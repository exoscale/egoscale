// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AccessKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccessKey) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Operations != nil {
			e.FieldStart("operations")
			e.ArrStart()
			for _, elem := range s.Operations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAccessKey = [8]string{
	0: "name",
	1: "key",
	2: "secret",
	3: "type",
	4: "version",
	5: "tags",
	6: "operations",
	7: "resources",
}

// Decode decodes AccessKey from json.
func (s *AccessKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessKey to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "operations":
			if err := func() error {
				s.Operations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operations\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]AccessKeyResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AccessKeyResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccessKey")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccessKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccessKeyOperation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccessKeyOperation) encodeFields(e *jx.Encoder) {
	{
		if s.Operation.Set {
			e.FieldStart("operation")
			s.Operation.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAccessKeyOperation = [2]string{
	0: "operation",
	1: "tags",
}

// Decode decodes AccessKeyOperation from json.
func (s *AccessKeyOperation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessKeyOperation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operation":
			if err := func() error {
				s.Operation.Reset()
				if err := s.Operation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operation\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccessKeyOperation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccessKeyOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessKeyOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AccessKeyResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AccessKeyResource) encodeFields(e *jx.Encoder) {
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
	{
		if s.ResourceMinusType.Set {
			e.FieldStart("resource-type")
			s.ResourceMinusType.Encode(e)
		}
	}
	{
		if s.ResourceMinusName.Set {
			e.FieldStart("resource-name")
			s.ResourceMinusName.Encode(e)
		}
	}
}

var jsonFieldsNameOfAccessKeyResource = [3]string{
	0: "domain",
	1: "resource-type",
	2: "resource-name",
}

// Decode decodes AccessKeyResource from json.
func (s *AccessKeyResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessKeyResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		case "resource-type":
			if err := func() error {
				s.ResourceMinusType.Reset()
				if err := s.ResourceMinusType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource-type\"")
			}
		case "resource-name":
			if err := func() error {
				s.ResourceMinusName.Reset()
				if err := s.ResourceMinusName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource-name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AccessKeyResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AccessKeyResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessKeyResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessKeyResourceDomain as json.
func (s AccessKeyResourceDomain) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AccessKeyResourceDomain from json.
func (s *AccessKeyResourceDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessKeyResourceDomain to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AccessKeyResourceDomain(v) {
	case AccessKeyResourceDomainPartner:
		*s = AccessKeyResourceDomainPartner
	case AccessKeyResourceDomainSos:
		*s = AccessKeyResourceDomainSos
	default:
		*s = AccessKeyResourceDomain(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccessKeyResourceDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessKeyResourceDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessKeyResourceResourceMinusType as json.
func (s AccessKeyResourceResourceMinusType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AccessKeyResourceResourceMinusType from json.
func (s *AccessKeyResourceResourceMinusType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessKeyResourceResourceMinusType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AccessKeyResourceResourceMinusType(v) {
	case AccessKeyResourceResourceMinusTypeProduct:
		*s = AccessKeyResourceResourceMinusTypeProduct
	case AccessKeyResourceResourceMinusTypeBucket:
		*s = AccessKeyResourceResourceMinusTypeBucket
	default:
		*s = AccessKeyResourceResourceMinusType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccessKeyResourceResourceMinusType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessKeyResourceResourceMinusType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessKeyType as json.
func (s AccessKeyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AccessKeyType from json.
func (s *AccessKeyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessKeyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AccessKeyType(v) {
	case AccessKeyTypeRestricted:
		*s = AccessKeyTypeRestricted
	case AccessKeyTypeUnrestricted:
		*s = AccessKeyTypeUnrestricted
	default:
		*s = AccessKeyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccessKeyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessKeyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessKeyVersion as json.
func (s AccessKeyVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AccessKeyVersion from json.
func (s *AccessKeyVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AccessKeyVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AccessKeyVersion(v) {
	case AccessKeyVersionV2:
		*s = AccessKeyVersionV2
	case AccessKeyVersionV1:
		*s = AccessKeyVersionV1
	default:
		*s = AccessKeyVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AccessKeyVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AccessKeyVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddExternalSourceToSecurityGroupReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddExternalSourceToSecurityGroupReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cidr")
		e.Str(s.Cidr)
	}
}

var jsonFieldsNameOfAddExternalSourceToSecurityGroupReq = [1]string{
	0: "cidr",
}

// Decode decodes AddExternalSourceToSecurityGroupReq from json.
func (s *AddExternalSourceToSecurityGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddExternalSourceToSecurityGroupReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cidr":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Cidr = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cidr\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddExternalSourceToSecurityGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddExternalSourceToSecurityGroupReq) {
					name = jsonFieldsNameOfAddExternalSourceToSecurityGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddExternalSourceToSecurityGroupReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddExternalSourceToSecurityGroupReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddInstanceProtectionOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddInstanceProtectionOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAddInstanceProtectionOK = [0]string{}

// Decode decodes AddInstanceProtectionOK from json.
func (s *AddInstanceProtectionOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddInstanceProtectionOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddInstanceProtectionOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddInstanceProtectionOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddInstanceProtectionOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddRuleToSecurityGroupReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddRuleToSecurityGroupReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("flow-direction")
		s.FlowMinusDirection.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Network.Set {
			e.FieldStart("network")
			s.Network.Encode(e)
		}
	}
	{
		if s.SecurityMinusGroup.Set {
			e.FieldStart("security-group")
			s.SecurityMinusGroup.Encode(e)
		}
	}
	{
		e.FieldStart("protocol")
		s.Protocol.Encode(e)
	}
	{
		if s.Icmp.Set {
			e.FieldStart("icmp")
			s.Icmp.Encode(e)
		}
	}
	{
		if s.StartMinusPort.Set {
			e.FieldStart("start-port")
			s.StartMinusPort.Encode(e)
		}
	}
	{
		if s.EndMinusPort.Set {
			e.FieldStart("end-port")
			s.EndMinusPort.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddRuleToSecurityGroupReq = [8]string{
	0: "flow-direction",
	1: "description",
	2: "network",
	3: "security-group",
	4: "protocol",
	5: "icmp",
	6: "start-port",
	7: "end-port",
}

// Decode decodes AddRuleToSecurityGroupReq from json.
func (s *AddRuleToSecurityGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRuleToSecurityGroupReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "flow-direction":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.FlowMinusDirection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flow-direction\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "network":
			if err := func() error {
				s.Network.Reset()
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security-group":
			if err := func() error {
				s.SecurityMinusGroup.Reset()
				if err := s.SecurityMinusGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security-group\"")
			}
		case "protocol":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "icmp":
			if err := func() error {
				s.Icmp.Reset()
				if err := s.Icmp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icmp\"")
			}
		case "start-port":
			if err := func() error {
				s.StartMinusPort.Reset()
				if err := s.StartMinusPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start-port\"")
			}
		case "end-port":
			if err := func() error {
				s.EndMinusPort.Reset()
				if err := s.EndMinusPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end-port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddRuleToSecurityGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddRuleToSecurityGroupReq) {
					name = jsonFieldsNameOfAddRuleToSecurityGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRuleToSecurityGroupReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRuleToSecurityGroupReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRuleToSecurityGroupReqFlowMinusDirection as json.
func (s AddRuleToSecurityGroupReqFlowMinusDirection) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddRuleToSecurityGroupReqFlowMinusDirection from json.
func (s *AddRuleToSecurityGroupReqFlowMinusDirection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRuleToSecurityGroupReqFlowMinusDirection to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddRuleToSecurityGroupReqFlowMinusDirection(v) {
	case AddRuleToSecurityGroupReqFlowMinusDirectionIngress:
		*s = AddRuleToSecurityGroupReqFlowMinusDirectionIngress
	case AddRuleToSecurityGroupReqFlowMinusDirectionEgress:
		*s = AddRuleToSecurityGroupReqFlowMinusDirectionEgress
	default:
		*s = AddRuleToSecurityGroupReqFlowMinusDirection(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddRuleToSecurityGroupReqFlowMinusDirection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRuleToSecurityGroupReqFlowMinusDirection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddRuleToSecurityGroupReqIcmp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddRuleToSecurityGroupReqIcmp) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddRuleToSecurityGroupReqIcmp = [2]string{
	0: "code",
	1: "type",
}

// Decode decodes AddRuleToSecurityGroupReqIcmp from json.
func (s *AddRuleToSecurityGroupReqIcmp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRuleToSecurityGroupReqIcmp to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddRuleToSecurityGroupReqIcmp")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRuleToSecurityGroupReqIcmp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRuleToSecurityGroupReqIcmp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRuleToSecurityGroupReqProtocol as json.
func (s AddRuleToSecurityGroupReqProtocol) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddRuleToSecurityGroupReqProtocol from json.
func (s *AddRuleToSecurityGroupReqProtocol) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRuleToSecurityGroupReqProtocol to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddRuleToSecurityGroupReqProtocol(v) {
	case AddRuleToSecurityGroupReqProtocolTCP:
		*s = AddRuleToSecurityGroupReqProtocolTCP
	case AddRuleToSecurityGroupReqProtocolEsp:
		*s = AddRuleToSecurityGroupReqProtocolEsp
	case AddRuleToSecurityGroupReqProtocolIcmp:
		*s = AddRuleToSecurityGroupReqProtocolIcmp
	case AddRuleToSecurityGroupReqProtocolUDP:
		*s = AddRuleToSecurityGroupReqProtocolUDP
	case AddRuleToSecurityGroupReqProtocolGre:
		*s = AddRuleToSecurityGroupReqProtocolGre
	case AddRuleToSecurityGroupReqProtocolAh:
		*s = AddRuleToSecurityGroupReqProtocolAh
	case AddRuleToSecurityGroupReqProtocolIpip:
		*s = AddRuleToSecurityGroupReqProtocolIpip
	case AddRuleToSecurityGroupReqProtocolIcmpv6:
		*s = AddRuleToSecurityGroupReqProtocolIcmpv6
	default:
		*s = AddRuleToSecurityGroupReqProtocol(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddRuleToSecurityGroupReqProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRuleToSecurityGroupReqProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttachInstanceToPrivateNetworkReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttachInstanceToPrivateNetworkReq) encodeFields(e *jx.Encoder) {
	{
		if s.IP.Set {
			e.FieldStart("ip")
			s.IP.Encode(e)
		}
	}
	{
		e.FieldStart("instance")
		s.Instance.Encode(e)
	}
}

var jsonFieldsNameOfAttachInstanceToPrivateNetworkReq = [2]string{
	0: "ip",
	1: "instance",
}

// Decode decodes AttachInstanceToPrivateNetworkReq from json.
func (s *AttachInstanceToPrivateNetworkReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachInstanceToPrivateNetworkReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ip":
			if err := func() error {
				s.IP.Reset()
				if err := s.IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		case "instance":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttachInstanceToPrivateNetworkReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttachInstanceToPrivateNetworkReq) {
					name = jsonFieldsNameOfAttachInstanceToPrivateNetworkReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachInstanceToPrivateNetworkReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachInstanceToPrivateNetworkReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttachInstanceToPrivateNetworkReqInstance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttachInstanceToPrivateNetworkReqInstance) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfAttachInstanceToPrivateNetworkReqInstance = [1]string{
	0: "id",
}

// Decode decodes AttachInstanceToPrivateNetworkReqInstance from json.
func (s *AttachInstanceToPrivateNetworkReqInstance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttachInstanceToPrivateNetworkReqInstance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttachInstanceToPrivateNetworkReqInstance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttachInstanceToPrivateNetworkReqInstance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttachInstanceToPrivateNetworkReqInstance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CopyTemplateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CopyTemplateReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("target-zone")
		s.TargetMinusZone.Encode(e)
	}
}

var jsonFieldsNameOfCopyTemplateReq = [1]string{
	0: "target-zone",
}

// Decode decodes CopyTemplateReq from json.
func (s *CopyTemplateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CopyTemplateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "target-zone":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.TargetMinusZone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target-zone\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CopyTemplateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCopyTemplateReq) {
					name = jsonFieldsNameOfCopyTemplateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CopyTemplateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CopyTemplateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAPIKeyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAPIKeyReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("role-id")
		json.EncodeUUID(e, s.RoleMinusID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfCreateAPIKeyReq = [2]string{
	0: "role-id",
	1: "name",
}

// Decode decodes CreateAPIKeyReq from json.
func (s *CreateAPIKeyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAPIKeyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "role-id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.RoleMinusID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role-id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAPIKeyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAPIKeyReq) {
					name = jsonFieldsNameOfCreateAPIKeyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAPIKeyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAPIKeyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAccessKeyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAccessKeyReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Operations != nil {
			e.FieldStart("operations")
			e.ArrStart()
			for _, elem := range s.Operations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateAccessKeyReq = [4]string{
	0: "name",
	1: "tags",
	2: "operations",
	3: "resources",
}

// Decode decodes CreateAccessKeyReq from json.
func (s *CreateAccessKeyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAccessKeyReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "operations":
			if err := func() error {
				s.Operations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Operations = append(s.Operations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operations\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]AccessKeyResource, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AccessKeyResource
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAccessKeyReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAccessKeyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAccessKeyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAntiAffinityGroupReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAntiAffinityGroupReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateAntiAffinityGroupReq = [2]string{
	0: "name",
	1: "description",
}

// Decode decodes CreateAntiAffinityGroupReq from json.
func (s *CreateAntiAffinityGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAntiAffinityGroupReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAntiAffinityGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAntiAffinityGroupReq) {
					name = jsonFieldsNameOfCreateAntiAffinityGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAntiAffinityGroupReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAntiAffinityGroupReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDNSDomainRecordReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDNSDomainRecordReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("content")
		e.Str(s.Content)
	}
	{
		if s.TTL.Set {
			e.FieldStart("ttl")
			s.TTL.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDNSDomainRecordReq = [5]string{
	0: "name",
	1: "type",
	2: "content",
	3: "ttl",
	4: "priority",
}

// Decode decodes CreateDNSDomainRecordReq from json.
func (s *CreateDNSDomainRecordReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDNSDomainRecordReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Content = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "ttl":
			if err := func() error {
				s.TTL.Reset()
				if err := s.TTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttl\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDNSDomainRecordReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDNSDomainRecordReq) {
					name = jsonFieldsNameOfCreateDNSDomainRecordReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDNSDomainRecordReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDNSDomainRecordReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDNSDomainRecordReqType as json.
func (s CreateDNSDomainRecordReqType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDNSDomainRecordReqType from json.
func (s *CreateDNSDomainRecordReqType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDNSDomainRecordReqType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDNSDomainRecordReqType(v) {
	case CreateDNSDomainRecordReqTypeNS:
		*s = CreateDNSDomainRecordReqTypeNS
	case CreateDNSDomainRecordReqTypeCAA:
		*s = CreateDNSDomainRecordReqTypeCAA
	case CreateDNSDomainRecordReqTypeNAPTR:
		*s = CreateDNSDomainRecordReqTypeNAPTR
	case CreateDNSDomainRecordReqTypePOOL:
		*s = CreateDNSDomainRecordReqTypePOOL
	case CreateDNSDomainRecordReqTypeA:
		*s = CreateDNSDomainRecordReqTypeA
	case CreateDNSDomainRecordReqTypeHINFO:
		*s = CreateDNSDomainRecordReqTypeHINFO
	case CreateDNSDomainRecordReqTypeCNAME:
		*s = CreateDNSDomainRecordReqTypeCNAME
	case CreateDNSDomainRecordReqTypeSOA:
		*s = CreateDNSDomainRecordReqTypeSOA
	case CreateDNSDomainRecordReqTypeSSHFP:
		*s = CreateDNSDomainRecordReqTypeSSHFP
	case CreateDNSDomainRecordReqTypeSRV:
		*s = CreateDNSDomainRecordReqTypeSRV
	case CreateDNSDomainRecordReqTypeAAAA:
		*s = CreateDNSDomainRecordReqTypeAAAA
	case CreateDNSDomainRecordReqTypeMX:
		*s = CreateDNSDomainRecordReqTypeMX
	case CreateDNSDomainRecordReqTypeDNSKEY:
		*s = CreateDNSDomainRecordReqTypeDNSKEY
	case CreateDNSDomainRecordReqTypeTXT:
		*s = CreateDNSDomainRecordReqTypeTXT
	case CreateDNSDomainRecordReqTypeDS:
		*s = CreateDNSDomainRecordReqTypeDS
	case CreateDNSDomainRecordReqTypePTR:
		*s = CreateDNSDomainRecordReqTypePTR
	case CreateDNSDomainRecordReqTypeALIAS:
		*s = CreateDNSDomainRecordReqTypeALIAS
	case CreateDNSDomainRecordReqTypeURL:
		*s = CreateDNSDomainRecordReqTypeURL
	case CreateDNSDomainRecordReqTypeSPF:
		*s = CreateDNSDomainRecordReqTypeSPF
	default:
		*s = CreateDNSDomainRecordReqType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDNSDomainRecordReqType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDNSDomainRecordReqType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDNSDomainReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDNSDomainReq) encodeFields(e *jx.Encoder) {
	{
		if s.UnicodeMinusName.Set {
			e.FieldStart("unicode-name")
			s.UnicodeMinusName.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDNSDomainReq = [1]string{
	0: "unicode-name",
}

// Decode decodes CreateDNSDomainReq from json.
func (s *CreateDNSDomainReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDNSDomainReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "unicode-name":
			if err := func() error {
				s.UnicodeMinusName.Reset()
				if err := s.UnicodeMinusName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unicode-name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDNSDomainReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDNSDomainReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDNSDomainReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasIntegrationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasIntegrationReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("integration-type")
		e.Str(s.IntegrationMinusType)
	}
	{
		e.FieldStart("source-service")
		s.SourceMinusService.Encode(e)
	}
	{
		e.FieldStart("dest-service")
		s.DestMinusService.Encode(e)
	}
	{
		if s.Settings != nil {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasIntegrationReq = [4]string{
	0: "integration-type",
	1: "source-service",
	2: "dest-service",
	3: "settings",
}

// Decode decodes CreateDbaasIntegrationReq from json.
func (s *CreateDbaasIntegrationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasIntegrationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "integration-type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.IntegrationMinusType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integration-type\"")
			}
		case "source-service":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.SourceMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source-service\"")
			}
		case "dest-service":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.DestMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dest-service\"")
			}
		case "settings":
			if err := func() error {
				s.Settings = nil
				var elem CreateDbaasIntegrationReqSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Settings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasIntegrationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasIntegrationReq) {
					name = jsonFieldsNameOfCreateDbaasIntegrationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasIntegrationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasIntegrationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasIntegrationReqSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasIntegrationReqSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasIntegrationReqSettings = [0]string{}

// Decode decodes CreateDbaasIntegrationReqSettings from json.
func (s *CreateDbaasIntegrationReqSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasIntegrationReqSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasIntegrationReqSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasIntegrationReqSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasIntegrationReqSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasKafkaUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasKafkaUserReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		s.Username.Encode(e)
	}
}

var jsonFieldsNameOfCreateDbaasKafkaUserReq = [1]string{
	0: "username",
}

// Decode decodes CreateDbaasKafkaUserReq from json.
func (s *CreateDbaasKafkaUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasKafkaUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasKafkaUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasKafkaUserReq) {
					name = jsonFieldsNameOfCreateDbaasKafkaUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasKafkaUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasKafkaUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasPostgresUserReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasPostgresUserReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		s.Username.Encode(e)
	}
	{
		if s.AllowMinusReplication.Set {
			e.FieldStart("allow-replication")
			s.AllowMinusReplication.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasPostgresUserReq = [2]string{
	0: "username",
	1: "allow-replication",
}

// Decode decodes CreateDbaasPostgresUserReq from json.
func (s *CreateDbaasPostgresUserReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasPostgresUserReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "allow-replication":
			if err := func() error {
				s.AllowMinusReplication.Reset()
				if err := s.AllowMinusReplication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow-replication\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasPostgresUserReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasPostgresUserReq) {
					name = jsonFieldsNameOfCreateDbaasPostgresUserReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasPostgresUserReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasPostgresUserReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceKafkaReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceKafkaReq) encodeFields(e *jx.Encoder) {
	{
		if s.AuthenticationMinusMethods.Set {
			e.FieldStart("authentication-methods")
			s.AuthenticationMinusMethods.Encode(e)
		}
	}
	{
		if s.KafkaMinusRestMinusEnabled.Set {
			e.FieldStart("kafka-rest-enabled")
			s.KafkaMinusRestMinusEnabled.Encode(e)
		}
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.KafkaMinusConnectMinusEnabled.Set {
			e.FieldStart("kafka-connect-enabled")
			s.KafkaMinusConnectMinusEnabled.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SchemaMinusRegistryMinusSettings != nil {
			e.FieldStart("schema-registry-settings")
			s.SchemaMinusRegistryMinusSettings.Encode(e)
		}
	}
	{
		if s.KafkaMinusRestMinusSettings != nil {
			e.FieldStart("kafka-rest-settings")
			s.KafkaMinusRestMinusSettings.Encode(e)
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.KafkaMinusConnectMinusSettings != nil {
			e.FieldStart("kafka-connect-settings")
			s.KafkaMinusConnectMinusSettings.Encode(e)
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.KafkaMinusSettings != nil {
			e.FieldStart("kafka-settings")
			s.KafkaMinusSettings.Encode(e)
		}
	}
	{
		if s.SchemaMinusRegistryMinusEnabled.Set {
			e.FieldStart("schema-registry-enabled")
			s.SchemaMinusRegistryMinusEnabled.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		e.FieldStart("plan")
		e.Str(s.Plan)
	}
}

var jsonFieldsNameOfCreateDbaasServiceKafkaReq = [14]string{
	0:  "authentication-methods",
	1:  "kafka-rest-enabled",
	2:  "integrations",
	3:  "kafka-connect-enabled",
	4:  "ip-filter",
	5:  "schema-registry-settings",
	6:  "kafka-rest-settings",
	7:  "termination-protection",
	8:  "kafka-connect-settings",
	9:  "maintenance",
	10: "kafka-settings",
	11: "schema-registry-enabled",
	12: "version",
	13: "plan",
}

// Decode decodes CreateDbaasServiceKafkaReq from json.
func (s *CreateDbaasServiceKafkaReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceKafkaReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "authentication-methods":
			if err := func() error {
				s.AuthenticationMinusMethods.Reset()
				if err := s.AuthenticationMinusMethods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authentication-methods\"")
			}
		case "kafka-rest-enabled":
			if err := func() error {
				s.KafkaMinusRestMinusEnabled.Reset()
				if err := s.KafkaMinusRestMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-rest-enabled\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]CreateDbaasServiceKafkaReqIntegrationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateDbaasServiceKafkaReqIntegrationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "kafka-connect-enabled":
			if err := func() error {
				s.KafkaMinusConnectMinusEnabled.Reset()
				if err := s.KafkaMinusConnectMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-connect-enabled\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "schema-registry-settings":
			if err := func() error {
				s.SchemaMinusRegistryMinusSettings = nil
				var elem CreateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.SchemaMinusRegistryMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema-registry-settings\"")
			}
		case "kafka-rest-settings":
			if err := func() error {
				s.KafkaMinusRestMinusSettings = nil
				var elem CreateDbaasServiceKafkaReqKafkaMinusRestMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.KafkaMinusRestMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-rest-settings\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "kafka-connect-settings":
			if err := func() error {
				s.KafkaMinusConnectMinusSettings = nil
				var elem CreateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.KafkaMinusConnectMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-connect-settings\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "kafka-settings":
			if err := func() error {
				s.KafkaMinusSettings = nil
				var elem CreateDbaasServiceKafkaReqKafkaMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.KafkaMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-settings\"")
			}
		case "schema-registry-enabled":
			if err := func() error {
				s.SchemaMinusRegistryMinusEnabled.Reset()
				if err := s.SchemaMinusRegistryMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema-registry-enabled\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "plan":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Plan = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceKafkaReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceKafkaReq) {
					name = jsonFieldsNameOfCreateDbaasServiceKafkaReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceKafkaReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceKafkaReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceKafkaReqAuthenticationMinusMethods) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceKafkaReqAuthenticationMinusMethods) encodeFields(e *jx.Encoder) {
	{
		if s.Certificate.Set {
			e.FieldStart("certificate")
			s.Certificate.Encode(e)
		}
	}
	{
		if s.Sasl.Set {
			e.FieldStart("sasl")
			s.Sasl.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceKafkaReqAuthenticationMinusMethods = [2]string{
	0: "certificate",
	1: "sasl",
}

// Decode decodes CreateDbaasServiceKafkaReqAuthenticationMinusMethods from json.
func (s *CreateDbaasServiceKafkaReqAuthenticationMinusMethods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceKafkaReqAuthenticationMinusMethods to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificate":
			if err := func() error {
				s.Certificate.Reset()
				if err := s.Certificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		case "sasl":
			if err := func() error {
				s.Sasl.Reset()
				if err := s.Sasl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sasl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceKafkaReqAuthenticationMinusMethods")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceKafkaReqAuthenticationMinusMethods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceKafkaReqAuthenticationMinusMethods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceKafkaReqIntegrationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceKafkaReqIntegrationsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.SourceMinusService.Set {
			e.FieldStart("source-service")
			s.SourceMinusService.Encode(e)
		}
	}
	{
		if s.DestMinusService.Set {
			e.FieldStart("dest-service")
			s.DestMinusService.Encode(e)
		}
	}
	{
		if s.Settings != nil {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceKafkaReqIntegrationsItem = [4]string{
	0: "type",
	1: "source-service",
	2: "dest-service",
	3: "settings",
}

// Decode decodes CreateDbaasServiceKafkaReqIntegrationsItem from json.
func (s *CreateDbaasServiceKafkaReqIntegrationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceKafkaReqIntegrationsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "source-service":
			if err := func() error {
				s.SourceMinusService.Reset()
				if err := s.SourceMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source-service\"")
			}
		case "dest-service":
			if err := func() error {
				s.DestMinusService.Reset()
				if err := s.DestMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dest-service\"")
			}
		case "settings":
			if err := func() error {
				s.Settings = nil
				var elem CreateDbaasServiceKafkaReqIntegrationsItemSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Settings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceKafkaReqIntegrationsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceKafkaReqIntegrationsItem) {
					name = jsonFieldsNameOfCreateDbaasServiceKafkaReqIntegrationsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceKafkaReqIntegrationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceKafkaReqIntegrationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceKafkaReqIntegrationsItemSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceKafkaReqIntegrationsItemSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServiceKafkaReqIntegrationsItemSettings = [0]string{}

// Decode decodes CreateDbaasServiceKafkaReqIntegrationsItemSettings from json.
func (s *CreateDbaasServiceKafkaReqIntegrationsItemSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceKafkaReqIntegrationsItemSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceKafkaReqIntegrationsItemSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceKafkaReqIntegrationsItemSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceKafkaReqIntegrationsItemSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings = [0]string{}

// Decode decodes CreateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings from json.
func (s *CreateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceKafkaReqKafkaMinusRestMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceKafkaReqKafkaMinusRestMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServiceKafkaReqKafkaMinusRestMinusSettings = [0]string{}

// Decode decodes CreateDbaasServiceKafkaReqKafkaMinusRestMinusSettings from json.
func (s *CreateDbaasServiceKafkaReqKafkaMinusRestMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceKafkaReqKafkaMinusRestMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceKafkaReqKafkaMinusRestMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceKafkaReqKafkaMinusRestMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceKafkaReqKafkaMinusRestMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceKafkaReqKafkaMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceKafkaReqKafkaMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServiceKafkaReqKafkaMinusSettings = [0]string{}

// Decode decodes CreateDbaasServiceKafkaReqKafkaMinusSettings from json.
func (s *CreateDbaasServiceKafkaReqKafkaMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceKafkaReqKafkaMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceKafkaReqKafkaMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceKafkaReqKafkaMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceKafkaReqKafkaMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceKafkaReqMaintenance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceKafkaReqMaintenance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dow")
		s.Dow.Encode(e)
	}
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfCreateDbaasServiceKafkaReqMaintenance = [2]string{
	0: "dow",
	1: "time",
}

// Decode decodes CreateDbaasServiceKafkaReqMaintenance from json.
func (s *CreateDbaasServiceKafkaReqMaintenance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceKafkaReqMaintenance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dow":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dow\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceKafkaReqMaintenance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceKafkaReqMaintenance) {
					name = jsonFieldsNameOfCreateDbaasServiceKafkaReqMaintenance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceKafkaReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceKafkaReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceKafkaReqMaintenanceDow as json.
func (s CreateDbaasServiceKafkaReqMaintenanceDow) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDbaasServiceKafkaReqMaintenanceDow from json.
func (s *CreateDbaasServiceKafkaReqMaintenanceDow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceKafkaReqMaintenanceDow to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDbaasServiceKafkaReqMaintenanceDow(v) {
	case CreateDbaasServiceKafkaReqMaintenanceDowSaturday:
		*s = CreateDbaasServiceKafkaReqMaintenanceDowSaturday
	case CreateDbaasServiceKafkaReqMaintenanceDowTuesday:
		*s = CreateDbaasServiceKafkaReqMaintenanceDowTuesday
	case CreateDbaasServiceKafkaReqMaintenanceDowNever:
		*s = CreateDbaasServiceKafkaReqMaintenanceDowNever
	case CreateDbaasServiceKafkaReqMaintenanceDowWednesday:
		*s = CreateDbaasServiceKafkaReqMaintenanceDowWednesday
	case CreateDbaasServiceKafkaReqMaintenanceDowSunday:
		*s = CreateDbaasServiceKafkaReqMaintenanceDowSunday
	case CreateDbaasServiceKafkaReqMaintenanceDowFriday:
		*s = CreateDbaasServiceKafkaReqMaintenanceDowFriday
	case CreateDbaasServiceKafkaReqMaintenanceDowMonday:
		*s = CreateDbaasServiceKafkaReqMaintenanceDowMonday
	case CreateDbaasServiceKafkaReqMaintenanceDowThursday:
		*s = CreateDbaasServiceKafkaReqMaintenanceDowThursday
	default:
		*s = CreateDbaasServiceKafkaReqMaintenanceDow(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDbaasServiceKafkaReqMaintenanceDow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceKafkaReqMaintenanceDow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings = [0]string{}

// Decode decodes CreateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings from json.
func (s *CreateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceMysqlReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceMysqlReq) encodeFields(e *jx.Encoder) {
	{
		if s.BackupMinusSchedule.Set {
			e.FieldStart("backup-schedule")
			s.BackupMinusSchedule.Encode(e)
		}
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.ForkMinusFromMinusService.Set {
			e.FieldStart("fork-from-service")
			s.ForkMinusFromMinusService.Encode(e)
		}
	}
	{
		if s.RecoveryMinusBackupMinusTime.Set {
			e.FieldStart("recovery-backup-time")
			s.RecoveryMinusBackupMinusTime.Encode(e)
		}
	}
	{
		if s.MysqlMinusSettings != nil {
			e.FieldStart("mysql-settings")
			s.MysqlMinusSettings.Encode(e)
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.AdminMinusUsername.Set {
			e.FieldStart("admin-username")
			s.AdminMinusUsername.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		e.FieldStart("plan")
		e.Str(s.Plan)
	}
	{
		if s.AdminMinusPassword.Set {
			e.FieldStart("admin-password")
			s.AdminMinusPassword.Encode(e)
		}
	}
	{
		if s.Migration.Set {
			e.FieldStart("migration")
			s.Migration.Encode(e)
		}
	}
	{
		if s.BinlogMinusRetentionMinusPeriod.Set {
			e.FieldStart("binlog-retention-period")
			s.BinlogMinusRetentionMinusPeriod.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceMysqlReq = [14]string{
	0:  "backup-schedule",
	1:  "integrations",
	2:  "ip-filter",
	3:  "termination-protection",
	4:  "fork-from-service",
	5:  "recovery-backup-time",
	6:  "mysql-settings",
	7:  "maintenance",
	8:  "admin-username",
	9:  "version",
	10: "plan",
	11: "admin-password",
	12: "migration",
	13: "binlog-retention-period",
}

// Decode decodes CreateDbaasServiceMysqlReq from json.
func (s *CreateDbaasServiceMysqlReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceMysqlReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backup-schedule":
			if err := func() error {
				s.BackupMinusSchedule.Reset()
				if err := s.BackupMinusSchedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-schedule\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]CreateDbaasServiceMysqlReqIntegrationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateDbaasServiceMysqlReqIntegrationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "fork-from-service":
			if err := func() error {
				s.ForkMinusFromMinusService.Reset()
				if err := s.ForkMinusFromMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork-from-service\"")
			}
		case "recovery-backup-time":
			if err := func() error {
				s.RecoveryMinusBackupMinusTime.Reset()
				if err := s.RecoveryMinusBackupMinusTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recovery-backup-time\"")
			}
		case "mysql-settings":
			if err := func() error {
				s.MysqlMinusSettings = nil
				var elem CreateDbaasServiceMysqlReqMysqlMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.MysqlMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mysql-settings\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "admin-username":
			if err := func() error {
				s.AdminMinusUsername.Reset()
				if err := s.AdminMinusUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin-username\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "plan":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Plan = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "admin-password":
			if err := func() error {
				s.AdminMinusPassword.Reset()
				if err := s.AdminMinusPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin-password\"")
			}
		case "migration":
			if err := func() error {
				s.Migration.Reset()
				if err := s.Migration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migration\"")
			}
		case "binlog-retention-period":
			if err := func() error {
				s.BinlogMinusRetentionMinusPeriod.Reset()
				if err := s.BinlogMinusRetentionMinusPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"binlog-retention-period\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceMysqlReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceMysqlReq) {
					name = jsonFieldsNameOfCreateDbaasServiceMysqlReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceMysqlReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceMysqlReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceMysqlReqBackupMinusSchedule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceMysqlReqBackupMinusSchedule) encodeFields(e *jx.Encoder) {
	{
		if s.BackupMinusHour.Set {
			e.FieldStart("backup-hour")
			s.BackupMinusHour.Encode(e)
		}
	}
	{
		if s.BackupMinusMinute.Set {
			e.FieldStart("backup-minute")
			s.BackupMinusMinute.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceMysqlReqBackupMinusSchedule = [2]string{
	0: "backup-hour",
	1: "backup-minute",
}

// Decode decodes CreateDbaasServiceMysqlReqBackupMinusSchedule from json.
func (s *CreateDbaasServiceMysqlReqBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceMysqlReqBackupMinusSchedule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backup-hour":
			if err := func() error {
				s.BackupMinusHour.Reset()
				if err := s.BackupMinusHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-hour\"")
			}
		case "backup-minute":
			if err := func() error {
				s.BackupMinusMinute.Reset()
				if err := s.BackupMinusMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-minute\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceMysqlReqBackupMinusSchedule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceMysqlReqBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceMysqlReqBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceMysqlReqIntegrationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceMysqlReqIntegrationsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.SourceMinusService.Set {
			e.FieldStart("source-service")
			s.SourceMinusService.Encode(e)
		}
	}
	{
		if s.DestMinusService.Set {
			e.FieldStart("dest-service")
			s.DestMinusService.Encode(e)
		}
	}
	{
		if s.Settings != nil {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceMysqlReqIntegrationsItem = [4]string{
	0: "type",
	1: "source-service",
	2: "dest-service",
	3: "settings",
}

// Decode decodes CreateDbaasServiceMysqlReqIntegrationsItem from json.
func (s *CreateDbaasServiceMysqlReqIntegrationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceMysqlReqIntegrationsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "source-service":
			if err := func() error {
				s.SourceMinusService.Reset()
				if err := s.SourceMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source-service\"")
			}
		case "dest-service":
			if err := func() error {
				s.DestMinusService.Reset()
				if err := s.DestMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dest-service\"")
			}
		case "settings":
			if err := func() error {
				s.Settings = nil
				var elem CreateDbaasServiceMysqlReqIntegrationsItemSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Settings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceMysqlReqIntegrationsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceMysqlReqIntegrationsItem) {
					name = jsonFieldsNameOfCreateDbaasServiceMysqlReqIntegrationsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceMysqlReqIntegrationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceMysqlReqIntegrationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceMysqlReqIntegrationsItemSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceMysqlReqIntegrationsItemSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServiceMysqlReqIntegrationsItemSettings = [0]string{}

// Decode decodes CreateDbaasServiceMysqlReqIntegrationsItemSettings from json.
func (s *CreateDbaasServiceMysqlReqIntegrationsItemSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceMysqlReqIntegrationsItemSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceMysqlReqIntegrationsItemSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceMysqlReqIntegrationsItemSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceMysqlReqIntegrationsItemSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceMysqlReqMaintenance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceMysqlReqMaintenance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dow")
		s.Dow.Encode(e)
	}
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfCreateDbaasServiceMysqlReqMaintenance = [2]string{
	0: "dow",
	1: "time",
}

// Decode decodes CreateDbaasServiceMysqlReqMaintenance from json.
func (s *CreateDbaasServiceMysqlReqMaintenance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceMysqlReqMaintenance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dow":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dow\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceMysqlReqMaintenance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceMysqlReqMaintenance) {
					name = jsonFieldsNameOfCreateDbaasServiceMysqlReqMaintenance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceMysqlReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceMysqlReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceMysqlReqMaintenanceDow as json.
func (s CreateDbaasServiceMysqlReqMaintenanceDow) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDbaasServiceMysqlReqMaintenanceDow from json.
func (s *CreateDbaasServiceMysqlReqMaintenanceDow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceMysqlReqMaintenanceDow to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDbaasServiceMysqlReqMaintenanceDow(v) {
	case CreateDbaasServiceMysqlReqMaintenanceDowSaturday:
		*s = CreateDbaasServiceMysqlReqMaintenanceDowSaturday
	case CreateDbaasServiceMysqlReqMaintenanceDowTuesday:
		*s = CreateDbaasServiceMysqlReqMaintenanceDowTuesday
	case CreateDbaasServiceMysqlReqMaintenanceDowNever:
		*s = CreateDbaasServiceMysqlReqMaintenanceDowNever
	case CreateDbaasServiceMysqlReqMaintenanceDowWednesday:
		*s = CreateDbaasServiceMysqlReqMaintenanceDowWednesday
	case CreateDbaasServiceMysqlReqMaintenanceDowSunday:
		*s = CreateDbaasServiceMysqlReqMaintenanceDowSunday
	case CreateDbaasServiceMysqlReqMaintenanceDowFriday:
		*s = CreateDbaasServiceMysqlReqMaintenanceDowFriday
	case CreateDbaasServiceMysqlReqMaintenanceDowMonday:
		*s = CreateDbaasServiceMysqlReqMaintenanceDowMonday
	case CreateDbaasServiceMysqlReqMaintenanceDowThursday:
		*s = CreateDbaasServiceMysqlReqMaintenanceDowThursday
	default:
		*s = CreateDbaasServiceMysqlReqMaintenanceDow(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDbaasServiceMysqlReqMaintenanceDow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceMysqlReqMaintenanceDow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceMysqlReqMigration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceMysqlReqMigration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.Ssl.Set {
			e.FieldStart("ssl")
			s.Ssl.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Dbname.Set {
			e.FieldStart("dbname")
			s.Dbname.Encode(e)
		}
	}
	{
		if s.IgnoreMinusDbs.Set {
			e.FieldStart("ignore-dbs")
			s.IgnoreMinusDbs.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceMysqlReqMigration = [8]string{
	0: "host",
	1: "port",
	2: "password",
	3: "ssl",
	4: "username",
	5: "dbname",
	6: "ignore-dbs",
	7: "method",
}

// Decode decodes CreateDbaasServiceMysqlReqMigration from json.
func (s *CreateDbaasServiceMysqlReqMigration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceMysqlReqMigration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "ssl":
			if err := func() error {
				s.Ssl.Reset()
				if err := s.Ssl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssl\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "dbname":
			if err := func() error {
				s.Dbname.Reset()
				if err := s.Dbname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbname\"")
			}
		case "ignore-dbs":
			if err := func() error {
				s.IgnoreMinusDbs.Reset()
				if err := s.IgnoreMinusDbs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore-dbs\"")
			}
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceMysqlReqMigration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceMysqlReqMigration) {
					name = jsonFieldsNameOfCreateDbaasServiceMysqlReqMigration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceMysqlReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceMysqlReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceMysqlReqMysqlMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceMysqlReqMysqlMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServiceMysqlReqMysqlMinusSettings = [0]string{}

// Decode decodes CreateDbaasServiceMysqlReqMysqlMinusSettings from json.
func (s *CreateDbaasServiceMysqlReqMysqlMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceMysqlReqMysqlMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceMysqlReqMysqlMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceMysqlReqMysqlMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceMysqlReqMysqlMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceOpensearchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceOpensearchReq) encodeFields(e *jx.Encoder) {
	{
		if s.MaxMinusIndexMinusCount.Set {
			e.FieldStart("max-index-count")
			s.MaxMinusIndexMinusCount.Encode(e)
		}
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.KeepMinusIndexMinusRefreshMinusInterval.Set {
			e.FieldStart("keep-index-refresh-interval")
			s.KeepMinusIndexMinusRefreshMinusInterval.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.ForkMinusFromMinusService.Set {
			e.FieldStart("fork-from-service")
			s.ForkMinusFromMinusService.Encode(e)
		}
	}
	{
		if s.IndexMinusPatterns != nil {
			e.FieldStart("index-patterns")
			e.ArrStart()
			for _, elem := range s.IndexMinusPatterns {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.IndexMinusTemplate.Set {
			e.FieldStart("index-template")
			s.IndexMinusTemplate.Encode(e)
		}
	}
	{
		if s.OpensearchMinusSettings != nil {
			e.FieldStart("opensearch-settings")
			s.OpensearchMinusSettings.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.RecoveryMinusBackupMinusName.Set {
			e.FieldStart("recovery-backup-name")
			s.RecoveryMinusBackupMinusName.Encode(e)
		}
	}
	{
		e.FieldStart("plan")
		e.Str(s.Plan)
	}
	{
		if s.OpensearchMinusDashboards.Set {
			e.FieldStart("opensearch-dashboards")
			s.OpensearchMinusDashboards.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceOpensearchReq = [14]string{
	0:  "max-index-count",
	1:  "integrations",
	2:  "keep-index-refresh-interval",
	3:  "ip-filter",
	4:  "termination-protection",
	5:  "fork-from-service",
	6:  "index-patterns",
	7:  "maintenance",
	8:  "index-template",
	9:  "opensearch-settings",
	10: "version",
	11: "recovery-backup-name",
	12: "plan",
	13: "opensearch-dashboards",
}

// Decode decodes CreateDbaasServiceOpensearchReq from json.
func (s *CreateDbaasServiceOpensearchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceOpensearchReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max-index-count":
			if err := func() error {
				s.MaxMinusIndexMinusCount.Reset()
				if err := s.MaxMinusIndexMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-index-count\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]CreateDbaasServiceOpensearchReqIntegrationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateDbaasServiceOpensearchReqIntegrationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "keep-index-refresh-interval":
			if err := func() error {
				s.KeepMinusIndexMinusRefreshMinusInterval.Reset()
				if err := s.KeepMinusIndexMinusRefreshMinusInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keep-index-refresh-interval\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "fork-from-service":
			if err := func() error {
				s.ForkMinusFromMinusService.Reset()
				if err := s.ForkMinusFromMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork-from-service\"")
			}
		case "index-patterns":
			if err := func() error {
				s.IndexMinusPatterns = make([]CreateDbaasServiceOpensearchReqIndexMinusPatternsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateDbaasServiceOpensearchReqIndexMinusPatternsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IndexMinusPatterns = append(s.IndexMinusPatterns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index-patterns\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "index-template":
			if err := func() error {
				s.IndexMinusTemplate.Reset()
				if err := s.IndexMinusTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index-template\"")
			}
		case "opensearch-settings":
			if err := func() error {
				s.OpensearchMinusSettings = nil
				var elem CreateDbaasServiceOpensearchReqOpensearchMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.OpensearchMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opensearch-settings\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "recovery-backup-name":
			if err := func() error {
				s.RecoveryMinusBackupMinusName.Reset()
				if err := s.RecoveryMinusBackupMinusName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recovery-backup-name\"")
			}
		case "plan":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Plan = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "opensearch-dashboards":
			if err := func() error {
				s.OpensearchMinusDashboards.Reset()
				if err := s.OpensearchMinusDashboards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opensearch-dashboards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceOpensearchReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000000,
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceOpensearchReq) {
					name = jsonFieldsNameOfCreateDbaasServiceOpensearchReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceOpensearchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceOpensearchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceOpensearchReqIndexMinusPatternsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceOpensearchReqIndexMinusPatternsItem) encodeFields(e *jx.Encoder) {
	{
		if s.MaxMinusIndexMinusCount.Set {
			e.FieldStart("max-index-count")
			s.MaxMinusIndexMinusCount.Encode(e)
		}
	}
	{
		if s.SortingMinusAlgorithm.Set {
			e.FieldStart("sorting-algorithm")
			s.SortingMinusAlgorithm.Encode(e)
		}
	}
	{
		if s.Pattern.Set {
			e.FieldStart("pattern")
			s.Pattern.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceOpensearchReqIndexMinusPatternsItem = [3]string{
	0: "max-index-count",
	1: "sorting-algorithm",
	2: "pattern",
}

// Decode decodes CreateDbaasServiceOpensearchReqIndexMinusPatternsItem from json.
func (s *CreateDbaasServiceOpensearchReqIndexMinusPatternsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceOpensearchReqIndexMinusPatternsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max-index-count":
			if err := func() error {
				s.MaxMinusIndexMinusCount.Reset()
				if err := s.MaxMinusIndexMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-index-count\"")
			}
		case "sorting-algorithm":
			if err := func() error {
				s.SortingMinusAlgorithm.Reset()
				if err := s.SortingMinusAlgorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sorting-algorithm\"")
			}
		case "pattern":
			if err := func() error {
				s.Pattern.Reset()
				if err := s.Pattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceOpensearchReqIndexMinusPatternsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceOpensearchReqIndexMinusPatternsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceOpensearchReqIndexMinusPatternsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm as json.
func (s CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm from json.
func (s *CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm(v) {
	case CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithmAlphabetical:
		*s = CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithmAlphabetical
	case CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithmCreationDate:
		*s = CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithmCreationDate
	default:
		*s = CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceOpensearchReqIndexMinusTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceOpensearchReqIndexMinusTemplate) encodeFields(e *jx.Encoder) {
	{
		if s.MappingMinusNestedMinusObjectsMinusLimit.Set {
			e.FieldStart("mapping-nested-objects-limit")
			s.MappingMinusNestedMinusObjectsMinusLimit.Encode(e)
		}
	}
	{
		if s.NumberMinusOfMinusReplicas.Set {
			e.FieldStart("number-of-replicas")
			s.NumberMinusOfMinusReplicas.Encode(e)
		}
	}
	{
		if s.NumberMinusOfMinusShards.Set {
			e.FieldStart("number-of-shards")
			s.NumberMinusOfMinusShards.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceOpensearchReqIndexMinusTemplate = [3]string{
	0: "mapping-nested-objects-limit",
	1: "number-of-replicas",
	2: "number-of-shards",
}

// Decode decodes CreateDbaasServiceOpensearchReqIndexMinusTemplate from json.
func (s *CreateDbaasServiceOpensearchReqIndexMinusTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceOpensearchReqIndexMinusTemplate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mapping-nested-objects-limit":
			if err := func() error {
				s.MappingMinusNestedMinusObjectsMinusLimit.Reset()
				if err := s.MappingMinusNestedMinusObjectsMinusLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapping-nested-objects-limit\"")
			}
		case "number-of-replicas":
			if err := func() error {
				s.NumberMinusOfMinusReplicas.Reset()
				if err := s.NumberMinusOfMinusReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number-of-replicas\"")
			}
		case "number-of-shards":
			if err := func() error {
				s.NumberMinusOfMinusShards.Reset()
				if err := s.NumberMinusOfMinusShards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number-of-shards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceOpensearchReqIndexMinusTemplate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceOpensearchReqIndexMinusTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceOpensearchReqIndexMinusTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceOpensearchReqIntegrationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceOpensearchReqIntegrationsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.SourceMinusService.Set {
			e.FieldStart("source-service")
			s.SourceMinusService.Encode(e)
		}
	}
	{
		if s.DestMinusService.Set {
			e.FieldStart("dest-service")
			s.DestMinusService.Encode(e)
		}
	}
	{
		if s.Settings != nil {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceOpensearchReqIntegrationsItem = [4]string{
	0: "type",
	1: "source-service",
	2: "dest-service",
	3: "settings",
}

// Decode decodes CreateDbaasServiceOpensearchReqIntegrationsItem from json.
func (s *CreateDbaasServiceOpensearchReqIntegrationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceOpensearchReqIntegrationsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "source-service":
			if err := func() error {
				s.SourceMinusService.Reset()
				if err := s.SourceMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source-service\"")
			}
		case "dest-service":
			if err := func() error {
				s.DestMinusService.Reset()
				if err := s.DestMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dest-service\"")
			}
		case "settings":
			if err := func() error {
				s.Settings = nil
				var elem CreateDbaasServiceOpensearchReqIntegrationsItemSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Settings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceOpensearchReqIntegrationsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceOpensearchReqIntegrationsItem) {
					name = jsonFieldsNameOfCreateDbaasServiceOpensearchReqIntegrationsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceOpensearchReqIntegrationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceOpensearchReqIntegrationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceOpensearchReqIntegrationsItemSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceOpensearchReqIntegrationsItemSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServiceOpensearchReqIntegrationsItemSettings = [0]string{}

// Decode decodes CreateDbaasServiceOpensearchReqIntegrationsItemSettings from json.
func (s *CreateDbaasServiceOpensearchReqIntegrationsItemSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceOpensearchReqIntegrationsItemSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceOpensearchReqIntegrationsItemSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceOpensearchReqIntegrationsItemSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceOpensearchReqIntegrationsItemSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceOpensearchReqMaintenance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceOpensearchReqMaintenance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dow")
		s.Dow.Encode(e)
	}
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfCreateDbaasServiceOpensearchReqMaintenance = [2]string{
	0: "dow",
	1: "time",
}

// Decode decodes CreateDbaasServiceOpensearchReqMaintenance from json.
func (s *CreateDbaasServiceOpensearchReqMaintenance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceOpensearchReqMaintenance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dow":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dow\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceOpensearchReqMaintenance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceOpensearchReqMaintenance) {
					name = jsonFieldsNameOfCreateDbaasServiceOpensearchReqMaintenance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceOpensearchReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceOpensearchReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceOpensearchReqMaintenanceDow as json.
func (s CreateDbaasServiceOpensearchReqMaintenanceDow) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDbaasServiceOpensearchReqMaintenanceDow from json.
func (s *CreateDbaasServiceOpensearchReqMaintenanceDow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceOpensearchReqMaintenanceDow to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDbaasServiceOpensearchReqMaintenanceDow(v) {
	case CreateDbaasServiceOpensearchReqMaintenanceDowSaturday:
		*s = CreateDbaasServiceOpensearchReqMaintenanceDowSaturday
	case CreateDbaasServiceOpensearchReqMaintenanceDowTuesday:
		*s = CreateDbaasServiceOpensearchReqMaintenanceDowTuesday
	case CreateDbaasServiceOpensearchReqMaintenanceDowNever:
		*s = CreateDbaasServiceOpensearchReqMaintenanceDowNever
	case CreateDbaasServiceOpensearchReqMaintenanceDowWednesday:
		*s = CreateDbaasServiceOpensearchReqMaintenanceDowWednesday
	case CreateDbaasServiceOpensearchReqMaintenanceDowSunday:
		*s = CreateDbaasServiceOpensearchReqMaintenanceDowSunday
	case CreateDbaasServiceOpensearchReqMaintenanceDowFriday:
		*s = CreateDbaasServiceOpensearchReqMaintenanceDowFriday
	case CreateDbaasServiceOpensearchReqMaintenanceDowMonday:
		*s = CreateDbaasServiceOpensearchReqMaintenanceDowMonday
	case CreateDbaasServiceOpensearchReqMaintenanceDowThursday:
		*s = CreateDbaasServiceOpensearchReqMaintenanceDowThursday
	default:
		*s = CreateDbaasServiceOpensearchReqMaintenanceDow(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDbaasServiceOpensearchReqMaintenanceDow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceOpensearchReqMaintenanceDow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceOpensearchReqOpensearchMinusDashboards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceOpensearchReqOpensearchMinusDashboards) encodeFields(e *jx.Encoder) {
	{
		if s.OpensearchMinusRequestMinusTimeout.Set {
			e.FieldStart("opensearch-request-timeout")
			s.OpensearchMinusRequestMinusTimeout.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.MaxMinusOldMinusSpaceMinusSize.Set {
			e.FieldStart("max-old-space-size")
			s.MaxMinusOldMinusSpaceMinusSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceOpensearchReqOpensearchMinusDashboards = [3]string{
	0: "opensearch-request-timeout",
	1: "enabled",
	2: "max-old-space-size",
}

// Decode decodes CreateDbaasServiceOpensearchReqOpensearchMinusDashboards from json.
func (s *CreateDbaasServiceOpensearchReqOpensearchMinusDashboards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceOpensearchReqOpensearchMinusDashboards to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "opensearch-request-timeout":
			if err := func() error {
				s.OpensearchMinusRequestMinusTimeout.Reset()
				if err := s.OpensearchMinusRequestMinusTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opensearch-request-timeout\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "max-old-space-size":
			if err := func() error {
				s.MaxMinusOldMinusSpaceMinusSize.Reset()
				if err := s.MaxMinusOldMinusSpaceMinusSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-old-space-size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceOpensearchReqOpensearchMinusDashboards")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceOpensearchReqOpensearchMinusDashboards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceOpensearchReqOpensearchMinusDashboards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceOpensearchReqOpensearchMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceOpensearchReqOpensearchMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServiceOpensearchReqOpensearchMinusSettings = [0]string{}

// Decode decodes CreateDbaasServiceOpensearchReqOpensearchMinusSettings from json.
func (s *CreateDbaasServiceOpensearchReqOpensearchMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceOpensearchReqOpensearchMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceOpensearchReqOpensearchMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceOpensearchReqOpensearchMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceOpensearchReqOpensearchMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServicePgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServicePgReq) encodeFields(e *jx.Encoder) {
	{
		if s.PgbouncerMinusSettings != nil {
			e.FieldStart("pgbouncer-settings")
			s.PgbouncerMinusSettings.Encode(e)
		}
	}
	{
		if s.BackupMinusSchedule.Set {
			e.FieldStart("backup-schedule")
			s.BackupMinusSchedule.Encode(e)
		}
	}
	{
		if s.Variant.Set {
			e.FieldStart("variant")
			s.Variant.Encode(e)
		}
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TimescaledbMinusSettings != nil {
			e.FieldStart("timescaledb-settings")
			s.TimescaledbMinusSettings.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.ForkMinusFromMinusService.Set {
			e.FieldStart("fork-from-service")
			s.ForkMinusFromMinusService.Encode(e)
		}
	}
	{
		if s.SynchronousMinusReplication.Set {
			e.FieldStart("synchronous-replication")
			s.SynchronousMinusReplication.Encode(e)
		}
	}
	{
		if s.RecoveryMinusBackupMinusTime.Set {
			e.FieldStart("recovery-backup-time")
			s.RecoveryMinusBackupMinusTime.Encode(e)
		}
	}
	{
		if s.PglookoutMinusSettings != nil {
			e.FieldStart("pglookout-settings")
			s.PglookoutMinusSettings.Encode(e)
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.AdminMinusUsername.Set {
			e.FieldStart("admin-username")
			s.AdminMinusUsername.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		e.FieldStart("plan")
		e.Str(s.Plan)
	}
	{
		if s.WorkMinusMem.Set {
			e.FieldStart("work-mem")
			s.WorkMinusMem.Encode(e)
		}
	}
	{
		if s.SharedMinusBuffersMinusPercentage.Set {
			e.FieldStart("shared-buffers-percentage")
			s.SharedMinusBuffersMinusPercentage.Encode(e)
		}
	}
	{
		if s.PgMinusSettings != nil {
			e.FieldStart("pg-settings")
			s.PgMinusSettings.Encode(e)
		}
	}
	{
		if s.AdminMinusPassword.Set {
			e.FieldStart("admin-password")
			s.AdminMinusPassword.Encode(e)
		}
	}
	{
		if s.Migration.Set {
			e.FieldStart("migration")
			s.Migration.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServicePgReq = [20]string{
	0:  "pgbouncer-settings",
	1:  "backup-schedule",
	2:  "variant",
	3:  "integrations",
	4:  "timescaledb-settings",
	5:  "ip-filter",
	6:  "termination-protection",
	7:  "fork-from-service",
	8:  "synchronous-replication",
	9:  "recovery-backup-time",
	10: "pglookout-settings",
	11: "maintenance",
	12: "admin-username",
	13: "version",
	14: "plan",
	15: "work-mem",
	16: "shared-buffers-percentage",
	17: "pg-settings",
	18: "admin-password",
	19: "migration",
}

// Decode decodes CreateDbaasServicePgReq from json.
func (s *CreateDbaasServicePgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServicePgReq to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pgbouncer-settings":
			if err := func() error {
				s.PgbouncerMinusSettings = nil
				var elem CreateDbaasServicePgReqPgbouncerMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PgbouncerMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pgbouncer-settings\"")
			}
		case "backup-schedule":
			if err := func() error {
				s.BackupMinusSchedule.Reset()
				if err := s.BackupMinusSchedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-schedule\"")
			}
		case "variant":
			if err := func() error {
				s.Variant.Reset()
				if err := s.Variant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variant\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]CreateDbaasServicePgReqIntegrationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateDbaasServicePgReqIntegrationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "timescaledb-settings":
			if err := func() error {
				s.TimescaledbMinusSettings = nil
				var elem CreateDbaasServicePgReqTimescaledbMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TimescaledbMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timescaledb-settings\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "fork-from-service":
			if err := func() error {
				s.ForkMinusFromMinusService.Reset()
				if err := s.ForkMinusFromMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork-from-service\"")
			}
		case "synchronous-replication":
			if err := func() error {
				s.SynchronousMinusReplication.Reset()
				if err := s.SynchronousMinusReplication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synchronous-replication\"")
			}
		case "recovery-backup-time":
			if err := func() error {
				s.RecoveryMinusBackupMinusTime.Reset()
				if err := s.RecoveryMinusBackupMinusTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recovery-backup-time\"")
			}
		case "pglookout-settings":
			if err := func() error {
				s.PglookoutMinusSettings = nil
				var elem CreateDbaasServicePgReqPglookoutMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PglookoutMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pglookout-settings\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "admin-username":
			if err := func() error {
				s.AdminMinusUsername.Reset()
				if err := s.AdminMinusUsername.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin-username\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "plan":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Plan = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "work-mem":
			if err := func() error {
				s.WorkMinusMem.Reset()
				if err := s.WorkMinusMem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"work-mem\"")
			}
		case "shared-buffers-percentage":
			if err := func() error {
				s.SharedMinusBuffersMinusPercentage.Reset()
				if err := s.SharedMinusBuffersMinusPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shared-buffers-percentage\"")
			}
		case "pg-settings":
			if err := func() error {
				s.PgMinusSettings = nil
				var elem CreateDbaasServicePgReqPgMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PgMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pg-settings\"")
			}
		case "admin-password":
			if err := func() error {
				s.AdminMinusPassword.Reset()
				if err := s.AdminMinusPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"admin-password\"")
			}
		case "migration":
			if err := func() error {
				s.Migration.Reset()
				if err := s.Migration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServicePgReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000000,
		0b01000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServicePgReq) {
					name = jsonFieldsNameOfCreateDbaasServicePgReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServicePgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServicePgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServicePgReqBackupMinusSchedule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServicePgReqBackupMinusSchedule) encodeFields(e *jx.Encoder) {
	{
		if s.BackupMinusHour.Set {
			e.FieldStart("backup-hour")
			s.BackupMinusHour.Encode(e)
		}
	}
	{
		if s.BackupMinusMinute.Set {
			e.FieldStart("backup-minute")
			s.BackupMinusMinute.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServicePgReqBackupMinusSchedule = [2]string{
	0: "backup-hour",
	1: "backup-minute",
}

// Decode decodes CreateDbaasServicePgReqBackupMinusSchedule from json.
func (s *CreateDbaasServicePgReqBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServicePgReqBackupMinusSchedule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backup-hour":
			if err := func() error {
				s.BackupMinusHour.Reset()
				if err := s.BackupMinusHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-hour\"")
			}
		case "backup-minute":
			if err := func() error {
				s.BackupMinusMinute.Reset()
				if err := s.BackupMinusMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-minute\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServicePgReqBackupMinusSchedule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServicePgReqBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServicePgReqBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServicePgReqIntegrationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServicePgReqIntegrationsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.SourceMinusService.Set {
			e.FieldStart("source-service")
			s.SourceMinusService.Encode(e)
		}
	}
	{
		if s.DestMinusService.Set {
			e.FieldStart("dest-service")
			s.DestMinusService.Encode(e)
		}
	}
	{
		if s.Settings != nil {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServicePgReqIntegrationsItem = [4]string{
	0: "type",
	1: "source-service",
	2: "dest-service",
	3: "settings",
}

// Decode decodes CreateDbaasServicePgReqIntegrationsItem from json.
func (s *CreateDbaasServicePgReqIntegrationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServicePgReqIntegrationsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "source-service":
			if err := func() error {
				s.SourceMinusService.Reset()
				if err := s.SourceMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source-service\"")
			}
		case "dest-service":
			if err := func() error {
				s.DestMinusService.Reset()
				if err := s.DestMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dest-service\"")
			}
		case "settings":
			if err := func() error {
				s.Settings = nil
				var elem CreateDbaasServicePgReqIntegrationsItemSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Settings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServicePgReqIntegrationsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServicePgReqIntegrationsItem) {
					name = jsonFieldsNameOfCreateDbaasServicePgReqIntegrationsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServicePgReqIntegrationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServicePgReqIntegrationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServicePgReqIntegrationsItemSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServicePgReqIntegrationsItemSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServicePgReqIntegrationsItemSettings = [0]string{}

// Decode decodes CreateDbaasServicePgReqIntegrationsItemSettings from json.
func (s *CreateDbaasServicePgReqIntegrationsItemSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServicePgReqIntegrationsItemSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServicePgReqIntegrationsItemSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServicePgReqIntegrationsItemSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServicePgReqIntegrationsItemSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServicePgReqMaintenance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServicePgReqMaintenance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dow")
		s.Dow.Encode(e)
	}
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfCreateDbaasServicePgReqMaintenance = [2]string{
	0: "dow",
	1: "time",
}

// Decode decodes CreateDbaasServicePgReqMaintenance from json.
func (s *CreateDbaasServicePgReqMaintenance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServicePgReqMaintenance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dow":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dow\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServicePgReqMaintenance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServicePgReqMaintenance) {
					name = jsonFieldsNameOfCreateDbaasServicePgReqMaintenance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServicePgReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServicePgReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServicePgReqMaintenanceDow as json.
func (s CreateDbaasServicePgReqMaintenanceDow) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDbaasServicePgReqMaintenanceDow from json.
func (s *CreateDbaasServicePgReqMaintenanceDow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServicePgReqMaintenanceDow to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDbaasServicePgReqMaintenanceDow(v) {
	case CreateDbaasServicePgReqMaintenanceDowSaturday:
		*s = CreateDbaasServicePgReqMaintenanceDowSaturday
	case CreateDbaasServicePgReqMaintenanceDowTuesday:
		*s = CreateDbaasServicePgReqMaintenanceDowTuesday
	case CreateDbaasServicePgReqMaintenanceDowNever:
		*s = CreateDbaasServicePgReqMaintenanceDowNever
	case CreateDbaasServicePgReqMaintenanceDowWednesday:
		*s = CreateDbaasServicePgReqMaintenanceDowWednesday
	case CreateDbaasServicePgReqMaintenanceDowSunday:
		*s = CreateDbaasServicePgReqMaintenanceDowSunday
	case CreateDbaasServicePgReqMaintenanceDowFriday:
		*s = CreateDbaasServicePgReqMaintenanceDowFriday
	case CreateDbaasServicePgReqMaintenanceDowMonday:
		*s = CreateDbaasServicePgReqMaintenanceDowMonday
	case CreateDbaasServicePgReqMaintenanceDowThursday:
		*s = CreateDbaasServicePgReqMaintenanceDowThursday
	default:
		*s = CreateDbaasServicePgReqMaintenanceDow(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDbaasServicePgReqMaintenanceDow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServicePgReqMaintenanceDow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServicePgReqMigration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServicePgReqMigration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.Ssl.Set {
			e.FieldStart("ssl")
			s.Ssl.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Dbname.Set {
			e.FieldStart("dbname")
			s.Dbname.Encode(e)
		}
	}
	{
		if s.IgnoreMinusDbs.Set {
			e.FieldStart("ignore-dbs")
			s.IgnoreMinusDbs.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServicePgReqMigration = [8]string{
	0: "host",
	1: "port",
	2: "password",
	3: "ssl",
	4: "username",
	5: "dbname",
	6: "ignore-dbs",
	7: "method",
}

// Decode decodes CreateDbaasServicePgReqMigration from json.
func (s *CreateDbaasServicePgReqMigration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServicePgReqMigration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "ssl":
			if err := func() error {
				s.Ssl.Reset()
				if err := s.Ssl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssl\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "dbname":
			if err := func() error {
				s.Dbname.Reset()
				if err := s.Dbname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbname\"")
			}
		case "ignore-dbs":
			if err := func() error {
				s.IgnoreMinusDbs.Reset()
				if err := s.IgnoreMinusDbs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore-dbs\"")
			}
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServicePgReqMigration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServicePgReqMigration) {
					name = jsonFieldsNameOfCreateDbaasServicePgReqMigration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServicePgReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServicePgReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServicePgReqPgMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServicePgReqPgMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServicePgReqPgMinusSettings = [0]string{}

// Decode decodes CreateDbaasServicePgReqPgMinusSettings from json.
func (s *CreateDbaasServicePgReqPgMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServicePgReqPgMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServicePgReqPgMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServicePgReqPgMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServicePgReqPgMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServicePgReqPgbouncerMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServicePgReqPgbouncerMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServicePgReqPgbouncerMinusSettings = [0]string{}

// Decode decodes CreateDbaasServicePgReqPgbouncerMinusSettings from json.
func (s *CreateDbaasServicePgReqPgbouncerMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServicePgReqPgbouncerMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServicePgReqPgbouncerMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServicePgReqPgbouncerMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServicePgReqPgbouncerMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServicePgReqPglookoutMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServicePgReqPglookoutMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServicePgReqPglookoutMinusSettings = [0]string{}

// Decode decodes CreateDbaasServicePgReqPglookoutMinusSettings from json.
func (s *CreateDbaasServicePgReqPglookoutMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServicePgReqPglookoutMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServicePgReqPglookoutMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServicePgReqPglookoutMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServicePgReqPglookoutMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServicePgReqTimescaledbMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServicePgReqTimescaledbMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServicePgReqTimescaledbMinusSettings = [0]string{}

// Decode decodes CreateDbaasServicePgReqTimescaledbMinusSettings from json.
func (s *CreateDbaasServicePgReqTimescaledbMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServicePgReqTimescaledbMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServicePgReqTimescaledbMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServicePgReqTimescaledbMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServicePgReqTimescaledbMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceRedisReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceRedisReq) encodeFields(e *jx.Encoder) {
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RedisMinusSettings != nil {
			e.FieldStart("redis-settings")
			s.RedisMinusSettings.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.ForkMinusFromMinusService.Set {
			e.FieldStart("fork-from-service")
			s.ForkMinusFromMinusService.Encode(e)
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.RecoveryMinusBackupMinusName.Set {
			e.FieldStart("recovery-backup-name")
			s.RecoveryMinusBackupMinusName.Encode(e)
		}
	}
	{
		e.FieldStart("plan")
		e.Str(s.Plan)
	}
	{
		if s.Migration.Set {
			e.FieldStart("migration")
			s.Migration.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceRedisReq = [9]string{
	0: "integrations",
	1: "redis-settings",
	2: "ip-filter",
	3: "termination-protection",
	4: "fork-from-service",
	5: "maintenance",
	6: "recovery-backup-name",
	7: "plan",
	8: "migration",
}

// Decode decodes CreateDbaasServiceRedisReq from json.
func (s *CreateDbaasServiceRedisReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceRedisReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "integrations":
			if err := func() error {
				s.Integrations = make([]CreateDbaasServiceRedisReqIntegrationsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateDbaasServiceRedisReqIntegrationsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "redis-settings":
			if err := func() error {
				s.RedisMinusSettings = nil
				var elem CreateDbaasServiceRedisReqRedisMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RedisMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redis-settings\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "fork-from-service":
			if err := func() error {
				s.ForkMinusFromMinusService.Reset()
				if err := s.ForkMinusFromMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fork-from-service\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "recovery-backup-name":
			if err := func() error {
				s.RecoveryMinusBackupMinusName.Reset()
				if err := s.RecoveryMinusBackupMinusName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recovery-backup-name\"")
			}
		case "plan":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Plan = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "migration":
			if err := func() error {
				s.Migration.Reset()
				if err := s.Migration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceRedisReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceRedisReq) {
					name = jsonFieldsNameOfCreateDbaasServiceRedisReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceRedisReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceRedisReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceRedisReqIntegrationsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceRedisReqIntegrationsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.SourceMinusService.Set {
			e.FieldStart("source-service")
			s.SourceMinusService.Encode(e)
		}
	}
	{
		if s.DestMinusService.Set {
			e.FieldStart("dest-service")
			s.DestMinusService.Encode(e)
		}
	}
	{
		if s.Settings != nil {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceRedisReqIntegrationsItem = [4]string{
	0: "type",
	1: "source-service",
	2: "dest-service",
	3: "settings",
}

// Decode decodes CreateDbaasServiceRedisReqIntegrationsItem from json.
func (s *CreateDbaasServiceRedisReqIntegrationsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceRedisReqIntegrationsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "source-service":
			if err := func() error {
				s.SourceMinusService.Reset()
				if err := s.SourceMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source-service\"")
			}
		case "dest-service":
			if err := func() error {
				s.DestMinusService.Reset()
				if err := s.DestMinusService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dest-service\"")
			}
		case "settings":
			if err := func() error {
				s.Settings = nil
				var elem CreateDbaasServiceRedisReqIntegrationsItemSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Settings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceRedisReqIntegrationsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceRedisReqIntegrationsItem) {
					name = jsonFieldsNameOfCreateDbaasServiceRedisReqIntegrationsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceRedisReqIntegrationsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceRedisReqIntegrationsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceRedisReqIntegrationsItemSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceRedisReqIntegrationsItemSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServiceRedisReqIntegrationsItemSettings = [0]string{}

// Decode decodes CreateDbaasServiceRedisReqIntegrationsItemSettings from json.
func (s *CreateDbaasServiceRedisReqIntegrationsItemSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceRedisReqIntegrationsItemSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceRedisReqIntegrationsItemSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceRedisReqIntegrationsItemSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceRedisReqIntegrationsItemSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceRedisReqMaintenance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceRedisReqMaintenance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dow")
		s.Dow.Encode(e)
	}
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfCreateDbaasServiceRedisReqMaintenance = [2]string{
	0: "dow",
	1: "time",
}

// Decode decodes CreateDbaasServiceRedisReqMaintenance from json.
func (s *CreateDbaasServiceRedisReqMaintenance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceRedisReqMaintenance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dow":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dow\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceRedisReqMaintenance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceRedisReqMaintenance) {
					name = jsonFieldsNameOfCreateDbaasServiceRedisReqMaintenance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceRedisReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceRedisReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceRedisReqMaintenanceDow as json.
func (s CreateDbaasServiceRedisReqMaintenanceDow) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateDbaasServiceRedisReqMaintenanceDow from json.
func (s *CreateDbaasServiceRedisReqMaintenanceDow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceRedisReqMaintenanceDow to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateDbaasServiceRedisReqMaintenanceDow(v) {
	case CreateDbaasServiceRedisReqMaintenanceDowSaturday:
		*s = CreateDbaasServiceRedisReqMaintenanceDowSaturday
	case CreateDbaasServiceRedisReqMaintenanceDowTuesday:
		*s = CreateDbaasServiceRedisReqMaintenanceDowTuesday
	case CreateDbaasServiceRedisReqMaintenanceDowNever:
		*s = CreateDbaasServiceRedisReqMaintenanceDowNever
	case CreateDbaasServiceRedisReqMaintenanceDowWednesday:
		*s = CreateDbaasServiceRedisReqMaintenanceDowWednesday
	case CreateDbaasServiceRedisReqMaintenanceDowSunday:
		*s = CreateDbaasServiceRedisReqMaintenanceDowSunday
	case CreateDbaasServiceRedisReqMaintenanceDowFriday:
		*s = CreateDbaasServiceRedisReqMaintenanceDowFriday
	case CreateDbaasServiceRedisReqMaintenanceDowMonday:
		*s = CreateDbaasServiceRedisReqMaintenanceDowMonday
	case CreateDbaasServiceRedisReqMaintenanceDowThursday:
		*s = CreateDbaasServiceRedisReqMaintenanceDowThursday
	default:
		*s = CreateDbaasServiceRedisReqMaintenanceDow(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateDbaasServiceRedisReqMaintenanceDow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceRedisReqMaintenanceDow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceRedisReqMigration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceRedisReqMigration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.Ssl.Set {
			e.FieldStart("ssl")
			s.Ssl.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Dbname.Set {
			e.FieldStart("dbname")
			s.Dbname.Encode(e)
		}
	}
	{
		if s.IgnoreMinusDbs.Set {
			e.FieldStart("ignore-dbs")
			s.IgnoreMinusDbs.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasServiceRedisReqMigration = [8]string{
	0: "host",
	1: "port",
	2: "password",
	3: "ssl",
	4: "username",
	5: "dbname",
	6: "ignore-dbs",
	7: "method",
}

// Decode decodes CreateDbaasServiceRedisReqMigration from json.
func (s *CreateDbaasServiceRedisReqMigration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceRedisReqMigration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "ssl":
			if err := func() error {
				s.Ssl.Reset()
				if err := s.Ssl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssl\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "dbname":
			if err := func() error {
				s.Dbname.Reset()
				if err := s.Dbname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbname\"")
			}
		case "ignore-dbs":
			if err := func() error {
				s.IgnoreMinusDbs.Reset()
				if err := s.IgnoreMinusDbs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore-dbs\"")
			}
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceRedisReqMigration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasServiceRedisReqMigration) {
					name = jsonFieldsNameOfCreateDbaasServiceRedisReqMigration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceRedisReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceRedisReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasServiceRedisReqRedisMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasServiceRedisReqRedisMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateDbaasServiceRedisReqRedisMinusSettings = [0]string{}

// Decode decodes CreateDbaasServiceRedisReqRedisMinusSettings from json.
func (s *CreateDbaasServiceRedisReqRedisMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasServiceRedisReqRedisMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasServiceRedisReqRedisMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasServiceRedisReqRedisMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasServiceRedisReqRedisMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateDbaasTaskMigrationCheckReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateDbaasTaskMigrationCheckReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source-service-uri")
		e.Str(s.SourceMinusServiceMinusURI)
	}
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
	{
		if s.IgnoreMinusDbs.Set {
			e.FieldStart("ignore-dbs")
			s.IgnoreMinusDbs.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateDbaasTaskMigrationCheckReq = [3]string{
	0: "source-service-uri",
	1: "method",
	2: "ignore-dbs",
}

// Decode decodes CreateDbaasTaskMigrationCheckReq from json.
func (s *CreateDbaasTaskMigrationCheckReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateDbaasTaskMigrationCheckReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source-service-uri":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SourceMinusServiceMinusURI = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source-service-uri\"")
			}
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "ignore-dbs":
			if err := func() error {
				s.IgnoreMinusDbs.Reset()
				if err := s.IgnoreMinusDbs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore-dbs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateDbaasTaskMigrationCheckReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateDbaasTaskMigrationCheckReq) {
					name = jsonFieldsNameOfCreateDbaasTaskMigrationCheckReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateDbaasTaskMigrationCheckReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateDbaasTaskMigrationCheckReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateElasticIPReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateElasticIPReq) encodeFields(e *jx.Encoder) {
	{
		if s.Addressfamily.Set {
			e.FieldStart("addressfamily")
			s.Addressfamily.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Healthcheck.Set {
			e.FieldStart("healthcheck")
			s.Healthcheck.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateElasticIPReq = [4]string{
	0: "addressfamily",
	1: "description",
	2: "healthcheck",
	3: "labels",
}

// Decode decodes CreateElasticIPReq from json.
func (s *CreateElasticIPReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateElasticIPReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addressfamily":
			if err := func() error {
				s.Addressfamily.Reset()
				if err := s.Addressfamily.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressfamily\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "healthcheck":
			if err := func() error {
				s.Healthcheck.Reset()
				if err := s.Healthcheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthcheck\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateElasticIPReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateElasticIPReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateElasticIPReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateElasticIPReqAddressfamily as json.
func (s CreateElasticIPReqAddressfamily) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateElasticIPReqAddressfamily from json.
func (s *CreateElasticIPReqAddressfamily) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateElasticIPReqAddressfamily to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateElasticIPReqAddressfamily(v) {
	case CreateElasticIPReqAddressfamilyInet4:
		*s = CreateElasticIPReqAddressfamilyInet4
	case CreateElasticIPReqAddressfamilyInet6:
		*s = CreateElasticIPReqAddressfamilyInet6
	default:
		*s = CreateElasticIPReqAddressfamily(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateElasticIPReqAddressfamily) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateElasticIPReqAddressfamily) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateIamRoleReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateIamRoleReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Editable.Set {
			e.FieldStart("editable")
			s.Editable.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
	{
		if s.Policy.Set {
			e.FieldStart("policy")
			s.Policy.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateIamRoleReq = [5]string{
	0: "name",
	1: "description",
	2: "editable",
	3: "labels",
	4: "policy",
}

// Decode decodes CreateIamRoleReq from json.
func (s *CreateIamRoleReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateIamRoleReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "editable":
			if err := func() error {
				s.Editable.Reset()
				if err := s.Editable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"editable\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "policy":
			if err := func() error {
				s.Policy.Reset()
				if err := s.Policy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateIamRoleReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateIamRoleReq) {
					name = jsonFieldsNameOfCreateIamRoleReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateIamRoleReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateIamRoleReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateLoadBalancerReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateLoadBalancerReq) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateLoadBalancerReq = [3]string{
	0: "description",
	1: "name",
	2: "labels",
}

// Decode decodes CreateLoadBalancerReq from json.
func (s *CreateLoadBalancerReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateLoadBalancerReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateLoadBalancerReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateLoadBalancerReq) {
					name = jsonFieldsNameOfCreateLoadBalancerReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateLoadBalancerReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateLoadBalancerReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatePrivateNetworkReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatePrivateNetworkReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Netmask.Set {
			e.FieldStart("netmask")
			s.Netmask.Encode(e)
		}
	}
	{
		if s.StartMinusIP.Set {
			e.FieldStart("start-ip")
			s.StartMinusIP.Encode(e)
		}
	}
	{
		if s.EndMinusIP.Set {
			e.FieldStart("end-ip")
			s.EndMinusIP.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreatePrivateNetworkReq = [6]string{
	0: "name",
	1: "description",
	2: "netmask",
	3: "start-ip",
	4: "end-ip",
	5: "labels",
}

// Decode decodes CreatePrivateNetworkReq from json.
func (s *CreatePrivateNetworkReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatePrivateNetworkReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "netmask":
			if err := func() error {
				s.Netmask.Reset()
				if err := s.Netmask.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"netmask\"")
			}
		case "start-ip":
			if err := func() error {
				s.StartMinusIP.Reset()
				if err := s.StartMinusIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start-ip\"")
			}
		case "end-ip":
			if err := func() error {
				s.EndMinusIP.Reset()
				if err := s.EndMinusIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end-ip\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatePrivateNetworkReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatePrivateNetworkReq) {
					name = jsonFieldsNameOfCreatePrivateNetworkReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatePrivateNetworkReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatePrivateNetworkReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSecurityGroupReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSecurityGroupReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateSecurityGroupReq = [2]string{
	0: "name",
	1: "description",
}

// Decode decodes CreateSecurityGroupReq from json.
func (s *CreateSecurityGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSecurityGroupReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSecurityGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSecurityGroupReq) {
					name = jsonFieldsNameOfCreateSecurityGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSecurityGroupReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSecurityGroupReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSksClusterReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSksClusterReq) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
	{
		if s.Cni.Set {
			e.FieldStart("cni")
			s.Cni.Encode(e)
		}
	}
	{
		if s.AutoMinusUpgrade.Set {
			e.FieldStart("auto-upgrade")
			s.AutoMinusUpgrade.Encode(e)
		}
	}
	{
		if s.Oidc.Set {
			e.FieldStart("oidc")
			s.Oidc.Encode(e)
		}
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("level")
		s.Level.Encode(e)
	}
	{
		if s.Addons != nil {
			e.FieldStart("addons")
			e.ArrStart()
			for _, elem := range s.Addons {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfCreateSksClusterReq = [9]string{
	0: "description",
	1: "labels",
	2: "cni",
	3: "auto-upgrade",
	4: "oidc",
	5: "name",
	6: "level",
	7: "addons",
	8: "version",
}

// Decode decodes CreateSksClusterReq from json.
func (s *CreateSksClusterReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSksClusterReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "cni":
			if err := func() error {
				s.Cni.Reset()
				if err := s.Cni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cni\"")
			}
		case "auto-upgrade":
			if err := func() error {
				s.AutoMinusUpgrade.Reset()
				if err := s.AutoMinusUpgrade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto-upgrade\"")
			}
		case "oidc":
			if err := func() error {
				s.Oidc.Reset()
				if err := s.Oidc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidc\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "level":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "addons":
			if err := func() error {
				s.Addons = make([]CreateSksClusterReqAddonsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateSksClusterReqAddonsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Addons = append(s.Addons, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addons\"")
			}
		case "version":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSksClusterReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01100000,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSksClusterReq) {
					name = jsonFieldsNameOfCreateSksClusterReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSksClusterReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSksClusterReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSksClusterReqAddonsItem as json.
func (s CreateSksClusterReqAddonsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateSksClusterReqAddonsItem from json.
func (s *CreateSksClusterReqAddonsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSksClusterReqAddonsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateSksClusterReqAddonsItem(v) {
	case CreateSksClusterReqAddonsItemExoscaleCloudController:
		*s = CreateSksClusterReqAddonsItemExoscaleCloudController
	case CreateSksClusterReqAddonsItemMetricsServer:
		*s = CreateSksClusterReqAddonsItemMetricsServer
	default:
		*s = CreateSksClusterReqAddonsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateSksClusterReqAddonsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSksClusterReqAddonsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSksClusterReqCni as json.
func (s CreateSksClusterReqCni) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateSksClusterReqCni from json.
func (s *CreateSksClusterReqCni) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSksClusterReqCni to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateSksClusterReqCni(v) {
	case CreateSksClusterReqCniCalico:
		*s = CreateSksClusterReqCniCalico
	case CreateSksClusterReqCniCilium:
		*s = CreateSksClusterReqCniCilium
	default:
		*s = CreateSksClusterReqCni(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateSksClusterReqCni) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSksClusterReqCni) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSksClusterReqLevel as json.
func (s CreateSksClusterReqLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateSksClusterReqLevel from json.
func (s *CreateSksClusterReqLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSksClusterReqLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateSksClusterReqLevel(v) {
	case CreateSksClusterReqLevelStarter:
		*s = CreateSksClusterReqLevelStarter
	case CreateSksClusterReqLevelPro:
		*s = CreateSksClusterReqLevelPro
	default:
		*s = CreateSksClusterReqLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateSksClusterReqLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSksClusterReqLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DNSDomain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DNSDomain) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedMinusAt.Set {
			e.FieldStart("created-at")
			s.CreatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UnicodeMinusName.Set {
			e.FieldStart("unicode-name")
			s.UnicodeMinusName.Encode(e)
		}
	}
}

var jsonFieldsNameOfDNSDomain = [3]string{
	0: "id",
	1: "created-at",
	2: "unicode-name",
}

// Decode decodes DNSDomain from json.
func (s *DNSDomain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DNSDomain to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "created-at":
			if err := func() error {
				s.CreatedMinusAt.Reset()
				if err := s.CreatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created-at\"")
			}
		case "unicode-name":
			if err := func() error {
				s.UnicodeMinusName.Reset()
				if err := s.UnicodeMinusName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unicode-name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DNSDomain")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DNSDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DNSDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DNSDomainRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DNSDomainRecord) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.TTL.Set {
			e.FieldStart("ttl")
			s.TTL.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.CreatedMinusAt.Set {
			e.FieldStart("created-at")
			s.CreatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedMinusAt.Set {
			e.FieldStart("updated-at")
			s.UpdatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfDNSDomainRecord = [8]string{
	0: "id",
	1: "priority",
	2: "content",
	3: "type",
	4: "ttl",
	5: "name",
	6: "created-at",
	7: "updated-at",
}

// Decode decodes DNSDomainRecord from json.
func (s *DNSDomainRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DNSDomainRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "ttl":
			if err := func() error {
				s.TTL.Reset()
				if err := s.TTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttl\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "created-at":
			if err := func() error {
				s.CreatedMinusAt.Reset()
				if err := s.CreatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created-at\"")
			}
		case "updated-at":
			if err := func() error {
				s.UpdatedMinusAt.Reset()
				if err := s.UpdatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated-at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DNSDomainRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DNSDomainRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DNSDomainRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DNSDomainRecordType as json.
func (s DNSDomainRecordType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DNSDomainRecordType from json.
func (s *DNSDomainRecordType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DNSDomainRecordType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DNSDomainRecordType(v) {
	case DNSDomainRecordTypeNS:
		*s = DNSDomainRecordTypeNS
	case DNSDomainRecordTypeCAA:
		*s = DNSDomainRecordTypeCAA
	case DNSDomainRecordTypeNAPTR:
		*s = DNSDomainRecordTypeNAPTR
	case DNSDomainRecordTypeCDNSKEY:
		*s = DNSDomainRecordTypeCDNSKEY
	case DNSDomainRecordTypePOOL:
		*s = DNSDomainRecordTypePOOL
	case DNSDomainRecordTypeA:
		*s = DNSDomainRecordTypeA
	case DNSDomainRecordTypeHINFO:
		*s = DNSDomainRecordTypeHINFO
	case DNSDomainRecordTypeCNAME:
		*s = DNSDomainRecordTypeCNAME
	case DNSDomainRecordTypeSOA:
		*s = DNSDomainRecordTypeSOA
	case DNSDomainRecordTypeSSHFP:
		*s = DNSDomainRecordTypeSSHFP
	case DNSDomainRecordTypeSRV:
		*s = DNSDomainRecordTypeSRV
	case DNSDomainRecordTypeAAAA:
		*s = DNSDomainRecordTypeAAAA
	case DNSDomainRecordTypeMX:
		*s = DNSDomainRecordTypeMX
	case DNSDomainRecordTypeDNSKEY:
		*s = DNSDomainRecordTypeDNSKEY
	case DNSDomainRecordTypeTXT:
		*s = DNSDomainRecordTypeTXT
	case DNSDomainRecordTypeDS:
		*s = DNSDomainRecordTypeDS
	case DNSDomainRecordTypePTR:
		*s = DNSDomainRecordTypePTR
	case DNSDomainRecordTypeALIAS:
		*s = DNSDomainRecordTypeALIAS
	case DNSDomainRecordTypeURL:
		*s = DNSDomainRecordTypeURL
	case DNSDomainRecordTypeCDS:
		*s = DNSDomainRecordTypeCDS
	case DNSDomainRecordTypeSPF:
		*s = DNSDomainRecordTypeSPF
	default:
		*s = DNSDomainRecordType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DNSDomainRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DNSDomainRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasBackupConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasBackupConfig) encodeFields(e *jx.Encoder) {
	{
		if s.MaxMinusCount.Set {
			e.FieldStart("max-count")
			s.MaxMinusCount.Encode(e)
		}
	}
	{
		if s.Interval.Set {
			e.FieldStart("interval")
			s.Interval.Encode(e)
		}
	}
	{
		if s.RecoveryMinusMode.Set {
			e.FieldStart("recovery-mode")
			s.RecoveryMinusMode.Encode(e)
		}
	}
	{
		if s.FrequentMinusIntervalMinusMinutes.Set {
			e.FieldStart("frequent-interval-minutes")
			s.FrequentMinusIntervalMinusMinutes.Encode(e)
		}
	}
	{
		if s.FrequentMinusOldestMinusAgeMinusMinutes.Set {
			e.FieldStart("frequent-oldest-age-minutes")
			s.FrequentMinusOldestMinusAgeMinusMinutes.Encode(e)
		}
	}
	{
		if s.InfrequentMinusIntervalMinusMinutes.Set {
			e.FieldStart("infrequent-interval-minutes")
			s.InfrequentMinusIntervalMinusMinutes.Encode(e)
		}
	}
	{
		if s.InfrequentMinusOldestMinusAgeMinusMinutes.Set {
			e.FieldStart("infrequent-oldest-age-minutes")
			s.InfrequentMinusOldestMinusAgeMinusMinutes.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasBackupConfig = [7]string{
	0: "max-count",
	1: "interval",
	2: "recovery-mode",
	3: "frequent-interval-minutes",
	4: "frequent-oldest-age-minutes",
	5: "infrequent-interval-minutes",
	6: "infrequent-oldest-age-minutes",
}

// Decode decodes DbaasBackupConfig from json.
func (s *DbaasBackupConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasBackupConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max-count":
			if err := func() error {
				s.MaxMinusCount.Reset()
				if err := s.MaxMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-count\"")
			}
		case "interval":
			if err := func() error {
				s.Interval.Reset()
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval\"")
			}
		case "recovery-mode":
			if err := func() error {
				s.RecoveryMinusMode.Reset()
				if err := s.RecoveryMinusMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recovery-mode\"")
			}
		case "frequent-interval-minutes":
			if err := func() error {
				s.FrequentMinusIntervalMinusMinutes.Reset()
				if err := s.FrequentMinusIntervalMinusMinutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequent-interval-minutes\"")
			}
		case "frequent-oldest-age-minutes":
			if err := func() error {
				s.FrequentMinusOldestMinusAgeMinusMinutes.Reset()
				if err := s.FrequentMinusOldestMinusAgeMinusMinutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frequent-oldest-age-minutes\"")
			}
		case "infrequent-interval-minutes":
			if err := func() error {
				s.InfrequentMinusIntervalMinusMinutes.Reset()
				if err := s.InfrequentMinusIntervalMinusMinutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"infrequent-interval-minutes\"")
			}
		case "infrequent-oldest-age-minutes":
			if err := func() error {
				s.InfrequentMinusOldestMinusAgeMinusMinutes.Reset()
				if err := s.InfrequentMinusOldestMinusAgeMinusMinutes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"infrequent-oldest-age-minutes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasBackupConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasBackupConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasBackupConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasIntegration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasIntegration) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Settings != nil {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.IsMinusEnabled.Set {
			e.FieldStart("is-enabled")
			s.IsMinusEnabled.Encode(e)
		}
	}
	{
		if s.Source.Set {
			e.FieldStart("source")
			s.Source.Encode(e)
		}
	}
	{
		if s.IsMinusActive.Set {
			e.FieldStart("is-active")
			s.IsMinusActive.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Dest.Set {
			e.FieldStart("dest")
			s.Dest.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasIntegration = [9]string{
	0: "description",
	1: "settings",
	2: "type",
	3: "is-enabled",
	4: "source",
	5: "is-active",
	6: "status",
	7: "id",
	8: "dest",
}

// Decode decodes DbaasIntegration from json.
func (s *DbaasIntegration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasIntegration to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "settings":
			if err := func() error {
				s.Settings = nil
				var elem DbaasIntegrationSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Settings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "is-enabled":
			if err := func() error {
				s.IsMinusEnabled.Reset()
				if err := s.IsMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is-enabled\"")
			}
		case "source":
			if err := func() error {
				s.Source.Reset()
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		case "is-active":
			if err := func() error {
				s.IsMinusActive.Reset()
				if err := s.IsMinusActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is-active\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "dest":
			if err := func() error {
				s.Dest.Reset()
				if err := s.Dest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dest\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasIntegration")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasIntegration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasIntegration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasIntegrationSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasIntegrationSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasIntegrationSettings = [0]string{}

// Decode decodes DbaasIntegrationSettings from json.
func (s *DbaasIntegrationSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasIntegrationSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasIntegrationSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasIntegrationSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasIntegrationSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasIntegrationType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasIntegrationType) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.SourceMinusDescription.Set {
			e.FieldStart("source-description")
			s.SourceMinusDescription.Encode(e)
		}
	}
	{
		if s.SourceMinusServiceMinusTypes != nil {
			e.FieldStart("source-service-types")
			e.ArrStart()
			for _, elem := range s.SourceMinusServiceMinusTypes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DestMinusDescription.Set {
			e.FieldStart("dest-description")
			s.DestMinusDescription.Encode(e)
		}
	}
	{
		if s.DestMinusServiceMinusTypes != nil {
			e.FieldStart("dest-service-types")
			e.ArrStart()
			for _, elem := range s.DestMinusServiceMinusTypes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasIntegrationType = [6]string{
	0: "type",
	1: "source-description",
	2: "source-service-types",
	3: "dest-description",
	4: "dest-service-types",
	5: "settings",
}

// Decode decodes DbaasIntegrationType from json.
func (s *DbaasIntegrationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasIntegrationType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "source-description":
			if err := func() error {
				s.SourceMinusDescription.Reset()
				if err := s.SourceMinusDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source-description\"")
			}
		case "source-service-types":
			if err := func() error {
				s.SourceMinusServiceMinusTypes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SourceMinusServiceMinusTypes = append(s.SourceMinusServiceMinusTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source-service-types\"")
			}
		case "dest-description":
			if err := func() error {
				s.DestMinusDescription.Reset()
				if err := s.DestMinusDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dest-description\"")
			}
		case "dest-service-types":
			if err := func() error {
				s.DestMinusServiceMinusTypes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DestMinusServiceMinusTypes = append(s.DestMinusServiceMinusTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dest-service-types\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasIntegrationType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasIntegrationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasIntegrationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasIntegrationTypeSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasIntegrationTypeSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasIntegrationTypeSettings = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes DbaasIntegrationTypeSettings from json.
func (s *DbaasIntegrationTypeSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasIntegrationTypeSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem DbaasIntegrationTypeSettingsProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasIntegrationTypeSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasIntegrationTypeSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasIntegrationTypeSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasIntegrationTypeSettingsProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasIntegrationTypeSettingsProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasIntegrationTypeSettingsProperties = [0]string{}

// Decode decodes DbaasIntegrationTypeSettingsProperties from json.
func (s *DbaasIntegrationTypeSettingsProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasIntegrationTypeSettingsProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasIntegrationTypeSettingsProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasIntegrationTypeSettingsProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasIntegrationTypeSettingsProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasKafkaACLID as json.
func (s DbaasKafkaACLID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DbaasKafkaACLID from json.
func (s *DbaasKafkaACLID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasKafkaACLID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DbaasKafkaACLID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasKafkaACLID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasKafkaACLID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasKafkaAcls) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasKafkaAcls) encodeFields(e *jx.Encoder) {
	{
		if s.TopicMinusACL != nil {
			e.FieldStart("topic-acl")
			e.ArrStart()
			for _, elem := range s.TopicMinusACL {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SchemaMinusRegistryMinusACL != nil {
			e.FieldStart("schema-registry-acl")
			e.ArrStart()
			for _, elem := range s.SchemaMinusRegistryMinusACL {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasKafkaAcls = [2]string{
	0: "topic-acl",
	1: "schema-registry-acl",
}

// Decode decodes DbaasKafkaAcls from json.
func (s *DbaasKafkaAcls) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasKafkaAcls to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "topic-acl":
			if err := func() error {
				s.TopicMinusACL = make([]DbaasKafkaTopicACLEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasKafkaTopicACLEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.TopicMinusACL = append(s.TopicMinusACL, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic-acl\"")
			}
		case "schema-registry-acl":
			if err := func() error {
				s.SchemaMinusRegistryMinusACL = make([]DbaasKafkaSchemaRegistryACLEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasKafkaSchemaRegistryACLEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SchemaMinusRegistryMinusACL = append(s.SchemaMinusRegistryMinusACL, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema-registry-acl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasKafkaAcls")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasKafkaAcls) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasKafkaAcls) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasKafkaSchemaRegistryACLEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasKafkaSchemaRegistryACLEntry) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("resource")
		e.Str(s.Resource)
	}
	{
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
}

var jsonFieldsNameOfDbaasKafkaSchemaRegistryACLEntry = [4]string{
	0: "id",
	1: "username",
	2: "resource",
	3: "permission",
}

// Decode decodes DbaasKafkaSchemaRegistryACLEntry from json.
func (s *DbaasKafkaSchemaRegistryACLEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasKafkaSchemaRegistryACLEntry to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "resource":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Resource = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "permission":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasKafkaSchemaRegistryACLEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasKafkaSchemaRegistryACLEntry) {
					name = jsonFieldsNameOfDbaasKafkaSchemaRegistryACLEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasKafkaSchemaRegistryACLEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasKafkaSchemaRegistryACLEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasKafkaSchemaRegistryACLEntryPermission as json.
func (s DbaasKafkaSchemaRegistryACLEntryPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DbaasKafkaSchemaRegistryACLEntryPermission from json.
func (s *DbaasKafkaSchemaRegistryACLEntryPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasKafkaSchemaRegistryACLEntryPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DbaasKafkaSchemaRegistryACLEntryPermission(v) {
	case DbaasKafkaSchemaRegistryACLEntryPermissionSchemaRegistryRead:
		*s = DbaasKafkaSchemaRegistryACLEntryPermissionSchemaRegistryRead
	case DbaasKafkaSchemaRegistryACLEntryPermissionSchemaRegistryWrite:
		*s = DbaasKafkaSchemaRegistryACLEntryPermissionSchemaRegistryWrite
	default:
		*s = DbaasKafkaSchemaRegistryACLEntryPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasKafkaSchemaRegistryACLEntryPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasKafkaSchemaRegistryACLEntryPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasKafkaTopicACLEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasKafkaTopicACLEntry) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("topic")
		e.Str(s.Topic)
	}
	{
		e.FieldStart("permission")
		s.Permission.Encode(e)
	}
}

var jsonFieldsNameOfDbaasKafkaTopicACLEntry = [4]string{
	0: "id",
	1: "username",
	2: "topic",
	3: "permission",
}

// Decode decodes DbaasKafkaTopicACLEntry from json.
func (s *DbaasKafkaTopicACLEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasKafkaTopicACLEntry to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "topic":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Topic = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"topic\"")
			}
		case "permission":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Permission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permission\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasKafkaTopicACLEntry")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001110,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasKafkaTopicACLEntry) {
					name = jsonFieldsNameOfDbaasKafkaTopicACLEntry[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasKafkaTopicACLEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasKafkaTopicACLEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasKafkaTopicACLEntryPermission as json.
func (s DbaasKafkaTopicACLEntryPermission) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DbaasKafkaTopicACLEntryPermission from json.
func (s *DbaasKafkaTopicACLEntryPermission) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasKafkaTopicACLEntryPermission to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DbaasKafkaTopicACLEntryPermission(v) {
	case DbaasKafkaTopicACLEntryPermissionAdmin:
		*s = DbaasKafkaTopicACLEntryPermissionAdmin
	case DbaasKafkaTopicACLEntryPermissionRead:
		*s = DbaasKafkaTopicACLEntryPermissionRead
	case DbaasKafkaTopicACLEntryPermissionReadwrite:
		*s = DbaasKafkaTopicACLEntryPermissionReadwrite
	case DbaasKafkaTopicACLEntryPermissionWrite:
		*s = DbaasKafkaTopicACLEntryPermissionWrite
	default:
		*s = DbaasKafkaTopicACLEntryPermission(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasKafkaTopicACLEntryPermission) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasKafkaTopicACLEntryPermission) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasMigrationStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasMigrationStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.MasterMinusLastMinusIoMinusSecondsMinusAgo.Set {
			e.FieldStart("master-last-io-seconds-ago")
			s.MasterMinusLastMinusIoMinusSecondsMinusAgo.Encode(e)
		}
	}
	{
		if s.MasterMinusLinkMinusStatus.Set {
			e.FieldStart("master-link-status")
			s.MasterMinusLinkMinusStatus.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Details != nil {
			e.FieldStart("details")
			e.ArrStart()
			for _, elem := range s.Details {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasMigrationStatus = [6]string{
	0: "error",
	1: "master-last-io-seconds-ago",
	2: "master-link-status",
	3: "method",
	4: "status",
	5: "details",
}

// Decode decodes DbaasMigrationStatus from json.
func (s *DbaasMigrationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasMigrationStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "master-last-io-seconds-ago":
			if err := func() error {
				s.MasterMinusLastMinusIoMinusSecondsMinusAgo.Reset()
				if err := s.MasterMinusLastMinusIoMinusSecondsMinusAgo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master-last-io-seconds-ago\"")
			}
		case "master-link-status":
			if err := func() error {
				s.MasterMinusLinkMinusStatus.Reset()
				if err := s.MasterMinusLinkMinusStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"master-link-status\"")
			}
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "details":
			if err := func() error {
				s.Details = make([]DbaasMigrationStatusDetailsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasMigrationStatusDetailsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Details = append(s.Details, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"details\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasMigrationStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasMigrationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasMigrationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasMigrationStatusDetailsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasMigrationStatusDetailsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Dbname.Set {
			e.FieldStart("dbname")
			s.Dbname.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasMigrationStatusDetailsItem = [4]string{
	0: "dbname",
	1: "error",
	2: "method",
	3: "status",
}

// Decode decodes DbaasMigrationStatusDetailsItem from json.
func (s *DbaasMigrationStatusDetailsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasMigrationStatusDetailsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dbname":
			if err := func() error {
				s.Dbname.Reset()
				if err := s.Dbname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbname\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasMigrationStatusDetailsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasMigrationStatusDetailsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasMigrationStatusDetailsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasNodeState) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasNodeState) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.ProgressMinusUpdates != nil {
			e.FieldStart("progress-updates")
			e.ArrStart()
			for _, elem := range s.ProgressMinusUpdates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Role.Set {
			e.FieldStart("role")
			s.Role.Encode(e)
		}
	}
	{
		e.FieldStart("state")
		s.State.Encode(e)
	}
}

var jsonFieldsNameOfDbaasNodeState = [4]string{
	0: "name",
	1: "progress-updates",
	2: "role",
	3: "state",
}

// Decode decodes DbaasNodeState from json.
func (s *DbaasNodeState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasNodeState to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "progress-updates":
			if err := func() error {
				s.ProgressMinusUpdates = make([]DbaasNodeStateProgressUpdate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasNodeStateProgressUpdate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ProgressMinusUpdates = append(s.ProgressMinusUpdates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"progress-updates\"")
			}
		case "role":
			if err := func() error {
				s.Role.Reset()
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasNodeState")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasNodeState) {
					name = jsonFieldsNameOfDbaasNodeState[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasNodeState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasNodeState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasNodeStateProgressUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasNodeStateProgressUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("completed")
		e.Bool(s.Completed)
	}
	{
		if s.Current.Set {
			e.FieldStart("current")
			s.Current.Encode(e)
		}
	}
	{
		if s.Max.Set {
			e.FieldStart("max")
			s.Max.Encode(e)
		}
	}
	{
		if s.Min.Set {
			e.FieldStart("min")
			s.Min.Encode(e)
		}
	}
	{
		e.FieldStart("phase")
		s.Phase.Encode(e)
	}
	{
		if s.Unit.Set {
			e.FieldStart("unit")
			s.Unit.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasNodeStateProgressUpdate = [6]string{
	0: "completed",
	1: "current",
	2: "max",
	3: "min",
	4: "phase",
	5: "unit",
}

// Decode decodes DbaasNodeStateProgressUpdate from json.
func (s *DbaasNodeStateProgressUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasNodeStateProgressUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "completed":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Completed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completed\"")
			}
		case "current":
			if err := func() error {
				s.Current.Reset()
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "max":
			if err := func() error {
				s.Max.Reset()
				if err := s.Max.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max\"")
			}
		case "min":
			if err := func() error {
				s.Min.Reset()
				if err := s.Min.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"min\"")
			}
		case "phase":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Phase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"phase\"")
			}
		case "unit":
			if err := func() error {
				s.Unit.Reset()
				if err := s.Unit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasNodeStateProgressUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasNodeStateProgressUpdate) {
					name = jsonFieldsNameOfDbaasNodeStateProgressUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasNodeStateProgressUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasNodeStateProgressUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasNodeStateProgressUpdatePhase as json.
func (s DbaasNodeStateProgressUpdatePhase) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DbaasNodeStateProgressUpdatePhase from json.
func (s *DbaasNodeStateProgressUpdatePhase) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasNodeStateProgressUpdatePhase to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DbaasNodeStateProgressUpdatePhase(v) {
	case DbaasNodeStateProgressUpdatePhaseStream:
		*s = DbaasNodeStateProgressUpdatePhaseStream
	case DbaasNodeStateProgressUpdatePhaseBasebackup:
		*s = DbaasNodeStateProgressUpdatePhaseBasebackup
	case DbaasNodeStateProgressUpdatePhasePrepare:
		*s = DbaasNodeStateProgressUpdatePhasePrepare
	case DbaasNodeStateProgressUpdatePhaseFinalize:
		*s = DbaasNodeStateProgressUpdatePhaseFinalize
	default:
		*s = DbaasNodeStateProgressUpdatePhase(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasNodeStateProgressUpdatePhase) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasNodeStateProgressUpdatePhase) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasNodeStateRole as json.
func (s DbaasNodeStateRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DbaasNodeStateRole from json.
func (s *DbaasNodeStateRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasNodeStateRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DbaasNodeStateRole(v) {
	case DbaasNodeStateRoleStandby:
		*s = DbaasNodeStateRoleStandby
	case DbaasNodeStateRoleMaster:
		*s = DbaasNodeStateRoleMaster
	case DbaasNodeStateRoleReadReplica:
		*s = DbaasNodeStateRoleReadReplica
	default:
		*s = DbaasNodeStateRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasNodeStateRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasNodeStateRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasNodeStateState as json.
func (s DbaasNodeStateState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DbaasNodeStateState from json.
func (s *DbaasNodeStateState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasNodeStateState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DbaasNodeStateState(v) {
	case DbaasNodeStateStateLeaving:
		*s = DbaasNodeStateStateLeaving
	case DbaasNodeStateStateRunning:
		*s = DbaasNodeStateStateRunning
	case DbaasNodeStateStateSyncingData:
		*s = DbaasNodeStateStateSyncingData
	case DbaasNodeStateStateSettingUpVM:
		*s = DbaasNodeStateStateSettingUpVM
	case DbaasNodeStateStateUnknown:
		*s = DbaasNodeStateStateUnknown
	default:
		*s = DbaasNodeStateState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasNodeStateState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasNodeStateState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasPgDatabaseName as json.
func (s DbaasPgDatabaseName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DbaasPgDatabaseName from json.
func (s *DbaasPgDatabaseName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasPgDatabaseName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DbaasPgDatabaseName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasPgDatabaseName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasPgDatabaseName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasPgPoolName as json.
func (s DbaasPgPoolName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DbaasPgPoolName from json.
func (s *DbaasPgPoolName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasPgPoolName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DbaasPgPoolName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasPgPoolName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasPgPoolName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasPgPoolSize as json.
func (s DbaasPgPoolSize) Encode(e *jx.Encoder) {
	unwrapped := int64(s)

	e.Int64(unwrapped)
}

// Decode decodes DbaasPgPoolSize from json.
func (s *DbaasPgPoolSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasPgPoolSize to nil")
	}
	var unwrapped int64
	if err := func() error {
		v, err := d.Int64()
		unwrapped = int64(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DbaasPgPoolSize(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasPgPoolSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasPgPoolSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasPgPoolUsername as json.
func (s DbaasPgPoolUsername) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DbaasPgPoolUsername from json.
func (s *DbaasPgPoolUsername) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasPgPoolUsername to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DbaasPgPoolUsername(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasPgPoolUsername) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasPgPoolUsername) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasPlan) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasPlan) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.NodeMinusCount.Set {
			e.FieldStart("node-count")
			s.NodeMinusCount.Encode(e)
		}
	}
	{
		if s.NodeMinusCPUMinusCount.Set {
			e.FieldStart("node-cpu-count")
			s.NodeMinusCPUMinusCount.Encode(e)
		}
	}
	{
		if s.DiskMinusSpace.Set {
			e.FieldStart("disk-space")
			s.DiskMinusSpace.Encode(e)
		}
	}
	{
		if s.NodeMinusMemory.Set {
			e.FieldStart("node-memory")
			s.NodeMinusMemory.Encode(e)
		}
	}
	{
		if s.MaxMinusMemoryMinusPercent.Set {
			e.FieldStart("max-memory-percent")
			s.MaxMinusMemoryMinusPercent.Encode(e)
		}
	}
	{
		if s.BackupMinusConfig.Set {
			e.FieldStart("backup-config")
			s.BackupMinusConfig.Encode(e)
		}
	}
	{
		if s.Authorized.Set {
			e.FieldStart("authorized")
			s.Authorized.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasPlan = [8]string{
	0: "name",
	1: "node-count",
	2: "node-cpu-count",
	3: "disk-space",
	4: "node-memory",
	5: "max-memory-percent",
	6: "backup-config",
	7: "authorized",
}

// Decode decodes DbaasPlan from json.
func (s *DbaasPlan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasPlan to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "node-count":
			if err := func() error {
				s.NodeMinusCount.Reset()
				if err := s.NodeMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-count\"")
			}
		case "node-cpu-count":
			if err := func() error {
				s.NodeMinusCPUMinusCount.Reset()
				if err := s.NodeMinusCPUMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-cpu-count\"")
			}
		case "disk-space":
			if err := func() error {
				s.DiskMinusSpace.Reset()
				if err := s.DiskMinusSpace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk-space\"")
			}
		case "node-memory":
			if err := func() error {
				s.NodeMinusMemory.Reset()
				if err := s.NodeMinusMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-memory\"")
			}
		case "max-memory-percent":
			if err := func() error {
				s.MaxMinusMemoryMinusPercent.Reset()
				if err := s.MaxMinusMemoryMinusPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-memory-percent\"")
			}
		case "backup-config":
			if err := func() error {
				s.BackupMinusConfig.Reset()
				if err := s.BackupMinusConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-config\"")
			}
		case "authorized":
			if err := func() error {
				s.Authorized.Reset()
				if err := s.Authorized.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorized\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasPlan")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasPlan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasPlan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasPostgresUsers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasPostgresUsers) encodeFields(e *jx.Encoder) {
	{
		if s.Users != nil {
			e.FieldStart("users")
			e.ArrStart()
			for _, elem := range s.Users {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasPostgresUsers = [1]string{
	0: "users",
}

// Decode decodes DbaasPostgresUsers from json.
func (s *DbaasPostgresUsers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasPostgresUsers to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			if err := func() error {
				s.Users = make([]DbaasPostgresUsersUsersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasPostgresUsersUsersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasPostgresUsers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasPostgresUsers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasPostgresUsers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasPostgresUsersUsersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasPostgresUsersUsersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		s.Username.Encode(e)
	}
	{
		if s.AllowMinusReplication.Set {
			e.FieldStart("allow-replication")
			s.AllowMinusReplication.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasPostgresUsersUsersItem = [2]string{
	0: "username",
	1: "allow-replication",
}

// Decode decodes DbaasPostgresUsersUsersItem from json.
func (s *DbaasPostgresUsersUsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasPostgresUsersUsersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "allow-replication":
			if err := func() error {
				s.AllowMinusReplication.Reset()
				if err := s.AllowMinusReplication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow-replication\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasPostgresUsersUsersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasPostgresUsersUsersItem) {
					name = jsonFieldsNameOfDbaasPostgresUsersUsersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasPostgresUsersUsersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasPostgresUsersUsersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceBackup) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceBackup) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("backup-name")
		e.Str(s.BackupMinusName)
	}
	{
		e.FieldStart("backup-time")
		json.EncodeDateTime(e, s.BackupMinusTime)
	}
	{
		e.FieldStart("data-size")
		e.Int64(s.DataMinusSize)
	}
}

var jsonFieldsNameOfDbaasServiceBackup = [3]string{
	0: "backup-name",
	1: "backup-time",
	2: "data-size",
}

// Decode decodes DbaasServiceBackup from json.
func (s *DbaasServiceBackup) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceBackup to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backup-name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BackupMinusName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-name\"")
			}
		case "backup-time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.BackupMinusTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-time\"")
			}
		case "data-size":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.DataMinusSize = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data-size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceBackup")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceBackup) {
					name = jsonFieldsNameOfDbaasServiceBackup[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceBackup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceBackup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceCommon) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceCommon) encodeFields(e *jx.Encoder) {
	{
		if s.UpdatedMinusAt.Set {
			e.FieldStart("updated-at")
			s.UpdatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.NodeMinusCount.Set {
			e.FieldStart("node-count")
			s.NodeMinusCount.Encode(e)
		}
	}
	{
		if s.NodeMinusCPUMinusCount.Set {
			e.FieldStart("node-cpu-count")
			s.NodeMinusCPUMinusCount.Encode(e)
		}
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.Notifications != nil {
			e.FieldStart("notifications")
			e.ArrStart()
			for _, elem := range s.Notifications {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DiskMinusSize.Set {
			e.FieldStart("disk-size")
			s.DiskMinusSize.Encode(e)
		}
	}
	{
		if s.NodeMinusMemory.Set {
			e.FieldStart("node-memory")
			s.NodeMinusMemory.Encode(e)
		}
	}
	{
		if s.CreatedMinusAt.Set {
			e.FieldStart("created-at")
			s.CreatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("plan")
		e.Str(s.Plan)
	}
}

var jsonFieldsNameOfDbaasServiceCommon = [13]string{
	0:  "updated-at",
	1:  "node-count",
	2:  "node-cpu-count",
	3:  "integrations",
	4:  "name",
	5:  "type",
	6:  "state",
	7:  "termination-protection",
	8:  "notifications",
	9:  "disk-size",
	10: "node-memory",
	11: "created-at",
	12: "plan",
}

// Decode decodes DbaasServiceCommon from json.
func (s *DbaasServiceCommon) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceCommon to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "updated-at":
			if err := func() error {
				s.UpdatedMinusAt.Reset()
				if err := s.UpdatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated-at\"")
			}
		case "node-count":
			if err := func() error {
				s.NodeMinusCount.Reset()
				if err := s.NodeMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-count\"")
			}
		case "node-cpu-count":
			if err := func() error {
				s.NodeMinusCPUMinusCount.Reset()
				if err := s.NodeMinusCPUMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-cpu-count\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]DbaasIntegration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasIntegration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "notifications":
			if err := func() error {
				s.Notifications = make([]DbaasServiceNotification, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceNotification
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Notifications = append(s.Notifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		case "disk-size":
			if err := func() error {
				s.DiskMinusSize.Reset()
				if err := s.DiskMinusSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk-size\"")
			}
		case "node-memory":
			if err := func() error {
				s.NodeMinusMemory.Reset()
				if err := s.NodeMinusMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-memory\"")
			}
		case "created-at":
			if err := func() error {
				s.CreatedMinusAt.Reset()
				if err := s.CreatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created-at\"")
			}
		case "plan":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Plan = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceCommon")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110000,
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceCommon) {
					name = jsonFieldsNameOfDbaasServiceCommon[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceCommon) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceCommon) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceKafka) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceKafka) encodeFields(e *jx.Encoder) {
	{
		if s.UpdatedMinusAt.Set {
			e.FieldStart("updated-at")
			s.UpdatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AuthenticationMinusMethods.Set {
			e.FieldStart("authentication-methods")
			s.AuthenticationMinusMethods.Encode(e)
		}
	}
	{
		if s.NodeMinusCount.Set {
			e.FieldStart("node-count")
			s.NodeMinusCount.Encode(e)
		}
	}
	{
		if s.ConnectionMinusInfo.Set {
			e.FieldStart("connection-info")
			s.ConnectionMinusInfo.Encode(e)
		}
	}
	{
		if s.NodeMinusCPUMinusCount.Set {
			e.FieldStart("node-cpu-count")
			s.NodeMinusCPUMinusCount.Encode(e)
		}
	}
	{
		if s.KafkaMinusRestMinusEnabled.Set {
			e.FieldStart("kafka-rest-enabled")
			s.KafkaMinusRestMinusEnabled.Encode(e)
		}
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeMinusStates != nil {
			e.FieldStart("node-states")
			e.ArrStart()
			for _, elem := range s.NodeMinusStates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.KafkaMinusConnectMinusEnabled.Set {
			e.FieldStart("kafka-connect-enabled")
			s.KafkaMinusConnectMinusEnabled.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SchemaMinusRegistryMinusSettings != nil {
			e.FieldStart("schema-registry-settings")
			s.SchemaMinusRegistryMinusSettings.Encode(e)
		}
	}
	{
		if s.Backups != nil {
			e.FieldStart("backups")
			e.ArrStart()
			for _, elem := range s.Backups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.KafkaMinusRestMinusSettings != nil {
			e.FieldStart("kafka-rest-settings")
			s.KafkaMinusRestMinusSettings.Encode(e)
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.Notifications != nil {
			e.FieldStart("notifications")
			e.ArrStart()
			for _, elem := range s.Notifications {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.KafkaMinusConnectMinusSettings != nil {
			e.FieldStart("kafka-connect-settings")
			s.KafkaMinusConnectMinusSettings.Encode(e)
		}
	}
	{
		if s.Components != nil {
			e.FieldStart("components")
			e.ArrStart()
			for _, elem := range s.Components {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.KafkaMinusSettings != nil {
			e.FieldStart("kafka-settings")
			s.KafkaMinusSettings.Encode(e)
		}
	}
	{
		if s.DiskMinusSize.Set {
			e.FieldStart("disk-size")
			s.DiskMinusSize.Encode(e)
		}
	}
	{
		if s.NodeMinusMemory.Set {
			e.FieldStart("node-memory")
			s.NodeMinusMemory.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.URIMinusParams != nil {
			e.FieldStart("uri-params")
			s.URIMinusParams.Encode(e)
		}
	}
	{
		if s.SchemaMinusRegistryMinusEnabled.Set {
			e.FieldStart("schema-registry-enabled")
			s.SchemaMinusRegistryMinusEnabled.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.CreatedMinusAt.Set {
			e.FieldStart("created-at")
			s.CreatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("plan")
		e.Str(s.Plan)
	}
	{
		if s.Users != nil {
			e.FieldStart("users")
			e.ArrStart()
			for _, elem := range s.Users {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasServiceKafka = [31]string{
	0:  "updated-at",
	1:  "authentication-methods",
	2:  "node-count",
	3:  "connection-info",
	4:  "node-cpu-count",
	5:  "kafka-rest-enabled",
	6:  "integrations",
	7:  "node-states",
	8:  "name",
	9:  "kafka-connect-enabled",
	10: "type",
	11: "state",
	12: "ip-filter",
	13: "schema-registry-settings",
	14: "backups",
	15: "kafka-rest-settings",
	16: "termination-protection",
	17: "notifications",
	18: "kafka-connect-settings",
	19: "components",
	20: "maintenance",
	21: "kafka-settings",
	22: "disk-size",
	23: "node-memory",
	24: "uri",
	25: "uri-params",
	26: "schema-registry-enabled",
	27: "version",
	28: "created-at",
	29: "plan",
	30: "users",
}

// Decode decodes DbaasServiceKafka from json.
func (s *DbaasServiceKafka) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceKafka to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "updated-at":
			if err := func() error {
				s.UpdatedMinusAt.Reset()
				if err := s.UpdatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated-at\"")
			}
		case "authentication-methods":
			if err := func() error {
				s.AuthenticationMinusMethods.Reset()
				if err := s.AuthenticationMinusMethods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authentication-methods\"")
			}
		case "node-count":
			if err := func() error {
				s.NodeMinusCount.Reset()
				if err := s.NodeMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-count\"")
			}
		case "connection-info":
			if err := func() error {
				s.ConnectionMinusInfo.Reset()
				if err := s.ConnectionMinusInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection-info\"")
			}
		case "node-cpu-count":
			if err := func() error {
				s.NodeMinusCPUMinusCount.Reset()
				if err := s.NodeMinusCPUMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-cpu-count\"")
			}
		case "kafka-rest-enabled":
			if err := func() error {
				s.KafkaMinusRestMinusEnabled.Reset()
				if err := s.KafkaMinusRestMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-rest-enabled\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]DbaasIntegration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasIntegration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "node-states":
			if err := func() error {
				s.NodeMinusStates = make([]DbaasNodeState, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasNodeState
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodeMinusStates = append(s.NodeMinusStates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-states\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "kafka-connect-enabled":
			if err := func() error {
				s.KafkaMinusConnectMinusEnabled.Reset()
				if err := s.KafkaMinusConnectMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-connect-enabled\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "schema-registry-settings":
			if err := func() error {
				s.SchemaMinusRegistryMinusSettings = nil
				var elem DbaasServiceKafkaSchemaMinusRegistryMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.SchemaMinusRegistryMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema-registry-settings\"")
			}
		case "backups":
			if err := func() error {
				s.Backups = make([]DbaasServiceBackup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceBackup
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Backups = append(s.Backups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backups\"")
			}
		case "kafka-rest-settings":
			if err := func() error {
				s.KafkaMinusRestMinusSettings = nil
				var elem DbaasServiceKafkaKafkaMinusRestMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.KafkaMinusRestMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-rest-settings\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "notifications":
			if err := func() error {
				s.Notifications = make([]DbaasServiceNotification, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceNotification
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Notifications = append(s.Notifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		case "kafka-connect-settings":
			if err := func() error {
				s.KafkaMinusConnectMinusSettings = nil
				var elem DbaasServiceKafkaKafkaMinusConnectMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.KafkaMinusConnectMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-connect-settings\"")
			}
		case "components":
			if err := func() error {
				s.Components = make([]DbaasServiceKafkaComponentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceKafkaComponentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Components = append(s.Components, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"components\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "kafka-settings":
			if err := func() error {
				s.KafkaMinusSettings = nil
				var elem DbaasServiceKafkaKafkaMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.KafkaMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-settings\"")
			}
		case "disk-size":
			if err := func() error {
				s.DiskMinusSize.Reset()
				if err := s.DiskMinusSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk-size\"")
			}
		case "node-memory":
			if err := func() error {
				s.NodeMinusMemory.Reset()
				if err := s.NodeMinusMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-memory\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "uri-params":
			if err := func() error {
				s.URIMinusParams = nil
				var elem DbaasServiceKafkaURIMinusParams
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.URIMinusParams = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri-params\"")
			}
		case "schema-registry-enabled":
			if err := func() error {
				s.SchemaMinusRegistryMinusEnabled.Reset()
				if err := s.SchemaMinusRegistryMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema-registry-enabled\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "created-at":
			if err := func() error {
				s.CreatedMinusAt.Reset()
				if err := s.CreatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created-at\"")
			}
		case "plan":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Plan = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "users":
			if err := func() error {
				s.Users = make([]DbaasServiceKafkaUsersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceKafkaUsersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceKafka")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00000000,
		0b00000101,
		0b00000000,
		0b00100000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceKafka) {
					name = jsonFieldsNameOfDbaasServiceKafka[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceKafka) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceKafka) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceKafkaAuthenticationMinusMethods) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceKafkaAuthenticationMinusMethods) encodeFields(e *jx.Encoder) {
	{
		if s.Certificate.Set {
			e.FieldStart("certificate")
			s.Certificate.Encode(e)
		}
	}
	{
		if s.Sasl.Set {
			e.FieldStart("sasl")
			s.Sasl.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceKafkaAuthenticationMinusMethods = [2]string{
	0: "certificate",
	1: "sasl",
}

// Decode decodes DbaasServiceKafkaAuthenticationMinusMethods from json.
func (s *DbaasServiceKafkaAuthenticationMinusMethods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceKafkaAuthenticationMinusMethods to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificate":
			if err := func() error {
				s.Certificate.Reset()
				if err := s.Certificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		case "sasl":
			if err := func() error {
				s.Sasl.Reset()
				if err := s.Sasl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sasl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceKafkaAuthenticationMinusMethods")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceKafkaAuthenticationMinusMethods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceKafkaAuthenticationMinusMethods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceKafkaComponentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceKafkaComponentsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("component")
		e.Str(s.Component)
	}
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		if s.KafkaMinusAuthenticationMinusMethod.Set {
			e.FieldStart("kafka-authentication-method")
			s.KafkaMinusAuthenticationMinusMethod.Encode(e)
		}
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		e.FieldStart("route")
		s.Route.Encode(e)
	}
	{
		e.FieldStart("usage")
		s.Usage.Encode(e)
	}
}

var jsonFieldsNameOfDbaasServiceKafkaComponentsItem = [6]string{
	0: "component",
	1: "host",
	2: "kafka-authentication-method",
	3: "port",
	4: "route",
	5: "usage",
}

// Decode decodes DbaasServiceKafkaComponentsItem from json.
func (s *DbaasServiceKafkaComponentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceKafkaComponentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "component":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Component = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "kafka-authentication-method":
			if err := func() error {
				s.KafkaMinusAuthenticationMinusMethod.Reset()
				if err := s.KafkaMinusAuthenticationMinusMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-authentication-method\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "route":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Route.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"route\"")
			}
		case "usage":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceKafkaComponentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceKafkaComponentsItem) {
					name = jsonFieldsNameOfDbaasServiceKafkaComponentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceKafkaComponentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceKafkaComponentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceKafkaConnectionMinusInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceKafkaConnectionMinusInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Nodes != nil {
			e.FieldStart("nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AccessMinusCert.Set {
			e.FieldStart("access-cert")
			s.AccessMinusCert.Encode(e)
		}
	}
	{
		if s.AccessMinusKey.Set {
			e.FieldStart("access-key")
			s.AccessMinusKey.Encode(e)
		}
	}
	{
		if s.ConnectMinusURI.Set {
			e.FieldStart("connect-uri")
			s.ConnectMinusURI.Encode(e)
		}
	}
	{
		if s.RestMinusURI.Set {
			e.FieldStart("rest-uri")
			s.RestMinusURI.Encode(e)
		}
	}
	{
		if s.RegistryMinusURI.Set {
			e.FieldStart("registry-uri")
			s.RegistryMinusURI.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceKafkaConnectionMinusInfo = [6]string{
	0: "nodes",
	1: "access-cert",
	2: "access-key",
	3: "connect-uri",
	4: "rest-uri",
	5: "registry-uri",
}

// Decode decodes DbaasServiceKafkaConnectionMinusInfo from json.
func (s *DbaasServiceKafkaConnectionMinusInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceKafkaConnectionMinusInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodes":
			if err := func() error {
				s.Nodes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "access-cert":
			if err := func() error {
				s.AccessMinusCert.Reset()
				if err := s.AccessMinusCert.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access-cert\"")
			}
		case "access-key":
			if err := func() error {
				s.AccessMinusKey.Reset()
				if err := s.AccessMinusKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access-key\"")
			}
		case "connect-uri":
			if err := func() error {
				s.ConnectMinusURI.Reset()
				if err := s.ConnectMinusURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connect-uri\"")
			}
		case "rest-uri":
			if err := func() error {
				s.RestMinusURI.Reset()
				if err := s.RestMinusURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rest-uri\"")
			}
		case "registry-uri":
			if err := func() error {
				s.RegistryMinusURI.Reset()
				if err := s.RegistryMinusURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registry-uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceKafkaConnectionMinusInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceKafkaConnectionMinusInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceKafkaConnectionMinusInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceKafkaKafkaMinusConnectMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceKafkaKafkaMinusConnectMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceKafkaKafkaMinusConnectMinusSettings = [0]string{}

// Decode decodes DbaasServiceKafkaKafkaMinusConnectMinusSettings from json.
func (s *DbaasServiceKafkaKafkaMinusConnectMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceKafkaKafkaMinusConnectMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceKafkaKafkaMinusConnectMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceKafkaKafkaMinusConnectMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceKafkaKafkaMinusConnectMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceKafkaKafkaMinusRestMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceKafkaKafkaMinusRestMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceKafkaKafkaMinusRestMinusSettings = [0]string{}

// Decode decodes DbaasServiceKafkaKafkaMinusRestMinusSettings from json.
func (s *DbaasServiceKafkaKafkaMinusRestMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceKafkaKafkaMinusRestMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceKafkaKafkaMinusRestMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceKafkaKafkaMinusRestMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceKafkaKafkaMinusRestMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceKafkaKafkaMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceKafkaKafkaMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceKafkaKafkaMinusSettings = [0]string{}

// Decode decodes DbaasServiceKafkaKafkaMinusSettings from json.
func (s *DbaasServiceKafkaKafkaMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceKafkaKafkaMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceKafkaKafkaMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceKafkaKafkaMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceKafkaKafkaMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceKafkaSchemaMinusRegistryMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceKafkaSchemaMinusRegistryMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceKafkaSchemaMinusRegistryMinusSettings = [0]string{}

// Decode decodes DbaasServiceKafkaSchemaMinusRegistryMinusSettings from json.
func (s *DbaasServiceKafkaSchemaMinusRegistryMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceKafkaSchemaMinusRegistryMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceKafkaSchemaMinusRegistryMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceKafkaSchemaMinusRegistryMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceKafkaSchemaMinusRegistryMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceKafkaURIMinusParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceKafkaURIMinusParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceKafkaURIMinusParams = [0]string{}

// Decode decodes DbaasServiceKafkaURIMinusParams from json.
func (s *DbaasServiceKafkaURIMinusParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceKafkaURIMinusParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceKafkaURIMinusParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceKafkaURIMinusParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceKafkaURIMinusParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceKafkaUsersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceKafkaUsersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.AccessMinusCert.Set {
			e.FieldStart("access-cert")
			s.AccessMinusCert.Encode(e)
		}
	}
	{
		if s.AccessMinusCertMinusExpiry.Set {
			e.FieldStart("access-cert-expiry")
			s.AccessMinusCertMinusExpiry.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.AccessMinusKey.Set {
			e.FieldStart("access-key")
			s.AccessMinusKey.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceKafkaUsersItem = [6]string{
	0: "type",
	1: "username",
	2: "password",
	3: "access-cert",
	4: "access-cert-expiry",
	5: "access-key",
}

// Decode decodes DbaasServiceKafkaUsersItem from json.
func (s *DbaasServiceKafkaUsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceKafkaUsersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "access-cert":
			if err := func() error {
				s.AccessMinusCert.Reset()
				if err := s.AccessMinusCert.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access-cert\"")
			}
		case "access-cert-expiry":
			if err := func() error {
				s.AccessMinusCertMinusExpiry.Reset()
				if err := s.AccessMinusCertMinusExpiry.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access-cert-expiry\"")
			}
		case "access-key":
			if err := func() error {
				s.AccessMinusKey.Reset()
				if err := s.AccessMinusKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access-key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceKafkaUsersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceKafkaUsersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceKafkaUsersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceLogs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceLogs) encodeFields(e *jx.Encoder) {
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
	{
		if s.FirstMinusLogMinusOffset.Set {
			e.FieldStart("first-log-offset")
			s.FirstMinusLogMinusOffset.Encode(e)
		}
	}
	{
		if s.Logs != nil {
			e.FieldStart("logs")
			e.ArrStart()
			for _, elem := range s.Logs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasServiceLogs = [3]string{
	0: "offset",
	1: "first-log-offset",
	2: "logs",
}

// Decode decodes DbaasServiceLogs from json.
func (s *DbaasServiceLogs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceLogs to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "first-log-offset":
			if err := func() error {
				s.FirstMinusLogMinusOffset.Reset()
				if err := s.FirstMinusLogMinusOffset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first-log-offset\"")
			}
		case "logs":
			if err := func() error {
				s.Logs = make([]DbaasServiceLogsLogsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceLogsLogsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Logs = append(s.Logs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceLogs")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceLogs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceLogs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceLogsLogsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceLogsLogsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Unit.Set {
			e.FieldStart("unit")
			s.Unit.Encode(e)
		}
	}
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Node.Set {
			e.FieldStart("node")
			s.Node.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceLogsLogsItem = [4]string{
	0: "unit",
	1: "time",
	2: "message",
	3: "node",
}

// Decode decodes DbaasServiceLogsLogsItem from json.
func (s *DbaasServiceLogsLogsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceLogsLogsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "unit":
			if err := func() error {
				s.Unit.Reset()
				if err := s.Unit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unit\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "node":
			if err := func() error {
				s.Node.Reset()
				if err := s.Node.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceLogsLogsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceLogsLogsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceLogsLogsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceMaintenance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceMaintenance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dow")
		s.Dow.Encode(e)
	}
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
	{
		e.FieldStart("updates")
		e.ArrStart()
		for _, elem := range s.Updates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDbaasServiceMaintenance = [3]string{
	0: "dow",
	1: "time",
	2: "updates",
}

// Decode decodes DbaasServiceMaintenance from json.
func (s *DbaasServiceMaintenance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceMaintenance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dow":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dow\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "updates":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Updates = make([]DbaasServiceUpdate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceUpdate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Updates = append(s.Updates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceMaintenance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceMaintenance) {
					name = jsonFieldsNameOfDbaasServiceMaintenance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceMaintenanceDow as json.
func (s DbaasServiceMaintenanceDow) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DbaasServiceMaintenanceDow from json.
func (s *DbaasServiceMaintenanceDow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceMaintenanceDow to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DbaasServiceMaintenanceDow(v) {
	case DbaasServiceMaintenanceDowSaturday:
		*s = DbaasServiceMaintenanceDowSaturday
	case DbaasServiceMaintenanceDowTuesday:
		*s = DbaasServiceMaintenanceDowTuesday
	case DbaasServiceMaintenanceDowNever:
		*s = DbaasServiceMaintenanceDowNever
	case DbaasServiceMaintenanceDowWednesday:
		*s = DbaasServiceMaintenanceDowWednesday
	case DbaasServiceMaintenanceDowSunday:
		*s = DbaasServiceMaintenanceDowSunday
	case DbaasServiceMaintenanceDowFriday:
		*s = DbaasServiceMaintenanceDowFriday
	case DbaasServiceMaintenanceDowMonday:
		*s = DbaasServiceMaintenanceDowMonday
	case DbaasServiceMaintenanceDowThursday:
		*s = DbaasServiceMaintenanceDowThursday
	default:
		*s = DbaasServiceMaintenanceDow(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasServiceMaintenanceDow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceMaintenanceDow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceMysql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceMysql) encodeFields(e *jx.Encoder) {
	{
		if s.UpdatedMinusAt.Set {
			e.FieldStart("updated-at")
			s.UpdatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.NodeMinusCount.Set {
			e.FieldStart("node-count")
			s.NodeMinusCount.Encode(e)
		}
	}
	{
		if s.ConnectionMinusInfo.Set {
			e.FieldStart("connection-info")
			s.ConnectionMinusInfo.Encode(e)
		}
	}
	{
		if s.BackupMinusSchedule.Set {
			e.FieldStart("backup-schedule")
			s.BackupMinusSchedule.Encode(e)
		}
	}
	{
		if s.NodeMinusCPUMinusCount.Set {
			e.FieldStart("node-cpu-count")
			s.NodeMinusCPUMinusCount.Encode(e)
		}
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeMinusStates != nil {
			e.FieldStart("node-states")
			e.ArrStart()
			for _, elem := range s.NodeMinusStates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Backups != nil {
			e.FieldStart("backups")
			e.ArrStart()
			for _, elem := range s.Backups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.Notifications != nil {
			e.FieldStart("notifications")
			e.ArrStart()
			for _, elem := range s.Notifications {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Components != nil {
			e.FieldStart("components")
			e.ArrStart()
			for _, elem := range s.Components {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MysqlMinusSettings != nil {
			e.FieldStart("mysql-settings")
			s.MysqlMinusSettings.Encode(e)
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.DiskMinusSize.Set {
			e.FieldStart("disk-size")
			s.DiskMinusSize.Encode(e)
		}
	}
	{
		if s.NodeMinusMemory.Set {
			e.FieldStart("node-memory")
			s.NodeMinusMemory.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.URIMinusParams != nil {
			e.FieldStart("uri-params")
			s.URIMinusParams.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.CreatedMinusAt.Set {
			e.FieldStart("created-at")
			s.CreatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("plan")
		e.Str(s.Plan)
	}
	{
		if s.Users != nil {
			e.FieldStart("users")
			e.ArrStart()
			for _, elem := range s.Users {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasServiceMysql = [25]string{
	0:  "updated-at",
	1:  "node-count",
	2:  "connection-info",
	3:  "backup-schedule",
	4:  "node-cpu-count",
	5:  "integrations",
	6:  "node-states",
	7:  "name",
	8:  "type",
	9:  "state",
	10: "ip-filter",
	11: "backups",
	12: "termination-protection",
	13: "notifications",
	14: "components",
	15: "mysql-settings",
	16: "maintenance",
	17: "disk-size",
	18: "node-memory",
	19: "uri",
	20: "uri-params",
	21: "version",
	22: "created-at",
	23: "plan",
	24: "users",
}

// Decode decodes DbaasServiceMysql from json.
func (s *DbaasServiceMysql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceMysql to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "updated-at":
			if err := func() error {
				s.UpdatedMinusAt.Reset()
				if err := s.UpdatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated-at\"")
			}
		case "node-count":
			if err := func() error {
				s.NodeMinusCount.Reset()
				if err := s.NodeMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-count\"")
			}
		case "connection-info":
			if err := func() error {
				s.ConnectionMinusInfo.Reset()
				if err := s.ConnectionMinusInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection-info\"")
			}
		case "backup-schedule":
			if err := func() error {
				s.BackupMinusSchedule.Reset()
				if err := s.BackupMinusSchedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-schedule\"")
			}
		case "node-cpu-count":
			if err := func() error {
				s.NodeMinusCPUMinusCount.Reset()
				if err := s.NodeMinusCPUMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-cpu-count\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]DbaasIntegration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasIntegration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "node-states":
			if err := func() error {
				s.NodeMinusStates = make([]DbaasNodeState, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasNodeState
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodeMinusStates = append(s.NodeMinusStates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-states\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "backups":
			if err := func() error {
				s.Backups = make([]DbaasServiceBackup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceBackup
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Backups = append(s.Backups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backups\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "notifications":
			if err := func() error {
				s.Notifications = make([]DbaasServiceNotification, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceNotification
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Notifications = append(s.Notifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		case "components":
			if err := func() error {
				s.Components = make([]DbaasServiceMysqlComponentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceMysqlComponentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Components = append(s.Components, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"components\"")
			}
		case "mysql-settings":
			if err := func() error {
				s.MysqlMinusSettings = nil
				var elem DbaasServiceMysqlMysqlMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.MysqlMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mysql-settings\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "disk-size":
			if err := func() error {
				s.DiskMinusSize.Reset()
				if err := s.DiskMinusSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk-size\"")
			}
		case "node-memory":
			if err := func() error {
				s.NodeMinusMemory.Reset()
				if err := s.NodeMinusMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-memory\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "uri-params":
			if err := func() error {
				s.URIMinusParams = nil
				var elem DbaasServiceMysqlURIMinusParams
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.URIMinusParams = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri-params\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "created-at":
			if err := func() error {
				s.CreatedMinusAt.Reset()
				if err := s.CreatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created-at\"")
			}
		case "plan":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Plan = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "users":
			if err := func() error {
				s.Users = make([]DbaasServiceMysqlUsersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceMysqlUsersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceMysql")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b10000000,
		0b00000001,
		0b10000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceMysql) {
					name = jsonFieldsNameOfDbaasServiceMysql[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceMysql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceMysql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceMysqlBackupMinusSchedule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceMysqlBackupMinusSchedule) encodeFields(e *jx.Encoder) {
	{
		if s.BackupMinusHour.Set {
			e.FieldStart("backup-hour")
			s.BackupMinusHour.Encode(e)
		}
	}
	{
		if s.BackupMinusMinute.Set {
			e.FieldStart("backup-minute")
			s.BackupMinusMinute.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceMysqlBackupMinusSchedule = [2]string{
	0: "backup-hour",
	1: "backup-minute",
}

// Decode decodes DbaasServiceMysqlBackupMinusSchedule from json.
func (s *DbaasServiceMysqlBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceMysqlBackupMinusSchedule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backup-hour":
			if err := func() error {
				s.BackupMinusHour.Reset()
				if err := s.BackupMinusHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-hour\"")
			}
		case "backup-minute":
			if err := func() error {
				s.BackupMinusMinute.Reset()
				if err := s.BackupMinusMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-minute\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceMysqlBackupMinusSchedule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceMysqlBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceMysqlBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceMysqlComponentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceMysqlComponentsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("component")
		e.Str(s.Component)
	}
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		e.FieldStart("route")
		s.Route.Encode(e)
	}
	{
		e.FieldStart("usage")
		s.Usage.Encode(e)
	}
}

var jsonFieldsNameOfDbaasServiceMysqlComponentsItem = [5]string{
	0: "component",
	1: "host",
	2: "port",
	3: "route",
	4: "usage",
}

// Decode decodes DbaasServiceMysqlComponentsItem from json.
func (s *DbaasServiceMysqlComponentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceMysqlComponentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "component":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Component = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "route":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Route.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"route\"")
			}
		case "usage":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceMysqlComponentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceMysqlComponentsItem) {
					name = jsonFieldsNameOfDbaasServiceMysqlComponentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceMysqlComponentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceMysqlComponentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceMysqlConnectionMinusInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceMysqlConnectionMinusInfo) encodeFields(e *jx.Encoder) {
	{
		if s.URI != nil {
			e.FieldStart("uri")
			e.ArrStart()
			for _, elem := range s.URI {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Params != nil {
			e.FieldStart("params")
			e.ArrStart()
			for _, elem := range s.Params {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Standby != nil {
			e.FieldStart("standby")
			e.ArrStart()
			for _, elem := range s.Standby {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasServiceMysqlConnectionMinusInfo = [3]string{
	0: "uri",
	1: "params",
	2: "standby",
}

// Decode decodes DbaasServiceMysqlConnectionMinusInfo from json.
func (s *DbaasServiceMysqlConnectionMinusInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceMysqlConnectionMinusInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.URI = append(s.URI, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "params":
			if err := func() error {
				s.Params = make([]DbaasServiceMysqlConnectionMinusInfoParamsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceMysqlConnectionMinusInfoParamsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Params = append(s.Params, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"params\"")
			}
		case "standby":
			if err := func() error {
				s.Standby = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Standby = append(s.Standby, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standby\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceMysqlConnectionMinusInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceMysqlConnectionMinusInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceMysqlConnectionMinusInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DbaasServiceMysqlConnectionMinusInfoParamsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DbaasServiceMysqlConnectionMinusInfoParamsItem) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DbaasServiceMysqlConnectionMinusInfoParamsItem from json.
func (s *DbaasServiceMysqlConnectionMinusInfoParamsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceMysqlConnectionMinusInfoParamsItem to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceMysqlConnectionMinusInfoParamsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasServiceMysqlConnectionMinusInfoParamsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceMysqlConnectionMinusInfoParamsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceMysqlMysqlMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceMysqlMysqlMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceMysqlMysqlMinusSettings = [0]string{}

// Decode decodes DbaasServiceMysqlMysqlMinusSettings from json.
func (s *DbaasServiceMysqlMysqlMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceMysqlMysqlMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceMysqlMysqlMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceMysqlMysqlMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceMysqlMysqlMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceMysqlURIMinusParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceMysqlURIMinusParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceMysqlURIMinusParams = [0]string{}

// Decode decodes DbaasServiceMysqlURIMinusParams from json.
func (s *DbaasServiceMysqlURIMinusParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceMysqlURIMinusParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceMysqlURIMinusParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceMysqlURIMinusParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceMysqlURIMinusParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceMysqlUsersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceMysqlUsersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.Authentication.Set {
			e.FieldStart("authentication")
			s.Authentication.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceMysqlUsersItem = [4]string{
	0: "type",
	1: "username",
	2: "password",
	3: "authentication",
}

// Decode decodes DbaasServiceMysqlUsersItem from json.
func (s *DbaasServiceMysqlUsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceMysqlUsersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "authentication":
			if err := func() error {
				s.Authentication.Reset()
				if err := s.Authentication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authentication\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceMysqlUsersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceMysqlUsersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceMysqlUsersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceName as json.
func (s DbaasServiceName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DbaasServiceName from json.
func (s *DbaasServiceName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DbaasServiceName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasServiceName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceNotification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceNotification) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("level")
		s.Level.Encode(e)
	}
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("metadata")
		s.Metadata.Encode(e)
	}
}

var jsonFieldsNameOfDbaasServiceNotification = [4]string{
	0: "level",
	1: "message",
	2: "type",
	3: "metadata",
}

// Decode decodes DbaasServiceNotification from json.
func (s *DbaasServiceNotification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceNotification to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "level":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "metadata":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Metadata.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metadata\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceNotification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceNotification) {
					name = jsonFieldsNameOfDbaasServiceNotification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceNotification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceNotification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceNotificationLevel as json.
func (s DbaasServiceNotificationLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DbaasServiceNotificationLevel from json.
func (s *DbaasServiceNotificationLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceNotificationLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DbaasServiceNotificationLevel(v) {
	case DbaasServiceNotificationLevelWarning:
		*s = DbaasServiceNotificationLevelWarning
	case DbaasServiceNotificationLevelNotice:
		*s = DbaasServiceNotificationLevelNotice
	default:
		*s = DbaasServiceNotificationLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasServiceNotificationLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceNotificationLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceNotificationMetadata) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceNotificationMetadata) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceNotificationMetadata = [0]string{}

// Decode decodes DbaasServiceNotificationMetadata from json.
func (s *DbaasServiceNotificationMetadata) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceNotificationMetadata to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceNotificationMetadata")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceNotificationMetadata) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceNotificationMetadata) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceNotificationType as json.
func (s DbaasServiceNotificationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DbaasServiceNotificationType from json.
func (s *DbaasServiceNotificationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceNotificationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DbaasServiceNotificationType(v) {
	case DbaasServiceNotificationTypeServicePoweredOffRemoval:
		*s = DbaasServiceNotificationTypeServicePoweredOffRemoval
	case DbaasServiceNotificationTypeServiceEndOfLife:
		*s = DbaasServiceNotificationTypeServiceEndOfLife
	default:
		*s = DbaasServiceNotificationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasServiceNotificationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceNotificationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceOpensearch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceOpensearch) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.MaxMinusIndexMinusCount.Set {
			e.FieldStart("max-index-count")
			s.MaxMinusIndexMinusCount.Encode(e)
		}
	}
	{
		if s.UpdatedMinusAt.Set {
			e.FieldStart("updated-at")
			s.UpdatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.NodeMinusCount.Set {
			e.FieldStart("node-count")
			s.NodeMinusCount.Encode(e)
		}
	}
	{
		if s.ConnectionMinusInfo.Set {
			e.FieldStart("connection-info")
			s.ConnectionMinusInfo.Encode(e)
		}
	}
	{
		if s.NodeMinusCPUMinusCount.Set {
			e.FieldStart("node-cpu-count")
			s.NodeMinusCPUMinusCount.Encode(e)
		}
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeMinusStates != nil {
			e.FieldStart("node-states")
			e.ArrStart()
			for _, elem := range s.NodeMinusStates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.KeepMinusIndexMinusRefreshMinusInterval.Set {
			e.FieldStart("keep-index-refresh-interval")
			s.KeepMinusIndexMinusRefreshMinusInterval.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Backups != nil {
			e.FieldStart("backups")
			e.ArrStart()
			for _, elem := range s.Backups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.Notifications != nil {
			e.FieldStart("notifications")
			e.ArrStart()
			for _, elem := range s.Notifications {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Components != nil {
			e.FieldStart("components")
			e.ArrStart()
			for _, elem := range s.Components {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IndexMinusPatterns != nil {
			e.FieldStart("index-patterns")
			e.ArrStart()
			for _, elem := range s.IndexMinusPatterns {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.IndexMinusTemplate.Set {
			e.FieldStart("index-template")
			s.IndexMinusTemplate.Encode(e)
		}
	}
	{
		if s.DiskMinusSize.Set {
			e.FieldStart("disk-size")
			s.DiskMinusSize.Encode(e)
		}
	}
	{
		if s.NodeMinusMemory.Set {
			e.FieldStart("node-memory")
			s.NodeMinusMemory.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.OpensearchMinusSettings != nil {
			e.FieldStart("opensearch-settings")
			s.OpensearchMinusSettings.Encode(e)
		}
	}
	{
		if s.URIMinusParams != nil {
			e.FieldStart("uri-params")
			s.URIMinusParams.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.CreatedMinusAt.Set {
			e.FieldStart("created-at")
			s.CreatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("plan")
		e.Str(s.Plan)
	}
	{
		if s.OpensearchMinusDashboards.Set {
			e.FieldStart("opensearch-dashboards")
			s.OpensearchMinusDashboards.Encode(e)
		}
	}
	{
		if s.Users != nil {
			e.FieldStart("users")
			e.ArrStart()
			for _, elem := range s.Users {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasServiceOpensearch = [30]string{
	0:  "description",
	1:  "max-index-count",
	2:  "updated-at",
	3:  "node-count",
	4:  "connection-info",
	5:  "node-cpu-count",
	6:  "integrations",
	7:  "node-states",
	8:  "name",
	9:  "keep-index-refresh-interval",
	10: "type",
	11: "state",
	12: "ip-filter",
	13: "backups",
	14: "termination-protection",
	15: "notifications",
	16: "components",
	17: "index-patterns",
	18: "maintenance",
	19: "index-template",
	20: "disk-size",
	21: "node-memory",
	22: "uri",
	23: "opensearch-settings",
	24: "uri-params",
	25: "version",
	26: "created-at",
	27: "plan",
	28: "opensearch-dashboards",
	29: "users",
}

// Decode decodes DbaasServiceOpensearch from json.
func (s *DbaasServiceOpensearch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceOpensearch to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "max-index-count":
			if err := func() error {
				s.MaxMinusIndexMinusCount.Reset()
				if err := s.MaxMinusIndexMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-index-count\"")
			}
		case "updated-at":
			if err := func() error {
				s.UpdatedMinusAt.Reset()
				if err := s.UpdatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated-at\"")
			}
		case "node-count":
			if err := func() error {
				s.NodeMinusCount.Reset()
				if err := s.NodeMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-count\"")
			}
		case "connection-info":
			if err := func() error {
				s.ConnectionMinusInfo.Reset()
				if err := s.ConnectionMinusInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection-info\"")
			}
		case "node-cpu-count":
			if err := func() error {
				s.NodeMinusCPUMinusCount.Reset()
				if err := s.NodeMinusCPUMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-cpu-count\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]DbaasIntegration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasIntegration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "node-states":
			if err := func() error {
				s.NodeMinusStates = make([]DbaasNodeState, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasNodeState
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodeMinusStates = append(s.NodeMinusStates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-states\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "keep-index-refresh-interval":
			if err := func() error {
				s.KeepMinusIndexMinusRefreshMinusInterval.Reset()
				if err := s.KeepMinusIndexMinusRefreshMinusInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keep-index-refresh-interval\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "backups":
			if err := func() error {
				s.Backups = make([]DbaasServiceBackup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceBackup
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Backups = append(s.Backups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backups\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "notifications":
			if err := func() error {
				s.Notifications = make([]DbaasServiceNotification, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceNotification
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Notifications = append(s.Notifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		case "components":
			if err := func() error {
				s.Components = make([]DbaasServiceOpensearchComponentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceOpensearchComponentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Components = append(s.Components, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"components\"")
			}
		case "index-patterns":
			if err := func() error {
				s.IndexMinusPatterns = make([]DbaasServiceOpensearchIndexMinusPatternsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceOpensearchIndexMinusPatternsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IndexMinusPatterns = append(s.IndexMinusPatterns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index-patterns\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "index-template":
			if err := func() error {
				s.IndexMinusTemplate.Reset()
				if err := s.IndexMinusTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index-template\"")
			}
		case "disk-size":
			if err := func() error {
				s.DiskMinusSize.Reset()
				if err := s.DiskMinusSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk-size\"")
			}
		case "node-memory":
			if err := func() error {
				s.NodeMinusMemory.Reset()
				if err := s.NodeMinusMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-memory\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "opensearch-settings":
			if err := func() error {
				s.OpensearchMinusSettings = nil
				var elem DbaasServiceOpensearchOpensearchMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.OpensearchMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opensearch-settings\"")
			}
		case "uri-params":
			if err := func() error {
				s.URIMinusParams = nil
				var elem DbaasServiceOpensearchURIMinusParams
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.URIMinusParams = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri-params\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "created-at":
			if err := func() error {
				s.CreatedMinusAt.Reset()
				if err := s.CreatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created-at\"")
			}
		case "plan":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Plan = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "opensearch-dashboards":
			if err := func() error {
				s.OpensearchMinusDashboards.Reset()
				if err := s.OpensearchMinusDashboards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opensearch-dashboards\"")
			}
		case "users":
			if err := func() error {
				s.Users = make([]DbaasServiceOpensearchUsersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceOpensearchUsersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceOpensearch")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00000000,
		0b00000101,
		0b00000000,
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceOpensearch) {
					name = jsonFieldsNameOfDbaasServiceOpensearch[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceOpensearch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceOpensearch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceOpensearchComponentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceOpensearchComponentsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("component")
		e.Str(s.Component)
	}
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		e.FieldStart("route")
		s.Route.Encode(e)
	}
	{
		e.FieldStart("usage")
		s.Usage.Encode(e)
	}
}

var jsonFieldsNameOfDbaasServiceOpensearchComponentsItem = [5]string{
	0: "component",
	1: "host",
	2: "port",
	3: "route",
	4: "usage",
}

// Decode decodes DbaasServiceOpensearchComponentsItem from json.
func (s *DbaasServiceOpensearchComponentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceOpensearchComponentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "component":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Component = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "route":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Route.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"route\"")
			}
		case "usage":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceOpensearchComponentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceOpensearchComponentsItem) {
					name = jsonFieldsNameOfDbaasServiceOpensearchComponentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceOpensearchComponentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceOpensearchComponentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceOpensearchConnectionMinusInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceOpensearchConnectionMinusInfo) encodeFields(e *jx.Encoder) {
	{
		if s.URI != nil {
			e.FieldStart("uri")
			e.ArrStart()
			for _, elem := range s.URI {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.DashboardMinusURI.Set {
			e.FieldStart("dashboard-uri")
			s.DashboardMinusURI.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceOpensearchConnectionMinusInfo = [4]string{
	0: "uri",
	1: "username",
	2: "password",
	3: "dashboard-uri",
}

// Decode decodes DbaasServiceOpensearchConnectionMinusInfo from json.
func (s *DbaasServiceOpensearchConnectionMinusInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceOpensearchConnectionMinusInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.URI = append(s.URI, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "dashboard-uri":
			if err := func() error {
				s.DashboardMinusURI.Reset()
				if err := s.DashboardMinusURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dashboard-uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceOpensearchConnectionMinusInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceOpensearchConnectionMinusInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceOpensearchConnectionMinusInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceOpensearchIndexMinusPatternsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceOpensearchIndexMinusPatternsItem) encodeFields(e *jx.Encoder) {
	{
		if s.MaxMinusIndexMinusCount.Set {
			e.FieldStart("max-index-count")
			s.MaxMinusIndexMinusCount.Encode(e)
		}
	}
	{
		if s.SortingMinusAlgorithm.Set {
			e.FieldStart("sorting-algorithm")
			s.SortingMinusAlgorithm.Encode(e)
		}
	}
	{
		if s.Pattern.Set {
			e.FieldStart("pattern")
			s.Pattern.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceOpensearchIndexMinusPatternsItem = [3]string{
	0: "max-index-count",
	1: "sorting-algorithm",
	2: "pattern",
}

// Decode decodes DbaasServiceOpensearchIndexMinusPatternsItem from json.
func (s *DbaasServiceOpensearchIndexMinusPatternsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceOpensearchIndexMinusPatternsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max-index-count":
			if err := func() error {
				s.MaxMinusIndexMinusCount.Reset()
				if err := s.MaxMinusIndexMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-index-count\"")
			}
		case "sorting-algorithm":
			if err := func() error {
				s.SortingMinusAlgorithm.Reset()
				if err := s.SortingMinusAlgorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sorting-algorithm\"")
			}
		case "pattern":
			if err := func() error {
				s.Pattern.Reset()
				if err := s.Pattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceOpensearchIndexMinusPatternsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceOpensearchIndexMinusPatternsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceOpensearchIndexMinusPatternsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm as json.
func (s DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm from json.
func (s *DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm(v) {
	case DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithmAlphabetical:
		*s = DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithmAlphabetical
	case DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithmCreationDate:
		*s = DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithmCreationDate
	default:
		*s = DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceOpensearchIndexMinusTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceOpensearchIndexMinusTemplate) encodeFields(e *jx.Encoder) {
	{
		if s.MappingMinusNestedMinusObjectsMinusLimit.Set {
			e.FieldStart("mapping-nested-objects-limit")
			s.MappingMinusNestedMinusObjectsMinusLimit.Encode(e)
		}
	}
	{
		if s.NumberMinusOfMinusReplicas.Set {
			e.FieldStart("number-of-replicas")
			s.NumberMinusOfMinusReplicas.Encode(e)
		}
	}
	{
		if s.NumberMinusOfMinusShards.Set {
			e.FieldStart("number-of-shards")
			s.NumberMinusOfMinusShards.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceOpensearchIndexMinusTemplate = [3]string{
	0: "mapping-nested-objects-limit",
	1: "number-of-replicas",
	2: "number-of-shards",
}

// Decode decodes DbaasServiceOpensearchIndexMinusTemplate from json.
func (s *DbaasServiceOpensearchIndexMinusTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceOpensearchIndexMinusTemplate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mapping-nested-objects-limit":
			if err := func() error {
				s.MappingMinusNestedMinusObjectsMinusLimit.Reset()
				if err := s.MappingMinusNestedMinusObjectsMinusLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapping-nested-objects-limit\"")
			}
		case "number-of-replicas":
			if err := func() error {
				s.NumberMinusOfMinusReplicas.Reset()
				if err := s.NumberMinusOfMinusReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number-of-replicas\"")
			}
		case "number-of-shards":
			if err := func() error {
				s.NumberMinusOfMinusShards.Reset()
				if err := s.NumberMinusOfMinusShards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number-of-shards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceOpensearchIndexMinusTemplate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceOpensearchIndexMinusTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceOpensearchIndexMinusTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceOpensearchOpensearchMinusDashboards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceOpensearchOpensearchMinusDashboards) encodeFields(e *jx.Encoder) {
	{
		if s.OpensearchMinusRequestMinusTimeout.Set {
			e.FieldStart("opensearch-request-timeout")
			s.OpensearchMinusRequestMinusTimeout.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.MaxMinusOldMinusSpaceMinusSize.Set {
			e.FieldStart("max-old-space-size")
			s.MaxMinusOldMinusSpaceMinusSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceOpensearchOpensearchMinusDashboards = [3]string{
	0: "opensearch-request-timeout",
	1: "enabled",
	2: "max-old-space-size",
}

// Decode decodes DbaasServiceOpensearchOpensearchMinusDashboards from json.
func (s *DbaasServiceOpensearchOpensearchMinusDashboards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceOpensearchOpensearchMinusDashboards to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "opensearch-request-timeout":
			if err := func() error {
				s.OpensearchMinusRequestMinusTimeout.Reset()
				if err := s.OpensearchMinusRequestMinusTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opensearch-request-timeout\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "max-old-space-size":
			if err := func() error {
				s.MaxMinusOldMinusSpaceMinusSize.Reset()
				if err := s.MaxMinusOldMinusSpaceMinusSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-old-space-size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceOpensearchOpensearchMinusDashboards")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceOpensearchOpensearchMinusDashboards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceOpensearchOpensearchMinusDashboards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceOpensearchOpensearchMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceOpensearchOpensearchMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceOpensearchOpensearchMinusSettings = [0]string{}

// Decode decodes DbaasServiceOpensearchOpensearchMinusSettings from json.
func (s *DbaasServiceOpensearchOpensearchMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceOpensearchOpensearchMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceOpensearchOpensearchMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceOpensearchOpensearchMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceOpensearchOpensearchMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceOpensearchURIMinusParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceOpensearchURIMinusParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceOpensearchURIMinusParams = [0]string{}

// Decode decodes DbaasServiceOpensearchURIMinusParams from json.
func (s *DbaasServiceOpensearchURIMinusParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceOpensearchURIMinusParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceOpensearchURIMinusParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceOpensearchURIMinusParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceOpensearchURIMinusParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceOpensearchUsersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceOpensearchUsersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceOpensearchUsersItem = [3]string{
	0: "type",
	1: "username",
	2: "password",
}

// Decode decodes DbaasServiceOpensearchUsersItem from json.
func (s *DbaasServiceOpensearchUsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceOpensearchUsersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceOpensearchUsersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceOpensearchUsersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceOpensearchUsersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePg) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePg) encodeFields(e *jx.Encoder) {
	{
		if s.PgbouncerMinusSettings != nil {
			e.FieldStart("pgbouncer-settings")
			s.PgbouncerMinusSettings.Encode(e)
		}
	}
	{
		if s.UpdatedMinusAt.Set {
			e.FieldStart("updated-at")
			s.UpdatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.NodeMinusCount.Set {
			e.FieldStart("node-count")
			s.NodeMinusCount.Encode(e)
		}
	}
	{
		if s.ConnectionMinusInfo.Set {
			e.FieldStart("connection-info")
			s.ConnectionMinusInfo.Encode(e)
		}
	}
	{
		if s.BackupMinusSchedule.Set {
			e.FieldStart("backup-schedule")
			s.BackupMinusSchedule.Encode(e)
		}
	}
	{
		if s.NodeMinusCPUMinusCount.Set {
			e.FieldStart("node-cpu-count")
			s.NodeMinusCPUMinusCount.Encode(e)
		}
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeMinusStates != nil {
			e.FieldStart("node-states")
			e.ArrStart()
			for _, elem := range s.NodeMinusStates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.ConnectionMinusPools != nil {
			e.FieldStart("connection-pools")
			e.ArrStart()
			for _, elem := range s.ConnectionMinusPools {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.TimescaledbMinusSettings != nil {
			e.FieldStart("timescaledb-settings")
			s.TimescaledbMinusSettings.Encode(e)
		}
	}
	{
		if s.Databases != nil {
			e.FieldStart("databases")
			e.ArrStart()
			for _, elem := range s.Databases {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Backups != nil {
			e.FieldStart("backups")
			e.ArrStart()
			for _, elem := range s.Backups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.Notifications != nil {
			e.FieldStart("notifications")
			e.ArrStart()
			for _, elem := range s.Notifications {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Components != nil {
			e.FieldStart("components")
			e.ArrStart()
			for _, elem := range s.Components {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SynchronousMinusReplication.Set {
			e.FieldStart("synchronous-replication")
			s.SynchronousMinusReplication.Encode(e)
		}
	}
	{
		if s.PglookoutMinusSettings != nil {
			e.FieldStart("pglookout-settings")
			s.PglookoutMinusSettings.Encode(e)
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.DiskMinusSize.Set {
			e.FieldStart("disk-size")
			s.DiskMinusSize.Encode(e)
		}
	}
	{
		if s.NodeMinusMemory.Set {
			e.FieldStart("node-memory")
			s.NodeMinusMemory.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.URIMinusParams != nil {
			e.FieldStart("uri-params")
			s.URIMinusParams.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.CreatedMinusAt.Set {
			e.FieldStart("created-at")
			s.CreatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("plan")
		e.Str(s.Plan)
	}
	{
		if s.WorkMinusMem.Set {
			e.FieldStart("work-mem")
			s.WorkMinusMem.Encode(e)
		}
	}
	{
		if s.SharedMinusBuffersMinusPercentage.Set {
			e.FieldStart("shared-buffers-percentage")
			s.SharedMinusBuffersMinusPercentage.Encode(e)
		}
	}
	{
		if s.PgMinusSettings != nil {
			e.FieldStart("pg-settings")
			s.PgMinusSettings.Encode(e)
		}
	}
	{
		if s.MaxMinusConnections.Set {
			e.FieldStart("max-connections")
			s.MaxMinusConnections.Encode(e)
		}
	}
	{
		if s.Users != nil {
			e.FieldStart("users")
			e.ArrStart()
			for _, elem := range s.Users {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasServicePg = [34]string{
	0:  "pgbouncer-settings",
	1:  "updated-at",
	2:  "node-count",
	3:  "connection-info",
	4:  "backup-schedule",
	5:  "node-cpu-count",
	6:  "integrations",
	7:  "node-states",
	8:  "name",
	9:  "connection-pools",
	10: "type",
	11: "state",
	12: "timescaledb-settings",
	13: "databases",
	14: "ip-filter",
	15: "backups",
	16: "termination-protection",
	17: "notifications",
	18: "components",
	19: "synchronous-replication",
	20: "pglookout-settings",
	21: "maintenance",
	22: "disk-size",
	23: "node-memory",
	24: "uri",
	25: "uri-params",
	26: "version",
	27: "created-at",
	28: "plan",
	29: "work-mem",
	30: "shared-buffers-percentage",
	31: "pg-settings",
	32: "max-connections",
	33: "users",
}

// Decode decodes DbaasServicePg from json.
func (s *DbaasServicePg) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePg to nil")
	}
	var requiredBitSet [5]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pgbouncer-settings":
			if err := func() error {
				s.PgbouncerMinusSettings = nil
				var elem DbaasServicePgPgbouncerMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PgbouncerMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pgbouncer-settings\"")
			}
		case "updated-at":
			if err := func() error {
				s.UpdatedMinusAt.Reset()
				if err := s.UpdatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated-at\"")
			}
		case "node-count":
			if err := func() error {
				s.NodeMinusCount.Reset()
				if err := s.NodeMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-count\"")
			}
		case "connection-info":
			if err := func() error {
				s.ConnectionMinusInfo.Reset()
				if err := s.ConnectionMinusInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection-info\"")
			}
		case "backup-schedule":
			if err := func() error {
				s.BackupMinusSchedule.Reset()
				if err := s.BackupMinusSchedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-schedule\"")
			}
		case "node-cpu-count":
			if err := func() error {
				s.NodeMinusCPUMinusCount.Reset()
				if err := s.NodeMinusCPUMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-cpu-count\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]DbaasIntegration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasIntegration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "node-states":
			if err := func() error {
				s.NodeMinusStates = make([]DbaasNodeState, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasNodeState
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodeMinusStates = append(s.NodeMinusStates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-states\"")
			}
		case "name":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "connection-pools":
			if err := func() error {
				s.ConnectionMinusPools = make([]DbaasServicePgConnectionMinusPoolsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServicePgConnectionMinusPoolsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ConnectionMinusPools = append(s.ConnectionMinusPools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection-pools\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "timescaledb-settings":
			if err := func() error {
				s.TimescaledbMinusSettings = nil
				var elem DbaasServicePgTimescaledbMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TimescaledbMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timescaledb-settings\"")
			}
		case "databases":
			if err := func() error {
				s.Databases = make([]DbaasPgDatabaseName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasPgDatabaseName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Databases = append(s.Databases, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"databases\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "backups":
			if err := func() error {
				s.Backups = make([]DbaasServiceBackup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceBackup
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Backups = append(s.Backups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backups\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "notifications":
			if err := func() error {
				s.Notifications = make([]DbaasServiceNotification, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceNotification
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Notifications = append(s.Notifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		case "components":
			if err := func() error {
				s.Components = make([]DbaasServicePgComponentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServicePgComponentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Components = append(s.Components, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"components\"")
			}
		case "synchronous-replication":
			if err := func() error {
				s.SynchronousMinusReplication.Reset()
				if err := s.SynchronousMinusReplication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synchronous-replication\"")
			}
		case "pglookout-settings":
			if err := func() error {
				s.PglookoutMinusSettings = nil
				var elem DbaasServicePgPglookoutMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PglookoutMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pglookout-settings\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "disk-size":
			if err := func() error {
				s.DiskMinusSize.Reset()
				if err := s.DiskMinusSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk-size\"")
			}
		case "node-memory":
			if err := func() error {
				s.NodeMinusMemory.Reset()
				if err := s.NodeMinusMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-memory\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "uri-params":
			if err := func() error {
				s.URIMinusParams = nil
				var elem DbaasServicePgURIMinusParams
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.URIMinusParams = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri-params\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "created-at":
			if err := func() error {
				s.CreatedMinusAt.Reset()
				if err := s.CreatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created-at\"")
			}
		case "plan":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Plan = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "work-mem":
			if err := func() error {
				s.WorkMinusMem.Reset()
				if err := s.WorkMinusMem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"work-mem\"")
			}
		case "shared-buffers-percentage":
			if err := func() error {
				s.SharedMinusBuffersMinusPercentage.Reset()
				if err := s.SharedMinusBuffersMinusPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shared-buffers-percentage\"")
			}
		case "pg-settings":
			if err := func() error {
				s.PgMinusSettings = nil
				var elem DbaasServicePgPgMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PgMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pg-settings\"")
			}
		case "max-connections":
			if err := func() error {
				s.MaxMinusConnections.Reset()
				if err := s.MaxMinusConnections.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-connections\"")
			}
		case "users":
			if err := func() error {
				s.Users = make([]DbaasServicePgUsersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServicePgUsersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePg")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b00000000,
		0b00000101,
		0b00000000,
		0b00010000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServicePg) {
					name = jsonFieldsNameOfDbaasServicePg[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePg) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePg) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePgBackupMinusSchedule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePgBackupMinusSchedule) encodeFields(e *jx.Encoder) {
	{
		if s.BackupMinusHour.Set {
			e.FieldStart("backup-hour")
			s.BackupMinusHour.Encode(e)
		}
	}
	{
		if s.BackupMinusMinute.Set {
			e.FieldStart("backup-minute")
			s.BackupMinusMinute.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServicePgBackupMinusSchedule = [2]string{
	0: "backup-hour",
	1: "backup-minute",
}

// Decode decodes DbaasServicePgBackupMinusSchedule from json.
func (s *DbaasServicePgBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgBackupMinusSchedule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backup-hour":
			if err := func() error {
				s.BackupMinusHour.Reset()
				if err := s.BackupMinusHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-hour\"")
			}
		case "backup-minute":
			if err := func() error {
				s.BackupMinusMinute.Reset()
				if err := s.BackupMinusMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-minute\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgBackupMinusSchedule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePgBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePgComponentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePgComponentsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("component")
		e.Str(s.Component)
	}
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		e.FieldStart("route")
		s.Route.Encode(e)
	}
	{
		e.FieldStart("usage")
		s.Usage.Encode(e)
	}
}

var jsonFieldsNameOfDbaasServicePgComponentsItem = [5]string{
	0: "component",
	1: "host",
	2: "port",
	3: "route",
	4: "usage",
}

// Decode decodes DbaasServicePgComponentsItem from json.
func (s *DbaasServicePgComponentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgComponentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "component":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Component = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "route":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Route.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"route\"")
			}
		case "usage":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgComponentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServicePgComponentsItem) {
					name = jsonFieldsNameOfDbaasServicePgComponentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePgComponentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgComponentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePgConnectionMinusInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePgConnectionMinusInfo) encodeFields(e *jx.Encoder) {
	{
		if s.URI != nil {
			e.FieldStart("uri")
			e.ArrStart()
			for _, elem := range s.URI {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Params != nil {
			e.FieldStart("params")
			e.ArrStart()
			for _, elem := range s.Params {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Standby != nil {
			e.FieldStart("standby")
			e.ArrStart()
			for _, elem := range s.Standby {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Syncing != nil {
			e.FieldStart("syncing")
			e.ArrStart()
			for _, elem := range s.Syncing {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasServicePgConnectionMinusInfo = [4]string{
	0: "uri",
	1: "params",
	2: "standby",
	3: "syncing",
}

// Decode decodes DbaasServicePgConnectionMinusInfo from json.
func (s *DbaasServicePgConnectionMinusInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgConnectionMinusInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.URI = append(s.URI, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "params":
			if err := func() error {
				s.Params = make([]DbaasServicePgConnectionMinusInfoParamsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServicePgConnectionMinusInfoParamsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Params = append(s.Params, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"params\"")
			}
		case "standby":
			if err := func() error {
				s.Standby = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Standby = append(s.Standby, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"standby\"")
			}
		case "syncing":
			if err := func() error {
				s.Syncing = make([]DbaasServicePgConnectionMinusInfoSyncingItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServicePgConnectionMinusInfoSyncingItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Syncing = append(s.Syncing, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"syncing\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgConnectionMinusInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePgConnectionMinusInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgConnectionMinusInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DbaasServicePgConnectionMinusInfoParamsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DbaasServicePgConnectionMinusInfoParamsItem) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DbaasServicePgConnectionMinusInfoParamsItem from json.
func (s *DbaasServicePgConnectionMinusInfoParamsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgConnectionMinusInfoParamsItem to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgConnectionMinusInfoParamsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasServicePgConnectionMinusInfoParamsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgConnectionMinusInfoParamsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePgConnectionMinusInfoSyncingItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePgConnectionMinusInfoSyncingItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServicePgConnectionMinusInfoSyncingItem = [0]string{}

// Decode decodes DbaasServicePgConnectionMinusInfoSyncingItem from json.
func (s *DbaasServicePgConnectionMinusInfoSyncingItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgConnectionMinusInfoSyncingItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgConnectionMinusInfoSyncingItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePgConnectionMinusInfoSyncingItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgConnectionMinusInfoSyncingItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePgConnectionMinusPoolsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePgConnectionMinusPoolsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connection-uri")
		e.Str(s.ConnectionMinusURI)
	}
	{
		e.FieldStart("database")
		s.Database.Encode(e)
	}
	{
		e.FieldStart("mode")
		s.Mode.Encode(e)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("size")
		s.Size.Encode(e)
	}
	{
		e.FieldStart("username")
		s.Username.Encode(e)
	}
}

var jsonFieldsNameOfDbaasServicePgConnectionMinusPoolsItem = [6]string{
	0: "connection-uri",
	1: "database",
	2: "mode",
	3: "name",
	4: "size",
	5: "username",
}

// Decode decodes DbaasServicePgConnectionMinusPoolsItem from json.
func (s *DbaasServicePgConnectionMinusPoolsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgConnectionMinusPoolsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connection-uri":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ConnectionMinusURI = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection-uri\"")
			}
		case "database":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Database.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"database\"")
			}
		case "mode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgConnectionMinusPoolsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServicePgConnectionMinusPoolsItem) {
					name = jsonFieldsNameOfDbaasServicePgConnectionMinusPoolsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePgConnectionMinusPoolsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgConnectionMinusPoolsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePgPgMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePgPgMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServicePgPgMinusSettings = [0]string{}

// Decode decodes DbaasServicePgPgMinusSettings from json.
func (s *DbaasServicePgPgMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgPgMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgPgMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePgPgMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgPgMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePgPgbouncerMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePgPgbouncerMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServicePgPgbouncerMinusSettings = [0]string{}

// Decode decodes DbaasServicePgPgbouncerMinusSettings from json.
func (s *DbaasServicePgPgbouncerMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgPgbouncerMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgPgbouncerMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePgPgbouncerMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgPgbouncerMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePgPglookoutMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePgPglookoutMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServicePgPglookoutMinusSettings = [0]string{}

// Decode decodes DbaasServicePgPglookoutMinusSettings from json.
func (s *DbaasServicePgPglookoutMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgPglookoutMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgPglookoutMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePgPglookoutMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgPglookoutMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePgTimescaledbMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePgTimescaledbMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServicePgTimescaledbMinusSettings = [0]string{}

// Decode decodes DbaasServicePgTimescaledbMinusSettings from json.
func (s *DbaasServicePgTimescaledbMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgTimescaledbMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgTimescaledbMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePgTimescaledbMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgTimescaledbMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePgURIMinusParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePgURIMinusParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServicePgURIMinusParams = [0]string{}

// Decode decodes DbaasServicePgURIMinusParams from json.
func (s *DbaasServicePgURIMinusParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgURIMinusParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgURIMinusParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePgURIMinusParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgURIMinusParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServicePgUsersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServicePgUsersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.AllowMinusReplication.Set {
			e.FieldStart("allow-replication")
			s.AllowMinusReplication.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServicePgUsersItem = [4]string{
	0: "type",
	1: "username",
	2: "password",
	3: "allow-replication",
}

// Decode decodes DbaasServicePgUsersItem from json.
func (s *DbaasServicePgUsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServicePgUsersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "allow-replication":
			if err := func() error {
				s.AllowMinusReplication.Reset()
				if err := s.AllowMinusReplication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow-replication\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServicePgUsersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServicePgUsersItem) {
					name = jsonFieldsNameOfDbaasServicePgUsersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServicePgUsersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServicePgUsersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceRedis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceRedis) encodeFields(e *jx.Encoder) {
	{
		if s.UpdatedMinusAt.Set {
			e.FieldStart("updated-at")
			s.UpdatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.NodeMinusCount.Set {
			e.FieldStart("node-count")
			s.NodeMinusCount.Encode(e)
		}
	}
	{
		if s.ConnectionMinusInfo.Set {
			e.FieldStart("connection-info")
			s.ConnectionMinusInfo.Encode(e)
		}
	}
	{
		if s.NodeMinusCPUMinusCount.Set {
			e.FieldStart("node-cpu-count")
			s.NodeMinusCPUMinusCount.Encode(e)
		}
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeMinusStates != nil {
			e.FieldStart("node-states")
			e.ArrStart()
			for _, elem := range s.NodeMinusStates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.RedisMinusSettings != nil {
			e.FieldStart("redis-settings")
			s.RedisMinusSettings.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Backups != nil {
			e.FieldStart("backups")
			e.ArrStart()
			for _, elem := range s.Backups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.Notifications != nil {
			e.FieldStart("notifications")
			e.ArrStart()
			for _, elem := range s.Notifications {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Components != nil {
			e.FieldStart("components")
			e.ArrStart()
			for _, elem := range s.Components {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.DiskMinusSize.Set {
			e.FieldStart("disk-size")
			s.DiskMinusSize.Encode(e)
		}
	}
	{
		if s.NodeMinusMemory.Set {
			e.FieldStart("node-memory")
			s.NodeMinusMemory.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.URIMinusParams != nil {
			e.FieldStart("uri-params")
			s.URIMinusParams.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.CreatedMinusAt.Set {
			e.FieldStart("created-at")
			s.CreatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("plan")
		e.Str(s.Plan)
	}
	{
		if s.Users != nil {
			e.FieldStart("users")
			e.ArrStart()
			for _, elem := range s.Users {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasServiceRedis = [24]string{
	0:  "updated-at",
	1:  "node-count",
	2:  "connection-info",
	3:  "node-cpu-count",
	4:  "integrations",
	5:  "node-states",
	6:  "name",
	7:  "redis-settings",
	8:  "type",
	9:  "state",
	10: "ip-filter",
	11: "backups",
	12: "termination-protection",
	13: "notifications",
	14: "components",
	15: "maintenance",
	16: "disk-size",
	17: "node-memory",
	18: "uri",
	19: "uri-params",
	20: "version",
	21: "created-at",
	22: "plan",
	23: "users",
}

// Decode decodes DbaasServiceRedis from json.
func (s *DbaasServiceRedis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceRedis to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "updated-at":
			if err := func() error {
				s.UpdatedMinusAt.Reset()
				if err := s.UpdatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated-at\"")
			}
		case "node-count":
			if err := func() error {
				s.NodeMinusCount.Reset()
				if err := s.NodeMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-count\"")
			}
		case "connection-info":
			if err := func() error {
				s.ConnectionMinusInfo.Reset()
				if err := s.ConnectionMinusInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connection-info\"")
			}
		case "node-cpu-count":
			if err := func() error {
				s.NodeMinusCPUMinusCount.Reset()
				if err := s.NodeMinusCPUMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-cpu-count\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]DbaasIntegration, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasIntegration
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "node-states":
			if err := func() error {
				s.NodeMinusStates = make([]DbaasNodeState, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasNodeState
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodeMinusStates = append(s.NodeMinusStates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-states\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "redis-settings":
			if err := func() error {
				s.RedisMinusSettings = nil
				var elem DbaasServiceRedisRedisMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RedisMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redis-settings\"")
			}
		case "type":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "backups":
			if err := func() error {
				s.Backups = make([]DbaasServiceBackup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceBackup
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Backups = append(s.Backups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backups\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "notifications":
			if err := func() error {
				s.Notifications = make([]DbaasServiceNotification, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceNotification
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Notifications = append(s.Notifications, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifications\"")
			}
		case "components":
			if err := func() error {
				s.Components = make([]DbaasServiceRedisComponentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceRedisComponentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Components = append(s.Components, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"components\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "disk-size":
			if err := func() error {
				s.DiskMinusSize.Reset()
				if err := s.DiskMinusSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk-size\"")
			}
		case "node-memory":
			if err := func() error {
				s.NodeMinusMemory.Reset()
				if err := s.NodeMinusMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node-memory\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "uri-params":
			if err := func() error {
				s.URIMinusParams = nil
				var elem DbaasServiceRedisURIMinusParams
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.URIMinusParams = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri-params\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "created-at":
			if err := func() error {
				s.CreatedMinusAt.Reset()
				if err := s.CreatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created-at\"")
			}
		case "plan":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Plan = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "users":
			if err := func() error {
				s.Users = make([]DbaasServiceRedisUsersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceRedisUsersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceRedis")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01000000,
		0b00000001,
		0b01000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceRedis) {
					name = jsonFieldsNameOfDbaasServiceRedis[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceRedis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceRedis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceRedisComponentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceRedisComponentsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("component")
		e.Str(s.Component)
	}
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		e.FieldStart("route")
		s.Route.Encode(e)
	}
	{
		if s.Ssl.Set {
			e.FieldStart("ssl")
			s.Ssl.Encode(e)
		}
	}
	{
		e.FieldStart("usage")
		s.Usage.Encode(e)
	}
}

var jsonFieldsNameOfDbaasServiceRedisComponentsItem = [6]string{
	0: "component",
	1: "host",
	2: "port",
	3: "route",
	4: "ssl",
	5: "usage",
}

// Decode decodes DbaasServiceRedisComponentsItem from json.
func (s *DbaasServiceRedisComponentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceRedisComponentsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "component":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Component = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"component\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "route":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Route.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"route\"")
			}
		case "ssl":
			if err := func() error {
				s.Ssl.Reset()
				if err := s.Ssl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssl\"")
			}
		case "usage":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceRedisComponentsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaasServiceRedisComponentsItem) {
					name = jsonFieldsNameOfDbaasServiceRedisComponentsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceRedisComponentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceRedisComponentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceRedisConnectionMinusInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceRedisConnectionMinusInfo) encodeFields(e *jx.Encoder) {
	{
		if s.URI != nil {
			e.FieldStart("uri")
			e.ArrStart()
			for _, elem := range s.URI {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.Slave != nil {
			e.FieldStart("slave")
			e.ArrStart()
			for _, elem := range s.Slave {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasServiceRedisConnectionMinusInfo = [3]string{
	0: "uri",
	1: "password",
	2: "slave",
}

// Decode decodes DbaasServiceRedisConnectionMinusInfo from json.
func (s *DbaasServiceRedisConnectionMinusInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceRedisConnectionMinusInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.URI = append(s.URI, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "slave":
			if err := func() error {
				s.Slave = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Slave = append(s.Slave, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slave\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceRedisConnectionMinusInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceRedisConnectionMinusInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceRedisConnectionMinusInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceRedisRedisMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceRedisRedisMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceRedisRedisMinusSettings = [0]string{}

// Decode decodes DbaasServiceRedisRedisMinusSettings from json.
func (s *DbaasServiceRedisRedisMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceRedisRedisMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceRedisRedisMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceRedisRedisMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceRedisRedisMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceRedisURIMinusParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceRedisURIMinusParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfDbaasServiceRedisURIMinusParams = [0]string{}

// Decode decodes DbaasServiceRedisURIMinusParams from json.
func (s *DbaasServiceRedisURIMinusParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceRedisURIMinusParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceRedisURIMinusParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceRedisURIMinusParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceRedisURIMinusParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceRedisUsersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceRedisUsersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.AccessMinusControl.Set {
			e.FieldStart("access-control")
			s.AccessMinusControl.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaasServiceRedisUsersItem = [4]string{
	0: "type",
	1: "username",
	2: "password",
	3: "access-control",
}

// Decode decodes DbaasServiceRedisUsersItem from json.
func (s *DbaasServiceRedisUsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceRedisUsersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "access-control":
			if err := func() error {
				s.AccessMinusControl.Reset()
				if err := s.AccessMinusControl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access-control\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceRedisUsersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceRedisUsersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceRedisUsersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceRedisUsersItemAccessMinusControl) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceRedisUsersItemAccessMinusControl) encodeFields(e *jx.Encoder) {
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Channels != nil {
			e.FieldStart("channels")
			e.ArrStart()
			for _, elem := range s.Channels {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Commands != nil {
			e.FieldStart("commands")
			e.ArrStart()
			for _, elem := range s.Commands {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Keys != nil {
			e.FieldStart("keys")
			e.ArrStart()
			for _, elem := range s.Keys {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasServiceRedisUsersItemAccessMinusControl = [4]string{
	0: "categories",
	1: "channels",
	2: "commands",
	3: "keys",
}

// Decode decodes DbaasServiceRedisUsersItemAccessMinusControl from json.
func (s *DbaasServiceRedisUsersItemAccessMinusControl) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceRedisUsersItemAccessMinusControl to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "categories":
			if err := func() error {
				s.Categories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "channels":
			if err := func() error {
				s.Channels = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Channels = append(s.Channels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channels\"")
			}
		case "commands":
			if err := func() error {
				s.Commands = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Commands = append(s.Commands, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commands\"")
			}
		case "keys":
			if err := func() error {
				s.Keys = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Keys = append(s.Keys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceRedisUsersItemAccessMinusControl")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceRedisUsersItemAccessMinusControl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceRedisUsersItemAccessMinusControl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceType) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.AvailableMinusVersions != nil {
			e.FieldStart("available-versions")
			e.ArrStart()
			for _, elem := range s.AvailableMinusVersions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DefaultMinusVersion.Set {
			e.FieldStart("default-version")
			s.DefaultMinusVersion.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Plans != nil {
			e.FieldStart("plans")
			e.ArrStart()
			for _, elem := range s.Plans {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDbaasServiceType = [5]string{
	0: "name",
	1: "available-versions",
	2: "default-version",
	3: "description",
	4: "plans",
}

// Decode decodes DbaasServiceType from json.
func (s *DbaasServiceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "available-versions":
			if err := func() error {
				s.AvailableMinusVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AvailableMinusVersions = append(s.AvailableMinusVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available-versions\"")
			}
		case "default-version":
			if err := func() error {
				s.DefaultMinusVersion.Reset()
				if err := s.DefaultMinusVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default-version\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "plans":
			if err := func() error {
				s.Plans = make([]DbaasPlan, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasPlan
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Plans = append(s.Plans, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plans\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceTypeName as json.
func (s DbaasServiceTypeName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DbaasServiceTypeName from json.
func (s *DbaasServiceTypeName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceTypeName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DbaasServiceTypeName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasServiceTypeName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceTypeName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaasServiceUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaasServiceUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Deadline.Set {
			e.FieldStart("deadline")
			s.Deadline.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.StartMinusAfter.Set {
			e.FieldStart("start-after")
			s.StartMinusAfter.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.StartMinusAt.Set {
			e.FieldStart("start-at")
			s.StartMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfDbaasServiceUpdate = [4]string{
	0: "description",
	1: "deadline",
	2: "start-after",
	3: "start-at",
}

// Decode decodes DbaasServiceUpdate from json.
func (s *DbaasServiceUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasServiceUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "deadline":
			if err := func() error {
				s.Deadline.Reset()
				if err := s.Deadline.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deadline\"")
			}
		case "start-after":
			if err := func() error {
				s.StartMinusAfter.Reset()
				if err := s.StartMinusAfter.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start-after\"")
			}
		case "start-at":
			if err := func() error {
				s.StartMinusAt.Reset()
				if err := s.StartMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start-at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaasServiceUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaasServiceUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasServiceUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasUserPassword as json.
func (s DbaasUserPassword) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DbaasUserPassword from json.
func (s *DbaasUserPassword) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasUserPassword to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DbaasUserPassword(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasUserPassword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasUserPassword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasUserUsername as json.
func (s DbaasUserUsername) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DbaasUserUsername from json.
func (s *DbaasUserUsername) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaasUserUsername to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DbaasUserUsername(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaasUserUsername) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaasUserUsername) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeployTarget) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeployTarget) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeployTarget = [4]string{
	0: "id",
	1: "name",
	2: "type",
	3: "description",
}

// Decode decodes DeployTarget from json.
func (s *DeployTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployTarget to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeployTarget")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeployTarget) {
					name = jsonFieldsNameOfDeployTarget[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeployTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeployTargetType as json.
func (s DeployTargetType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DeployTargetType from json.
func (s *DeployTargetType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeployTargetType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DeployTargetType(v) {
	case DeployTargetTypeEdge:
		*s = DeployTargetTypeEdge
	case DeployTargetTypeDedicated:
		*s = DeployTargetTypeDedicated
	default:
		*s = DeployTargetType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DeployTargetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeployTargetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainName as json.
func (s DomainName) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes DomainName from json.
func (s *DomainName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainName to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DomainName(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DomainName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ElasticIP) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ElasticIP) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.IP.Set {
			e.FieldStart("ip")
			s.IP.Encode(e)
		}
	}
	{
		if s.Addressfamily.Set {
			e.FieldStart("addressfamily")
			s.Addressfamily.Encode(e)
		}
	}
	{
		if s.Cidr.Set {
			e.FieldStart("cidr")
			s.Cidr.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Healthcheck.Set {
			e.FieldStart("healthcheck")
			s.Healthcheck.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfElasticIP = [7]string{
	0: "id",
	1: "ip",
	2: "addressfamily",
	3: "cidr",
	4: "description",
	5: "healthcheck",
	6: "labels",
}

// Decode decodes ElasticIP from json.
func (s *ElasticIP) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ElasticIP to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "ip":
			if err := func() error {
				s.IP.Reset()
				if err := s.IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		case "addressfamily":
			if err := func() error {
				s.Addressfamily.Reset()
				if err := s.Addressfamily.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressfamily\"")
			}
		case "cidr":
			if err := func() error {
				s.Cidr.Reset()
				if err := s.Cidr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cidr\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "healthcheck":
			if err := func() error {
				s.Healthcheck.Reset()
				if err := s.Healthcheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthcheck\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ElasticIP")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ElasticIP) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ElasticIP) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ElasticIPAddressfamily as json.
func (s ElasticIPAddressfamily) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ElasticIPAddressfamily from json.
func (s *ElasticIPAddressfamily) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ElasticIPAddressfamily to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ElasticIPAddressfamily(v) {
	case ElasticIPAddressfamilyInet4:
		*s = ElasticIPAddressfamilyInet4
	case ElasticIPAddressfamilyInet6:
		*s = ElasticIPAddressfamilyInet6
	default:
		*s = ElasticIPAddressfamily(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ElasticIPAddressfamily) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ElasticIPAddressfamily) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ElasticIPHealthcheck) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ElasticIPHealthcheck) encodeFields(e *jx.Encoder) {
	{
		if s.StrikesMinusOk.Set {
			e.FieldStart("strikes-ok")
			s.StrikesMinusOk.Encode(e)
		}
	}
	{
		if s.TLSMinusSkipMinusVerify.Set {
			e.FieldStart("tls-skip-verify")
			s.TLSMinusSkipMinusVerify.Encode(e)
		}
	}
	{
		if s.TLSMinusSni.Set {
			e.FieldStart("tls-sni")
			s.TLSMinusSni.Encode(e)
		}
	}
	{
		if s.StrikesMinusFail.Set {
			e.FieldStart("strikes-fail")
			s.StrikesMinusFail.Encode(e)
		}
	}
	{
		e.FieldStart("mode")
		s.Mode.Encode(e)
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.Interval.Set {
			e.FieldStart("interval")
			s.Interval.Encode(e)
		}
	}
	{
		if s.Timeout.Set {
			e.FieldStart("timeout")
			s.Timeout.Encode(e)
		}
	}
}

var jsonFieldsNameOfElasticIPHealthcheck = [9]string{
	0: "strikes-ok",
	1: "tls-skip-verify",
	2: "tls-sni",
	3: "strikes-fail",
	4: "mode",
	5: "port",
	6: "uri",
	7: "interval",
	8: "timeout",
}

// Decode decodes ElasticIPHealthcheck from json.
func (s *ElasticIPHealthcheck) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ElasticIPHealthcheck to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "strikes-ok":
			if err := func() error {
				s.StrikesMinusOk.Reset()
				if err := s.StrikesMinusOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strikes-ok\"")
			}
		case "tls-skip-verify":
			if err := func() error {
				s.TLSMinusSkipMinusVerify.Reset()
				if err := s.TLSMinusSkipMinusVerify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tls-skip-verify\"")
			}
		case "tls-sni":
			if err := func() error {
				s.TLSMinusSni.Reset()
				if err := s.TLSMinusSni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tls-sni\"")
			}
		case "strikes-fail":
			if err := func() error {
				s.StrikesMinusFail.Reset()
				if err := s.StrikesMinusFail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strikes-fail\"")
			}
		case "mode":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "interval":
			if err := func() error {
				s.Interval.Reset()
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval\"")
			}
		case "timeout":
			if err := func() error {
				s.Timeout.Reset()
				if err := s.Timeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ElasticIPHealthcheck")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00110000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfElasticIPHealthcheck) {
					name = jsonFieldsNameOfElasticIPHealthcheck[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ElasticIPHealthcheck) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ElasticIPHealthcheck) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ElasticIPHealthcheckMode as json.
func (s ElasticIPHealthcheckMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ElasticIPHealthcheckMode from json.
func (s *ElasticIPHealthcheckMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ElasticIPHealthcheckMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ElasticIPHealthcheckMode(v) {
	case ElasticIPHealthcheckModeTCP:
		*s = ElasticIPHealthcheckModeTCP
	case ElasticIPHealthcheckModeHTTP:
		*s = ElasticIPHealthcheckModeHTTP
	case ElasticIPHealthcheckModeHTTPS:
		*s = ElasticIPHealthcheckModeHTTPS
	default:
		*s = ElasticIPHealthcheckMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ElasticIPHealthcheckMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ElasticIPHealthcheckMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumComponentRoute as json.
func (s EnumComponentRoute) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumComponentRoute from json.
func (s *EnumComponentRoute) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumComponentRoute to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumComponentRoute(v) {
	case EnumComponentRouteDynamic:
		*s = EnumComponentRouteDynamic
	case EnumComponentRoutePrivate:
		*s = EnumComponentRoutePrivate
	case EnumComponentRoutePublic:
		*s = EnumComponentRoutePublic
	case EnumComponentRoutePrivatelink:
		*s = EnumComponentRoutePrivatelink
	default:
		*s = EnumComponentRoute(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumComponentRoute) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumComponentRoute) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumComponentUsage as json.
func (s EnumComponentUsage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumComponentUsage from json.
func (s *EnumComponentUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumComponentUsage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumComponentUsage(v) {
	case EnumComponentUsagePrimary:
		*s = EnumComponentUsagePrimary
	case EnumComponentUsageReplica:
		*s = EnumComponentUsageReplica
	default:
		*s = EnumComponentUsage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumComponentUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumComponentUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumIntegrationTypes as json.
func (s EnumIntegrationTypes) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumIntegrationTypes from json.
func (s *EnumIntegrationTypes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumIntegrationTypes to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumIntegrationTypes(v) {
	case EnumIntegrationTypesDatasource:
		*s = EnumIntegrationTypesDatasource
	case EnumIntegrationTypesReadReplica:
		*s = EnumIntegrationTypesReadReplica
	case EnumIntegrationTypesMetrics:
		*s = EnumIntegrationTypesMetrics
	default:
		*s = EnumIntegrationTypes(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumIntegrationTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumIntegrationTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumKafkaAuthMethod as json.
func (s EnumKafkaAuthMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumKafkaAuthMethod from json.
func (s *EnumKafkaAuthMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumKafkaAuthMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumKafkaAuthMethod(v) {
	case EnumKafkaAuthMethodCertificate:
		*s = EnumKafkaAuthMethodCertificate
	case EnumKafkaAuthMethodSasl:
		*s = EnumKafkaAuthMethodSasl
	default:
		*s = EnumKafkaAuthMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumKafkaAuthMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumKafkaAuthMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumMasterLinkStatus as json.
func (s EnumMasterLinkStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumMasterLinkStatus from json.
func (s *EnumMasterLinkStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumMasterLinkStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumMasterLinkStatus(v) {
	case EnumMasterLinkStatusUp:
		*s = EnumMasterLinkStatusUp
	case EnumMasterLinkStatusDown:
		*s = EnumMasterLinkStatusDown
	default:
		*s = EnumMasterLinkStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumMasterLinkStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumMasterLinkStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumMigrationMethod as json.
func (s EnumMigrationMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumMigrationMethod from json.
func (s *EnumMigrationMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumMigrationMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumMigrationMethod(v) {
	case EnumMigrationMethodDump:
		*s = EnumMigrationMethodDump
	case EnumMigrationMethodReplication:
		*s = EnumMigrationMethodReplication
	default:
		*s = EnumMigrationMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumMigrationMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumMigrationMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumMigrationStatus as json.
func (s EnumMigrationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumMigrationStatus from json.
func (s *EnumMigrationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumMigrationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumMigrationStatus(v) {
	case EnumMigrationStatusRunning:
		*s = EnumMigrationStatusRunning
	case EnumMigrationStatusSyncing:
		*s = EnumMigrationStatusSyncing
	case EnumMigrationStatusFailed:
		*s = EnumMigrationStatusFailed
	case EnumMigrationStatusDone:
		*s = EnumMigrationStatusDone
	default:
		*s = EnumMigrationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumMigrationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumMigrationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumPgPoolMode as json.
func (s EnumPgPoolMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumPgPoolMode from json.
func (s *EnumPgPoolMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumPgPoolMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumPgPoolMode(v) {
	case EnumPgPoolModeTransaction:
		*s = EnumPgPoolModeTransaction
	case EnumPgPoolModeStatement:
		*s = EnumPgPoolModeStatement
	case EnumPgPoolModeSession:
		*s = EnumPgPoolModeSession
	default:
		*s = EnumPgPoolMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumPgPoolMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumPgPoolMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumPgSynchronousReplication as json.
func (s EnumPgSynchronousReplication) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumPgSynchronousReplication from json.
func (s *EnumPgSynchronousReplication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumPgSynchronousReplication to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumPgSynchronousReplication(v) {
	case EnumPgSynchronousReplicationQuorum:
		*s = EnumPgSynchronousReplicationQuorum
	case EnumPgSynchronousReplicationOff:
		*s = EnumPgSynchronousReplicationOff
	default:
		*s = EnumPgSynchronousReplication(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumPgSynchronousReplication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumPgSynchronousReplication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumPgVariant as json.
func (s EnumPgVariant) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumPgVariant from json.
func (s *EnumPgVariant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumPgVariant to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumPgVariant(v) {
	case EnumPgVariantTimescale:
		*s = EnumPgVariantTimescale
	case EnumPgVariantAiven:
		*s = EnumPgVariantAiven
	default:
		*s = EnumPgVariant(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumPgVariant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumPgVariant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumServiceState as json.
func (s EnumServiceState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumServiceState from json.
func (s *EnumServiceState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumServiceState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumServiceState(v) {
	case EnumServiceStateRunning:
		*s = EnumServiceStateRunning
	case EnumServiceStateRebuilding:
		*s = EnumServiceStateRebuilding
	case EnumServiceStateRebalancing:
		*s = EnumServiceStateRebalancing
	case EnumServiceStatePoweroff:
		*s = EnumServiceStatePoweroff
	default:
		*s = EnumServiceState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumServiceState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumServiceState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumSortOrder as json.
func (s EnumSortOrder) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnumSortOrder from json.
func (s *EnumSortOrder) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumSortOrder to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnumSortOrder(v) {
	case EnumSortOrderDesc:
		*s = EnumSortOrderDesc
	case EnumSortOrderAsc:
		*s = EnumSortOrderAsc
	default:
		*s = EnumSortOrder(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumSortOrder) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumSortOrder) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Event) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Event) encodeFields(e *jx.Encoder) {
	{
		if s.RequestMinusID.Set {
			e.FieldStart("request-id")
			s.RequestMinusID.Encode(e)
		}
	}
	{
		if s.Zone.Set {
			e.FieldStart("zone")
			s.Zone.Encode(e)
		}
	}
	{
		if s.RemoteMinusAddr.Set {
			e.FieldStart("remote-addr")
			s.RemoteMinusAddr.Encode(e)
		}
	}
	{
		if s.GetMinusParams != nil {
			e.FieldStart("get-params")
			s.GetMinusParams.Encode(e)
		}
	}
	{
		if s.BodyMinusParams != nil {
			e.FieldStart("body-params")
			s.BodyMinusParams.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.ElapsedMinusMs.Set {
			e.FieldStart("elapsed-ms")
			s.ElapsedMinusMs.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.PathMinusParams != nil {
			e.FieldStart("path-params")
			s.PathMinusParams.Encode(e)
		}
	}
	{
		if s.Handler.Set {
			e.FieldStart("handler")
			s.Handler.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfEvent = [12]string{
	0:  "request-id",
	1:  "zone",
	2:  "remote-addr",
	3:  "get-params",
	4:  "body-params",
	5:  "status",
	6:  "uri",
	7:  "elapsed-ms",
	8:  "timestamp",
	9:  "path-params",
	10: "handler",
	11: "message",
}

// Decode decodes Event from json.
func (s *Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Event to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "request-id":
			if err := func() error {
				s.RequestMinusID.Reset()
				if err := s.RequestMinusID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request-id\"")
			}
		case "zone":
			if err := func() error {
				s.Zone.Reset()
				if err := s.Zone.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone\"")
			}
		case "remote-addr":
			if err := func() error {
				s.RemoteMinusAddr.Reset()
				if err := s.RemoteMinusAddr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remote-addr\"")
			}
		case "get-params":
			if err := func() error {
				s.GetMinusParams = nil
				var elem EventGetMinusParams
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.GetMinusParams = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"get-params\"")
			}
		case "body-params":
			if err := func() error {
				s.BodyMinusParams = nil
				var elem EventBodyMinusParams
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.BodyMinusParams = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body-params\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "elapsed-ms":
			if err := func() error {
				s.ElapsedMinusMs.Reset()
				if err := s.ElapsedMinusMs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elapsed-ms\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path-params":
			if err := func() error {
				s.PathMinusParams = nil
				var elem EventPathMinusParams
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PathMinusParams = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path-params\"")
			}
		case "handler":
			if err := func() error {
				s.Handler.Reset()
				if err := s.Handler.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handler\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Event")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Event) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Event) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventBodyMinusParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventBodyMinusParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventBodyMinusParams = [0]string{}

// Decode decodes EventBodyMinusParams from json.
func (s *EventBodyMinusParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventBodyMinusParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventBodyMinusParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventBodyMinusParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventBodyMinusParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventGetMinusParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventGetMinusParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventGetMinusParams = [0]string{}

// Decode decodes EventGetMinusParams from json.
func (s *EventGetMinusParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventGetMinusParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventGetMinusParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventGetMinusParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventGetMinusParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EventPathMinusParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EventPathMinusParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfEventPathMinusParams = [0]string{}

// Decode decodes EventPathMinusParams from json.
func (s *EventPathMinusParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventPathMinusParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventPathMinusParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EventPathMinusParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventPathMinusParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EvictInstancePoolMembersReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EvictInstancePoolMembersReq) encodeFields(e *jx.Encoder) {
	{
		if s.Instances != nil {
			e.FieldStart("instances")
			e.ArrStart()
			for _, elem := range s.Instances {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEvictInstancePoolMembersReq = [1]string{
	0: "instances",
}

// Decode decodes EvictInstancePoolMembersReq from json.
func (s *EvictInstancePoolMembersReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvictInstancePoolMembersReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instances":
			if err := func() error {
				s.Instances = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Instances = append(s.Instances, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instances\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EvictInstancePoolMembersReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvictInstancePoolMembersReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvictInstancePoolMembersReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EvictSksNodepoolMembersReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EvictSksNodepoolMembersReq) encodeFields(e *jx.Encoder) {
	{
		if s.Instances != nil {
			e.FieldStart("instances")
			e.ArrStart()
			for _, elem := range s.Instances {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEvictSksNodepoolMembersReq = [1]string{
	0: "instances",
}

// Decode decodes EvictSksNodepoolMembersReq from json.
func (s *EvictSksNodepoolMembersReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvictSksNodepoolMembersReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instances":
			if err := func() error {
				s.Instances = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Instances = append(s.Instances, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instances\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EvictSksNodepoolMembersReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvictSksNodepoolMembersReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvictSksNodepoolMembersReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateSksClusterKubeconfigOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateSksClusterKubeconfigOK) encodeFields(e *jx.Encoder) {
	{
		if s.Kubeconfig.Set {
			e.FieldStart("kubeconfig")
			s.Kubeconfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfGenerateSksClusterKubeconfigOK = [1]string{
	0: "kubeconfig",
}

// Decode decodes GenerateSksClusterKubeconfigOK from json.
func (s *GenerateSksClusterKubeconfigOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateSksClusterKubeconfigOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kubeconfig":
			if err := func() error {
				s.Kubeconfig.Reset()
				if err := s.Kubeconfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubeconfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateSksClusterKubeconfigOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateSksClusterKubeconfigOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateSksClusterKubeconfigOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDNSDomainZoneFileOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDNSDomainZoneFileOK) encodeFields(e *jx.Encoder) {
	{
		if s.ZoneMinusFile.Set {
			e.FieldStart("zone-file")
			s.ZoneMinusFile.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDNSDomainZoneFileOK = [1]string{
	0: "zone-file",
}

// Decode decodes GetDNSDomainZoneFileOK from json.
func (s *GetDNSDomainZoneFileOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDNSDomainZoneFileOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "zone-file":
			if err := func() error {
				s.ZoneMinusFile.Reset()
				if err := s.ZoneMinusFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone-file\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDNSDomainZoneFileOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDNSDomainZoneFileOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDNSDomainZoneFileOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasCaCertificateOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasCaCertificateOK) encodeFields(e *jx.Encoder) {
	{
		if s.Certificate.Set {
			e.FieldStart("certificate")
			s.Certificate.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasCaCertificateOK = [1]string{
	0: "certificate",
}

// Decode decodes GetDbaasCaCertificateOK from json.
func (s *GetDbaasCaCertificateOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasCaCertificateOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificate":
			if err := func() error {
				s.Certificate.Reset()
				if err := s.Certificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasCaCertificateOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasCaCertificateOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasCaCertificateOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasServiceLogsReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasServiceLogsReq) encodeFields(e *jx.Encoder) {
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
	{
		if s.SortMinusOrder.Set {
			e.FieldStart("sort-order")
			s.SortMinusOrder.Encode(e)
		}
	}
	{
		if s.Offset.Set {
			e.FieldStart("offset")
			s.Offset.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasServiceLogsReq = [3]string{
	0: "limit",
	1: "sort-order",
	2: "offset",
}

// Decode decodes GetDbaasServiceLogsReq from json.
func (s *GetDbaasServiceLogsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasServiceLogsReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "sort-order":
			if err := func() error {
				s.SortMinusOrder.Reset()
				if err := s.SortMinusOrder.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sort-order\"")
			}
		case "offset":
			if err := func() error {
				s.Offset.Reset()
				if err := s.Offset.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasServiceLogsReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasServiceLogsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasServiceLogsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasServiceMetricsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasServiceMetricsOK) encodeFields(e *jx.Encoder) {
	{
		if s.Metrics != nil {
			e.FieldStart("metrics")
			s.Metrics.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasServiceMetricsOK = [1]string{
	0: "metrics",
}

// Decode decodes GetDbaasServiceMetricsOK from json.
func (s *GetDbaasServiceMetricsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasServiceMetricsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "metrics":
			if err := func() error {
				s.Metrics = nil
				var elem GetDbaasServiceMetricsOKMetrics
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Metrics = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"metrics\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasServiceMetricsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasServiceMetricsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasServiceMetricsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasServiceMetricsOKMetrics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasServiceMetricsOKMetrics) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasServiceMetricsOKMetrics = [0]string{}

// Decode decodes GetDbaasServiceMetricsOKMetrics from json.
func (s *GetDbaasServiceMetricsOKMetrics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasServiceMetricsOKMetrics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasServiceMetricsOKMetrics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasServiceMetricsOKMetrics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasServiceMetricsOKMetrics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasServiceMetricsReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasServiceMetricsReq) encodeFields(e *jx.Encoder) {
	{
		if s.Period.Set {
			e.FieldStart("period")
			s.Period.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasServiceMetricsReq = [1]string{
	0: "period",
}

// Decode decodes GetDbaasServiceMetricsReq from json.
func (s *GetDbaasServiceMetricsReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasServiceMetricsReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "period":
			if err := func() error {
				s.Period.Reset()
				if err := s.Period.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"period\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasServiceMetricsReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasServiceMetricsReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasServiceMetricsReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasServiceMetricsReqPeriod as json.
func (s GetDbaasServiceMetricsReqPeriod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetDbaasServiceMetricsReqPeriod from json.
func (s *GetDbaasServiceMetricsReqPeriod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasServiceMetricsReqPeriod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetDbaasServiceMetricsReqPeriod(v) {
	case GetDbaasServiceMetricsReqPeriodHour:
		*s = GetDbaasServiceMetricsReqPeriodHour
	case GetDbaasServiceMetricsReqPeriodWeek:
		*s = GetDbaasServiceMetricsReqPeriodWeek
	case GetDbaasServiceMetricsReqPeriodYear:
		*s = GetDbaasServiceMetricsReqPeriodYear
	case GetDbaasServiceMetricsReqPeriodMonth:
		*s = GetDbaasServiceMetricsReqPeriodMonth
	case GetDbaasServiceMetricsReqPeriodDay:
		*s = GetDbaasServiceMetricsReqPeriodDay
	default:
		*s = GetDbaasServiceMetricsReqPeriod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetDbaasServiceMetricsReqPeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasServiceMetricsReqPeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsKafkaOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsKafkaOK) encodeFields(e *jx.Encoder) {
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsKafkaOK = [1]string{
	0: "settings",
}

// Decode decodes GetDbaasSettingsKafkaOK from json.
func (s *GetDbaasSettingsKafkaOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsKafkaOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsKafkaOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsKafkaOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsKafkaOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsKafkaOKSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Kafka.Set {
			e.FieldStart("kafka")
			s.Kafka.Encode(e)
		}
	}
	{
		if s.KafkaMinusConnect.Set {
			e.FieldStart("kafka-connect")
			s.KafkaMinusConnect.Encode(e)
		}
	}
	{
		if s.KafkaMinusRest.Set {
			e.FieldStart("kafka-rest")
			s.KafkaMinusRest.Encode(e)
		}
	}
	{
		if s.SchemaMinusRegistry.Set {
			e.FieldStart("schema-registry")
			s.SchemaMinusRegistry.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsKafkaOKSettings = [4]string{
	0: "kafka",
	1: "kafka-connect",
	2: "kafka-rest",
	3: "schema-registry",
}

// Decode decodes GetDbaasSettingsKafkaOKSettings from json.
func (s *GetDbaasSettingsKafkaOKSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsKafkaOKSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kafka":
			if err := func() error {
				s.Kafka.Reset()
				if err := s.Kafka.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka\"")
			}
		case "kafka-connect":
			if err := func() error {
				s.KafkaMinusConnect.Reset()
				if err := s.KafkaMinusConnect.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-connect\"")
			}
		case "kafka-rest":
			if err := func() error {
				s.KafkaMinusRest.Reset()
				if err := s.KafkaMinusRest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-rest\"")
			}
		case "schema-registry":
			if err := func() error {
				s.SchemaMinusRegistry.Reset()
				if err := s.SchemaMinusRegistry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema-registry\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsKafkaOKSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsKafkaOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafka) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsKafkaOKSettingsKafka) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsKafkaOKSettingsKafka = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes GetDbaasSettingsKafkaOKSettingsKafka from json.
func (s *GetDbaasSettingsKafkaOKSettingsKafka) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsKafkaOKSettingsKafka to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem GetDbaasSettingsKafkaOKSettingsKafkaProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsKafkaOKSettingsKafka")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafka) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafka) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusConnect) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusConnect) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsKafkaOKSettingsKafkaMinusConnect = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes GetDbaasSettingsKafkaOKSettingsKafkaMinusConnect from json.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusConnect) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsKafkaOKSettingsKafkaMinusConnect to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem GetDbaasSettingsKafkaOKSettingsKafkaMinusConnectProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsKafkaOKSettingsKafkaMinusConnect")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusConnect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusConnect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusConnectProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusConnectProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasSettingsKafkaOKSettingsKafkaMinusConnectProperties = [0]string{}

// Decode decodes GetDbaasSettingsKafkaOKSettingsKafkaMinusConnectProperties from json.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusConnectProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsKafkaOKSettingsKafkaMinusConnectProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsKafkaOKSettingsKafkaMinusConnectProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusConnectProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusConnectProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusRest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusRest) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsKafkaOKSettingsKafkaMinusRest = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes GetDbaasSettingsKafkaOKSettingsKafkaMinusRest from json.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusRest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsKafkaOKSettingsKafkaMinusRest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem GetDbaasSettingsKafkaOKSettingsKafkaMinusRestProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsKafkaOKSettingsKafkaMinusRest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusRest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusRest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusRestProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusRestProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasSettingsKafkaOKSettingsKafkaMinusRestProperties = [0]string{}

// Decode decodes GetDbaasSettingsKafkaOKSettingsKafkaMinusRestProperties from json.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusRestProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsKafkaOKSettingsKafkaMinusRestProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsKafkaOKSettingsKafkaMinusRestProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusRestProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaMinusRestProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasSettingsKafkaOKSettingsKafkaProperties = [0]string{}

// Decode decodes GetDbaasSettingsKafkaOKSettingsKafkaProperties from json.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsKafkaOKSettingsKafkaProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsKafkaOKSettingsKafkaProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsKafkaOKSettingsKafkaProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry from json.
func (s *GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistryProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistryProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistryProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasSettingsKafkaOKSettingsSchemaMinusRegistryProperties = [0]string{}

// Decode decodes GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistryProperties from json.
func (s *GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistryProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistryProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistryProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistryProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistryProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsMysqlOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsMysqlOK) encodeFields(e *jx.Encoder) {
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsMysqlOK = [1]string{
	0: "settings",
}

// Decode decodes GetDbaasSettingsMysqlOK from json.
func (s *GetDbaasSettingsMysqlOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsMysqlOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsMysqlOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsMysqlOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsMysqlOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsMysqlOKSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsMysqlOKSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Mysql.Set {
			e.FieldStart("mysql")
			s.Mysql.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsMysqlOKSettings = [1]string{
	0: "mysql",
}

// Decode decodes GetDbaasSettingsMysqlOKSettings from json.
func (s *GetDbaasSettingsMysqlOKSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsMysqlOKSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mysql":
			if err := func() error {
				s.Mysql.Reset()
				if err := s.Mysql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mysql\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsMysqlOKSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsMysqlOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsMysqlOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsMysqlOKSettingsMysql) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsMysqlOKSettingsMysql) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsMysqlOKSettingsMysql = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes GetDbaasSettingsMysqlOKSettingsMysql from json.
func (s *GetDbaasSettingsMysqlOKSettingsMysql) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsMysqlOKSettingsMysql to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem GetDbaasSettingsMysqlOKSettingsMysqlProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsMysqlOKSettingsMysql")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsMysqlOKSettingsMysql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsMysqlOKSettingsMysql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsMysqlOKSettingsMysqlProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsMysqlOKSettingsMysqlProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasSettingsMysqlOKSettingsMysqlProperties = [0]string{}

// Decode decodes GetDbaasSettingsMysqlOKSettingsMysqlProperties from json.
func (s *GetDbaasSettingsMysqlOKSettingsMysqlProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsMysqlOKSettingsMysqlProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsMysqlOKSettingsMysqlProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsMysqlOKSettingsMysqlProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsMysqlOKSettingsMysqlProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsOpensearchOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsOpensearchOK) encodeFields(e *jx.Encoder) {
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsOpensearchOK = [1]string{
	0: "settings",
}

// Decode decodes GetDbaasSettingsOpensearchOK from json.
func (s *GetDbaasSettingsOpensearchOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsOpensearchOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsOpensearchOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsOpensearchOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsOpensearchOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsOpensearchOKSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsOpensearchOKSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Opensearch.Set {
			e.FieldStart("opensearch")
			s.Opensearch.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsOpensearchOKSettings = [1]string{
	0: "opensearch",
}

// Decode decodes GetDbaasSettingsOpensearchOKSettings from json.
func (s *GetDbaasSettingsOpensearchOKSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsOpensearchOKSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "opensearch":
			if err := func() error {
				s.Opensearch.Reset()
				if err := s.Opensearch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opensearch\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsOpensearchOKSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsOpensearchOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsOpensearchOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsOpensearchOKSettingsOpensearch) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsOpensearchOKSettingsOpensearch) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsOpensearchOKSettingsOpensearch = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes GetDbaasSettingsOpensearchOKSettingsOpensearch from json.
func (s *GetDbaasSettingsOpensearchOKSettingsOpensearch) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsOpensearchOKSettingsOpensearch to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem GetDbaasSettingsOpensearchOKSettingsOpensearchProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsOpensearchOKSettingsOpensearch")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsOpensearchOKSettingsOpensearch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsOpensearchOKSettingsOpensearch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsOpensearchOKSettingsOpensearchProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsOpensearchOKSettingsOpensearchProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasSettingsOpensearchOKSettingsOpensearchProperties = [0]string{}

// Decode decodes GetDbaasSettingsOpensearchOKSettingsOpensearchProperties from json.
func (s *GetDbaasSettingsOpensearchOKSettingsOpensearchProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsOpensearchOKSettingsOpensearchProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsOpensearchOKSettingsOpensearchProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsOpensearchOKSettingsOpensearchProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsOpensearchOKSettingsOpensearchProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsPgOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsPgOK) encodeFields(e *jx.Encoder) {
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsPgOK = [1]string{
	0: "settings",
}

// Decode decodes GetDbaasSettingsPgOK from json.
func (s *GetDbaasSettingsPgOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsPgOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsPgOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsPgOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsPgOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsPgOKSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsPgOKSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Pg.Set {
			e.FieldStart("pg")
			s.Pg.Encode(e)
		}
	}
	{
		if s.Pglookout.Set {
			e.FieldStart("pglookout")
			s.Pglookout.Encode(e)
		}
	}
	{
		if s.Pgbouncer.Set {
			e.FieldStart("pgbouncer")
			s.Pgbouncer.Encode(e)
		}
	}
	{
		if s.Timescaledb.Set {
			e.FieldStart("timescaledb")
			s.Timescaledb.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsPgOKSettings = [4]string{
	0: "pg",
	1: "pglookout",
	2: "pgbouncer",
	3: "timescaledb",
}

// Decode decodes GetDbaasSettingsPgOKSettings from json.
func (s *GetDbaasSettingsPgOKSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsPgOKSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pg":
			if err := func() error {
				s.Pg.Reset()
				if err := s.Pg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pg\"")
			}
		case "pglookout":
			if err := func() error {
				s.Pglookout.Reset()
				if err := s.Pglookout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pglookout\"")
			}
		case "pgbouncer":
			if err := func() error {
				s.Pgbouncer.Reset()
				if err := s.Pgbouncer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pgbouncer\"")
			}
		case "timescaledb":
			if err := func() error {
				s.Timescaledb.Reset()
				if err := s.Timescaledb.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timescaledb\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsPgOKSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsPgOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsPgOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPg) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsPgOKSettingsPg) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsPgOKSettingsPg = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes GetDbaasSettingsPgOKSettingsPg from json.
func (s *GetDbaasSettingsPgOKSettingsPg) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsPgOKSettingsPg to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem GetDbaasSettingsPgOKSettingsPgProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsPgOKSettingsPg")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPg) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsPgOKSettingsPg) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPgProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsPgOKSettingsPgProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasSettingsPgOKSettingsPgProperties = [0]string{}

// Decode decodes GetDbaasSettingsPgOKSettingsPgProperties from json.
func (s *GetDbaasSettingsPgOKSettingsPgProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsPgOKSettingsPgProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsPgOKSettingsPgProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPgProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsPgOKSettingsPgProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPgbouncer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsPgOKSettingsPgbouncer) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsPgOKSettingsPgbouncer = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes GetDbaasSettingsPgOKSettingsPgbouncer from json.
func (s *GetDbaasSettingsPgOKSettingsPgbouncer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsPgOKSettingsPgbouncer to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem GetDbaasSettingsPgOKSettingsPgbouncerProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsPgOKSettingsPgbouncer")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPgbouncer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsPgOKSettingsPgbouncer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPgbouncerProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsPgOKSettingsPgbouncerProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasSettingsPgOKSettingsPgbouncerProperties = [0]string{}

// Decode decodes GetDbaasSettingsPgOKSettingsPgbouncerProperties from json.
func (s *GetDbaasSettingsPgOKSettingsPgbouncerProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsPgOKSettingsPgbouncerProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsPgOKSettingsPgbouncerProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPgbouncerProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsPgOKSettingsPgbouncerProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPglookout) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsPgOKSettingsPglookout) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsPgOKSettingsPglookout = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes GetDbaasSettingsPgOKSettingsPglookout from json.
func (s *GetDbaasSettingsPgOKSettingsPglookout) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsPgOKSettingsPglookout to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem GetDbaasSettingsPgOKSettingsPglookoutProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsPgOKSettingsPglookout")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPglookout) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsPgOKSettingsPglookout) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPglookoutProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsPgOKSettingsPglookoutProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasSettingsPgOKSettingsPglookoutProperties = [0]string{}

// Decode decodes GetDbaasSettingsPgOKSettingsPglookoutProperties from json.
func (s *GetDbaasSettingsPgOKSettingsPglookoutProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsPgOKSettingsPglookoutProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsPgOKSettingsPglookoutProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsPglookoutProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsPgOKSettingsPglookoutProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsTimescaledb) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsPgOKSettingsTimescaledb) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsPgOKSettingsTimescaledb = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes GetDbaasSettingsPgOKSettingsTimescaledb from json.
func (s *GetDbaasSettingsPgOKSettingsTimescaledb) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsPgOKSettingsTimescaledb to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem GetDbaasSettingsPgOKSettingsTimescaledbProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsPgOKSettingsTimescaledb")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsTimescaledb) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsPgOKSettingsTimescaledb) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsTimescaledbProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsPgOKSettingsTimescaledbProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasSettingsPgOKSettingsTimescaledbProperties = [0]string{}

// Decode decodes GetDbaasSettingsPgOKSettingsTimescaledbProperties from json.
func (s *GetDbaasSettingsPgOKSettingsTimescaledbProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsPgOKSettingsTimescaledbProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsPgOKSettingsTimescaledbProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsPgOKSettingsTimescaledbProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsPgOKSettingsTimescaledbProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsRedisOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsRedisOK) encodeFields(e *jx.Encoder) {
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsRedisOK = [1]string{
	0: "settings",
}

// Decode decodes GetDbaasSettingsRedisOK from json.
func (s *GetDbaasSettingsRedisOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsRedisOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsRedisOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsRedisOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsRedisOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsRedisOKSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsRedisOKSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Redis.Set {
			e.FieldStart("redis")
			s.Redis.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsRedisOKSettings = [1]string{
	0: "redis",
}

// Decode decodes GetDbaasSettingsRedisOKSettings from json.
func (s *GetDbaasSettingsRedisOKSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsRedisOKSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "redis":
			if err := func() error {
				s.Redis.Reset()
				if err := s.Redis.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redis\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsRedisOKSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsRedisOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsRedisOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsRedisOKSettingsRedis) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsRedisOKSettingsRedis) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasSettingsRedisOKSettingsRedis = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes GetDbaasSettingsRedisOKSettingsRedis from json.
func (s *GetDbaasSettingsRedisOKSettingsRedis) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsRedisOKSettingsRedis to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem GetDbaasSettingsRedisOKSettingsRedisProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsRedisOKSettingsRedis")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsRedisOKSettingsRedis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsRedisOKSettingsRedis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasSettingsRedisOKSettingsRedisProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasSettingsRedisOKSettingsRedisProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetDbaasSettingsRedisOKSettingsRedisProperties = [0]string{}

// Decode decodes GetDbaasSettingsRedisOKSettingsRedisProperties from json.
func (s *GetDbaasSettingsRedisOKSettingsRedisProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasSettingsRedisOKSettingsRedisProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasSettingsRedisOKSettingsRedisProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasSettingsRedisOKSettingsRedisProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasSettingsRedisOKSettingsRedisProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasTaskOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasTaskOK) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreateMinusTime.Set {
			e.FieldStart("create-time")
			s.CreateMinusTime.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Result.Set {
			e.FieldStart("result")
			s.Result.Encode(e)
		}
	}
	{
		if s.ResultMinusCodes != nil {
			e.FieldStart("result-codes")
			e.ArrStart()
			for _, elem := range s.ResultMinusCodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Success.Set {
			e.FieldStart("success")
			s.Success.Encode(e)
		}
	}
	{
		if s.TaskMinusType.Set {
			e.FieldStart("task-type")
			s.TaskMinusType.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasTaskOK = [6]string{
	0: "id",
	1: "create-time",
	2: "result",
	3: "result-codes",
	4: "success",
	5: "task-type",
}

// Decode decodes GetDbaasTaskOK from json.
func (s *GetDbaasTaskOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasTaskOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "create-time":
			if err := func() error {
				s.CreateMinusTime.Reset()
				if err := s.CreateMinusTime.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"create-time\"")
			}
		case "result":
			if err := func() error {
				s.Result.Reset()
				if err := s.Result.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result\"")
			}
		case "result-codes":
			if err := func() error {
				s.ResultMinusCodes = make([]GetDbaasTaskOKResultMinusCodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetDbaasTaskOKResultMinusCodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ResultMinusCodes = append(s.ResultMinusCodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"result-codes\"")
			}
		case "success":
			if err := func() error {
				s.Success.Reset()
				if err := s.Success.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"success\"")
			}
		case "task-type":
			if err := func() error {
				s.TaskMinusType.Reset()
				if err := s.TaskMinusType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"task-type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasTaskOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasTaskOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasTaskOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDbaasTaskOKResultMinusCodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDbaasTaskOKResultMinusCodesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Dbname.Set {
			e.FieldStart("dbname")
			s.Dbname.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetDbaasTaskOKResultMinusCodesItem = [2]string{
	0: "code",
	1: "dbname",
}

// Decode decodes GetDbaasTaskOKResultMinusCodesItem from json.
func (s *GetDbaasTaskOKResultMinusCodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDbaasTaskOKResultMinusCodesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "dbname":
			if err := func() error {
				s.Dbname.Reset()
				if err := s.Dbname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbname\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDbaasTaskOKResultMinusCodesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDbaasTaskOKResultMinusCodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDbaasTaskOKResultMinusCodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSksClusterAuthorityCertOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSksClusterAuthorityCertOK) encodeFields(e *jx.Encoder) {
	{
		if s.Cacert.Set {
			e.FieldStart("cacert")
			s.Cacert.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetSksClusterAuthorityCertOK = [1]string{
	0: "cacert",
}

// Decode decodes GetSksClusterAuthorityCertOK from json.
func (s *GetSksClusterAuthorityCertOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSksClusterAuthorityCertOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cacert":
			if err := func() error {
				s.Cacert.Reset()
				if err := s.Cacert.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cacert\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSksClusterAuthorityCertOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSksClusterAuthorityCertOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSksClusterAuthorityCertOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSosPresignedURLOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSosPresignedURLOK) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetSosPresignedURLOK = [1]string{
	0: "url",
}

// Decode decodes GetSosPresignedURLOK from json.
func (s *GetSosPresignedURLOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSosPresignedURLOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSosPresignedURLOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSosPresignedURLOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSosPresignedURLOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IamAPIKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IamAPIKey) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.RoleMinusID.Set {
			e.FieldStart("role-id")
			s.RoleMinusID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIamAPIKey = [3]string{
	0: "name",
	1: "key",
	2: "role-id",
}

// Decode decodes IamAPIKey from json.
func (s *IamAPIKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IamAPIKey to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "role-id":
			if err := func() error {
				s.RoleMinusID.Reset()
				if err := s.RoleMinusID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role-id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IamAPIKey")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IamAPIKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IamAPIKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IamAPIKeyCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IamAPIKeyCreated) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Secret.Set {
			e.FieldStart("secret")
			s.Secret.Encode(e)
		}
	}
	{
		if s.RoleMinusID.Set {
			e.FieldStart("role-id")
			s.RoleMinusID.Encode(e)
		}
	}
}

var jsonFieldsNameOfIamAPIKeyCreated = [4]string{
	0: "name",
	1: "key",
	2: "secret",
	3: "role-id",
}

// Decode decodes IamAPIKeyCreated from json.
func (s *IamAPIKeyCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IamAPIKeyCreated to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "secret":
			if err := func() error {
				s.Secret.Reset()
				if err := s.Secret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "role-id":
			if err := func() error {
				s.RoleMinusID.Reset()
				if err := s.RoleMinusID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role-id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IamAPIKeyCreated")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IamAPIKeyCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IamAPIKeyCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IamPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IamPolicy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("default-service-strategy")
		s.DefaultMinusServiceMinusStrategy.Encode(e)
	}
	{
		e.FieldStart("services")
		s.Services.Encode(e)
	}
}

var jsonFieldsNameOfIamPolicy = [2]string{
	0: "default-service-strategy",
	1: "services",
}

// Decode decodes IamPolicy from json.
func (s *IamPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IamPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "default-service-strategy":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.DefaultMinusServiceMinusStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default-service-strategy\"")
			}
		case "services":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Services.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"services\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IamPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIamPolicy) {
					name = jsonFieldsNameOfIamPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IamPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IamPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IamPolicyDefaultMinusServiceMinusStrategy as json.
func (s IamPolicyDefaultMinusServiceMinusStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IamPolicyDefaultMinusServiceMinusStrategy from json.
func (s *IamPolicyDefaultMinusServiceMinusStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IamPolicyDefaultMinusServiceMinusStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IamPolicyDefaultMinusServiceMinusStrategy(v) {
	case IamPolicyDefaultMinusServiceMinusStrategyAllow:
		*s = IamPolicyDefaultMinusServiceMinusStrategyAllow
	case IamPolicyDefaultMinusServiceMinusStrategyDeny:
		*s = IamPolicyDefaultMinusServiceMinusStrategyDeny
	default:
		*s = IamPolicyDefaultMinusServiceMinusStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IamPolicyDefaultMinusServiceMinusStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IamPolicyDefaultMinusServiceMinusStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s IamPolicyServices) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s IamPolicyServices) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes IamPolicyServices from json.
func (s *IamPolicyServices) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IamPolicyServices to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem IamServicePolicy
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IamPolicyServices")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IamPolicyServices) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IamPolicyServices) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IamRole) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IamRole) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
	{
		if s.Editable.Set {
			e.FieldStart("editable")
			s.Editable.Encode(e)
		}
	}
	{
		if s.Policy.Set {
			e.FieldStart("policy")
			s.Policy.Encode(e)
		}
	}
}

var jsonFieldsNameOfIamRole = [6]string{
	0: "id",
	1: "name",
	2: "description",
	3: "labels",
	4: "editable",
	5: "policy",
}

// Decode decodes IamRole from json.
func (s *IamRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IamRole to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "editable":
			if err := func() error {
				s.Editable.Reset()
				if err := s.Editable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"editable\"")
			}
		case "policy":
			if err := func() error {
				s.Policy.Reset()
				if err := s.Policy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"policy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IamRole")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IamRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IamRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IamServicePolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IamServicePolicy) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Rules != nil {
			e.FieldStart("rules")
			e.ArrStart()
			for _, elem := range s.Rules {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIamServicePolicy = [2]string{
	0: "type",
	1: "rules",
}

// Decode decodes IamServicePolicy from json.
func (s *IamServicePolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IamServicePolicy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "rules":
			if err := func() error {
				s.Rules = make([]IamServicePolicyRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IamServicePolicyRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IamServicePolicy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IamServicePolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IamServicePolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IamServicePolicyRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IamServicePolicyRule) encodeFields(e *jx.Encoder) {
	{
		if s.Action.Set {
			e.FieldStart("action")
			s.Action.Encode(e)
		}
	}
	{
		if s.Expression.Set {
			e.FieldStart("expression")
			s.Expression.Encode(e)
		}
	}
	{
		if s.Resources != nil {
			e.FieldStart("resources")
			e.ArrStart()
			for _, elem := range s.Resources {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfIamServicePolicyRule = [3]string{
	0: "action",
	1: "expression",
	2: "resources",
}

// Decode decodes IamServicePolicyRule from json.
func (s *IamServicePolicyRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IamServicePolicyRule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "action":
			if err := func() error {
				s.Action.Reset()
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "expression":
			if err := func() error {
				s.Expression.Reset()
				if err := s.Expression.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expression\"")
			}
		case "resources":
			if err := func() error {
				s.Resources = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Resources = append(s.Resources, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resources\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IamServicePolicyRule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IamServicePolicyRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IamServicePolicyRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IamServicePolicyRuleAction as json.
func (s IamServicePolicyRuleAction) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IamServicePolicyRuleAction from json.
func (s *IamServicePolicyRuleAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IamServicePolicyRuleAction to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IamServicePolicyRuleAction(v) {
	case IamServicePolicyRuleActionAllow:
		*s = IamServicePolicyRuleActionAllow
	case IamServicePolicyRuleActionDeny:
		*s = IamServicePolicyRuleActionDeny
	default:
		*s = IamServicePolicyRuleAction(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IamServicePolicyRuleAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IamServicePolicyRuleAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IamServicePolicyType as json.
func (s IamServicePolicyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IamServicePolicyType from json.
func (s *IamServicePolicyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IamServicePolicyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IamServicePolicyType(v) {
	case IamServicePolicyTypeRules:
		*s = IamServicePolicyTypeRules
	case IamServicePolicyTypeAllow:
		*s = IamServicePolicyTypeAllow
	case IamServicePolicyTypeDeny:
		*s = IamServicePolicyTypeDeny
	default:
		*s = IamServicePolicyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IamServicePolicyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IamServicePolicyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstancePassword) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstancePassword) encodeFields(e *jx.Encoder) {
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstancePassword = [1]string{
	0: "password",
}

// Decode decodes InstancePassword from json.
func (s *InstancePassword) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstancePassword to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstancePassword")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstancePassword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstancePassword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstanceType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstanceType) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.Family.Set {
			e.FieldStart("family")
			s.Family.Encode(e)
		}
	}
	{
		if s.Cpus.Set {
			e.FieldStart("cpus")
			s.Cpus.Encode(e)
		}
	}
	{
		if s.Gpus.Set {
			e.FieldStart("gpus")
			s.Gpus.Encode(e)
		}
	}
	{
		if s.Authorized.Set {
			e.FieldStart("authorized")
			s.Authorized.Encode(e)
		}
	}
	{
		if s.Memory.Set {
			e.FieldStart("memory")
			s.Memory.Encode(e)
		}
	}
	{
		if s.Zones != nil {
			e.FieldStart("zones")
			e.ArrStart()
			for _, elem := range s.Zones {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInstanceType = [8]string{
	0: "id",
	1: "size",
	2: "family",
	3: "cpus",
	4: "gpus",
	5: "authorized",
	6: "memory",
	7: "zones",
}

// Decode decodes InstanceType from json.
func (s *InstanceType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "family":
			if err := func() error {
				s.Family.Reset()
				if err := s.Family.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"family\"")
			}
		case "cpus":
			if err := func() error {
				s.Cpus.Reset()
				if err := s.Cpus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpus\"")
			}
		case "gpus":
			if err := func() error {
				s.Gpus.Reset()
				if err := s.Gpus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gpus\"")
			}
		case "authorized":
			if err := func() error {
				s.Authorized.Reset()
				if err := s.Authorized.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorized\"")
			}
		case "memory":
			if err := func() error {
				s.Memory.Reset()
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		case "zones":
			if err := func() error {
				s.Zones = make([]ZoneName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ZoneName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Zones = append(s.Zones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zones\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstanceType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstanceType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstanceTypeFamily as json.
func (s InstanceTypeFamily) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InstanceTypeFamily from json.
func (s *InstanceTypeFamily) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceTypeFamily to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstanceTypeFamily(v) {
	case InstanceTypeFamilyGpu3:
		*s = InstanceTypeFamilyGpu3
	case InstanceTypeFamilyGpu2:
		*s = InstanceTypeFamilyGpu2
	case InstanceTypeFamilyGpu:
		*s = InstanceTypeFamilyGpu
	case InstanceTypeFamilyMemory:
		*s = InstanceTypeFamilyMemory
	case InstanceTypeFamilyStorage:
		*s = InstanceTypeFamilyStorage
	case InstanceTypeFamilyStandard:
		*s = InstanceTypeFamilyStandard
	case InstanceTypeFamilyColossus:
		*s = InstanceTypeFamilyColossus
	case InstanceTypeFamilyCPU:
		*s = InstanceTypeFamilyCPU
	default:
		*s = InstanceTypeFamily(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InstanceTypeFamily) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceTypeFamily) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstanceTypeSize as json.
func (s InstanceTypeSize) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes InstanceTypeSize from json.
func (s *InstanceTypeSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceTypeSize to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch InstanceTypeSize(v) {
	case InstanceTypeSizeLarge:
		*s = InstanceTypeSizeLarge
	case InstanceTypeSizeHuge:
		*s = InstanceTypeSizeHuge
	case InstanceTypeSizeJumbo:
		*s = InstanceTypeSizeJumbo
	case InstanceTypeSizeMedium:
		*s = InstanceTypeSizeMedium
	case InstanceTypeSizeMega:
		*s = InstanceTypeSizeMega
	case InstanceTypeSizeSmall:
		*s = InstanceTypeSizeSmall
	case InstanceTypeSizeExtraLarge:
		*s = InstanceTypeSizeExtraLarge
	case InstanceTypeSizeTitan:
		*s = InstanceTypeSizeTitan
	case InstanceTypeSizeMicro:
		*s = InstanceTypeSizeMicro
	case InstanceTypeSizeColossus:
		*s = InstanceTypeSizeColossus
	case InstanceTypeSizeTiny:
		*s = InstanceTypeSizeTiny
	default:
		*s = InstanceTypeSize(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s InstanceTypeSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceTypeSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Labels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s Labels) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes Labels from json.
func (s *Labels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Labels to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Labels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Labels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Labels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAPIKeysOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAPIKeysOK) encodeFields(e *jx.Encoder) {
	{
		if s.APIMinusKeys != nil {
			e.FieldStart("api-keys")
			e.ArrStart()
			for _, elem := range s.APIMinusKeys {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListAPIKeysOK = [1]string{
	0: "api-keys",
}

// Decode decodes ListAPIKeysOK from json.
func (s *ListAPIKeysOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAPIKeysOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "api-keys":
			if err := func() error {
				s.APIMinusKeys = make([]IamAPIKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IamAPIKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.APIMinusKeys = append(s.APIMinusKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"api-keys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAPIKeysOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAPIKeysOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAPIKeysOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAccessKeyKnownOperationsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAccessKeyKnownOperationsOK) encodeFields(e *jx.Encoder) {
	{
		if s.AccessMinusKeyMinusOperations != nil {
			e.FieldStart("access-key-operations")
			e.ArrStart()
			for _, elem := range s.AccessMinusKeyMinusOperations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListAccessKeyKnownOperationsOK = [1]string{
	0: "access-key-operations",
}

// Decode decodes ListAccessKeyKnownOperationsOK from json.
func (s *ListAccessKeyKnownOperationsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAccessKeyKnownOperationsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access-key-operations":
			if err := func() error {
				s.AccessMinusKeyMinusOperations = make([]AccessKeyOperation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AccessKeyOperation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AccessMinusKeyMinusOperations = append(s.AccessMinusKeyMinusOperations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access-key-operations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAccessKeyKnownOperationsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAccessKeyKnownOperationsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAccessKeyKnownOperationsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAccessKeyOperationsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAccessKeyOperationsOK) encodeFields(e *jx.Encoder) {
	{
		if s.AccessMinusKeyMinusOperations != nil {
			e.FieldStart("access-key-operations")
			e.ArrStart()
			for _, elem := range s.AccessMinusKeyMinusOperations {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListAccessKeyOperationsOK = [1]string{
	0: "access-key-operations",
}

// Decode decodes ListAccessKeyOperationsOK from json.
func (s *ListAccessKeyOperationsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAccessKeyOperationsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access-key-operations":
			if err := func() error {
				s.AccessMinusKeyMinusOperations = make([]AccessKeyOperation, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AccessKeyOperation
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AccessMinusKeyMinusOperations = append(s.AccessMinusKeyMinusOperations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access-key-operations\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAccessKeyOperationsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAccessKeyOperationsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAccessKeyOperationsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListAccessKeysOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListAccessKeysOK) encodeFields(e *jx.Encoder) {
	{
		if s.AccessMinusKeys != nil {
			e.FieldStart("access-keys")
			e.ArrStart()
			for _, elem := range s.AccessMinusKeys {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListAccessKeysOK = [1]string{
	0: "access-keys",
}

// Decode decodes ListAccessKeysOK from json.
func (s *ListAccessKeysOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListAccessKeysOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access-keys":
			if err := func() error {
				s.AccessMinusKeys = make([]AccessKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AccessKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AccessMinusKeys = append(s.AccessMinusKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access-keys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListAccessKeysOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListAccessKeysOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListAccessKeysOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDNSDomainRecordsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDNSDomainRecordsOK) encodeFields(e *jx.Encoder) {
	{
		if s.DNSMinusDomainMinusRecords != nil {
			e.FieldStart("dns-domain-records")
			e.ArrStart()
			for _, elem := range s.DNSMinusDomainMinusRecords {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListDNSDomainRecordsOK = [1]string{
	0: "dns-domain-records",
}

// Decode decodes ListDNSDomainRecordsOK from json.
func (s *ListDNSDomainRecordsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDNSDomainRecordsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dns-domain-records":
			if err := func() error {
				s.DNSMinusDomainMinusRecords = make([]DNSDomainRecord, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DNSDomainRecord
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DNSMinusDomainMinusRecords = append(s.DNSMinusDomainMinusRecords, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dns-domain-records\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDNSDomainRecordsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDNSDomainRecordsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDNSDomainRecordsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDNSDomainsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDNSDomainsOK) encodeFields(e *jx.Encoder) {
	{
		if s.DNSMinusDomains != nil {
			e.FieldStart("dns-domains")
			e.ArrStart()
			for _, elem := range s.DNSMinusDomains {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListDNSDomainsOK = [1]string{
	0: "dns-domains",
}

// Decode decodes ListDNSDomainsOK from json.
func (s *ListDNSDomainsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDNSDomainsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dns-domains":
			if err := func() error {
				s.DNSMinusDomains = make([]DNSDomain, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DNSDomain
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DNSMinusDomains = append(s.DNSMinusDomains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dns-domains\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDNSDomainsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDNSDomainsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDNSDomainsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDbaasIntegrationSettingsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDbaasIntegrationSettingsOK) encodeFields(e *jx.Encoder) {
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfListDbaasIntegrationSettingsOK = [1]string{
	0: "settings",
}

// Decode decodes ListDbaasIntegrationSettingsOK from json.
func (s *ListDbaasIntegrationSettingsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDbaasIntegrationSettingsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDbaasIntegrationSettingsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDbaasIntegrationSettingsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDbaasIntegrationSettingsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDbaasIntegrationSettingsOKSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDbaasIntegrationSettingsOKSettings) encodeFields(e *jx.Encoder) {
	{
		if s.Properties != nil {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties.Set {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfListDbaasIntegrationSettingsOKSettings = [4]string{
	0: "properties",
	1: "additionalProperties",
	2: "type",
	3: "title",
}

// Decode decodes ListDbaasIntegrationSettingsOKSettings from json.
func (s *ListDbaasIntegrationSettingsOKSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDbaasIntegrationSettingsOKSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "properties":
			if err := func() error {
				s.Properties = nil
				var elem ListDbaasIntegrationSettingsOKSettingsProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Properties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties.Reset()
				if err := s.AdditionalProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDbaasIntegrationSettingsOKSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDbaasIntegrationSettingsOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDbaasIntegrationSettingsOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDbaasIntegrationSettingsOKSettingsProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDbaasIntegrationSettingsOKSettingsProperties) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfListDbaasIntegrationSettingsOKSettingsProperties = [0]string{}

// Decode decodes ListDbaasIntegrationSettingsOKSettingsProperties from json.
func (s *ListDbaasIntegrationSettingsOKSettingsProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDbaasIntegrationSettingsOKSettingsProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDbaasIntegrationSettingsOKSettingsProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDbaasIntegrationSettingsOKSettingsProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDbaasIntegrationSettingsOKSettingsProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDbaasIntegrationTypesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDbaasIntegrationTypesOK) encodeFields(e *jx.Encoder) {
	{
		if s.DbaasMinusIntegrationMinusTypes != nil {
			e.FieldStart("dbaas-integration-types")
			e.ArrStart()
			for _, elem := range s.DbaasMinusIntegrationMinusTypes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListDbaasIntegrationTypesOK = [1]string{
	0: "dbaas-integration-types",
}

// Decode decodes ListDbaasIntegrationTypesOK from json.
func (s *ListDbaasIntegrationTypesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDbaasIntegrationTypesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dbaas-integration-types":
			if err := func() error {
				s.DbaasMinusIntegrationMinusTypes = make([]DbaasIntegrationType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasIntegrationType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DbaasMinusIntegrationMinusTypes = append(s.DbaasMinusIntegrationMinusTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbaas-integration-types\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDbaasIntegrationTypesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDbaasIntegrationTypesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDbaasIntegrationTypesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDbaasServiceTypesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDbaasServiceTypesOK) encodeFields(e *jx.Encoder) {
	{
		if s.DbaasMinusServiceMinusTypes != nil {
			e.FieldStart("dbaas-service-types")
			e.ArrStart()
			for _, elem := range s.DbaasMinusServiceMinusTypes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListDbaasServiceTypesOK = [1]string{
	0: "dbaas-service-types",
}

// Decode decodes ListDbaasServiceTypesOK from json.
func (s *ListDbaasServiceTypesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDbaasServiceTypesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dbaas-service-types":
			if err := func() error {
				s.DbaasMinusServiceMinusTypes = make([]DbaasServiceType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DbaasMinusServiceMinusTypes = append(s.DbaasMinusServiceMinusTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbaas-service-types\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDbaasServiceTypesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDbaasServiceTypesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDbaasServiceTypesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDbaasServicesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDbaasServicesOK) encodeFields(e *jx.Encoder) {
	{
		if s.DbaasMinusServices != nil {
			e.FieldStart("dbaas-services")
			e.ArrStart()
			for _, elem := range s.DbaasMinusServices {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListDbaasServicesOK = [1]string{
	0: "dbaas-services",
}

// Decode decodes ListDbaasServicesOK from json.
func (s *ListDbaasServicesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDbaasServicesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dbaas-services":
			if err := func() error {
				s.DbaasMinusServices = make([]DbaasServiceCommon, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DbaasServiceCommon
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DbaasMinusServices = append(s.DbaasMinusServices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbaas-services\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDbaasServicesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDbaasServicesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDbaasServicesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListDeployTargetsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListDeployTargetsOK) encodeFields(e *jx.Encoder) {
	{
		if s.DeployMinusTargets != nil {
			e.FieldStart("deploy-targets")
			e.ArrStart()
			for _, elem := range s.DeployMinusTargets {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListDeployTargetsOK = [1]string{
	0: "deploy-targets",
}

// Decode decodes ListDeployTargetsOK from json.
func (s *ListDeployTargetsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListDeployTargetsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "deploy-targets":
			if err := func() error {
				s.DeployMinusTargets = make([]DeployTarget, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeployTarget
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DeployMinusTargets = append(s.DeployMinusTargets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deploy-targets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListDeployTargetsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListDeployTargetsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListDeployTargetsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListElasticIpsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListElasticIpsOK) encodeFields(e *jx.Encoder) {
	{
		if s.ElasticMinusIps != nil {
			e.FieldStart("elastic-ips")
			e.ArrStart()
			for _, elem := range s.ElasticMinusIps {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListElasticIpsOK = [1]string{
	0: "elastic-ips",
}

// Decode decodes ListElasticIpsOK from json.
func (s *ListElasticIpsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListElasticIpsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "elastic-ips":
			if err := func() error {
				s.ElasticMinusIps = make([]ElasticIP, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ElasticIP
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ElasticMinusIps = append(s.ElasticMinusIps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"elastic-ips\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListElasticIpsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListElasticIpsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListElasticIpsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListIamRolesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListIamRolesOK) encodeFields(e *jx.Encoder) {
	{
		if s.IamMinusRoles != nil {
			e.FieldStart("iam-roles")
			e.ArrStart()
			for _, elem := range s.IamMinusRoles {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListIamRolesOK = [1]string{
	0: "iam-roles",
}

// Decode decodes ListIamRolesOK from json.
func (s *ListIamRolesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListIamRolesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "iam-roles":
			if err := func() error {
				s.IamMinusRoles = make([]IamRole, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem IamRole
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IamMinusRoles = append(s.IamMinusRoles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iam-roles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListIamRolesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListIamRolesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListIamRolesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListInstanceTypesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListInstanceTypesOK) encodeFields(e *jx.Encoder) {
	{
		if s.InstanceMinusTypes != nil {
			e.FieldStart("instance-types")
			e.ArrStart()
			for _, elem := range s.InstanceMinusTypes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListInstanceTypesOK = [1]string{
	0: "instance-types",
}

// Decode decodes ListInstanceTypesOK from json.
func (s *ListInstanceTypesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListInstanceTypesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instance-types":
			if err := func() error {
				s.InstanceMinusTypes = make([]InstanceType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InstanceType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InstanceMinusTypes = append(s.InstanceMinusTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance-types\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListInstanceTypesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListInstanceTypesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListInstanceTypesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListPrivateNetworksOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListPrivateNetworksOK) encodeFields(e *jx.Encoder) {
	{
		if s.PrivateMinusNetworks != nil {
			e.FieldStart("private-networks")
			e.ArrStart()
			for _, elem := range s.PrivateMinusNetworks {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListPrivateNetworksOK = [1]string{
	0: "private-networks",
}

// Decode decodes ListPrivateNetworksOK from json.
func (s *ListPrivateNetworksOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListPrivateNetworksOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "private-networks":
			if err := func() error {
				s.PrivateMinusNetworks = make([]PrivateNetwork, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PrivateNetwork
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.PrivateMinusNetworks = append(s.PrivateMinusNetworks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private-networks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListPrivateNetworksOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListPrivateNetworksOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListPrivateNetworksOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListQuotasOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListQuotasOK) encodeFields(e *jx.Encoder) {
	{
		if s.Quotas != nil {
			e.FieldStart("quotas")
			e.ArrStart()
			for _, elem := range s.Quotas {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListQuotasOK = [1]string{
	0: "quotas",
}

// Decode decodes ListQuotasOK from json.
func (s *ListQuotasOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListQuotasOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "quotas":
			if err := func() error {
				s.Quotas = make([]Quota, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Quota
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Quotas = append(s.Quotas, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotas\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListQuotasOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListQuotasOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListQuotasOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListSSHKeysOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListSSHKeysOK) encodeFields(e *jx.Encoder) {
	{
		if s.SSHMinusKeys != nil {
			e.FieldStart("ssh-keys")
			e.ArrStart()
			for _, elem := range s.SSHMinusKeys {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListSSHKeysOK = [1]string{
	0: "ssh-keys",
}

// Decode decodes ListSSHKeysOK from json.
func (s *ListSSHKeysOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListSSHKeysOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ssh-keys":
			if err := func() error {
				s.SSHMinusKeys = make([]SSHKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SSHKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SSHMinusKeys = append(s.SSHMinusKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh-keys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListSSHKeysOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListSSHKeysOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListSSHKeysOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListSksClusterVersionsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListSksClusterVersionsOK) encodeFields(e *jx.Encoder) {
	{
		if s.SksMinusClusterMinusVersions != nil {
			e.FieldStart("sks-cluster-versions")
			e.ArrStart()
			for _, elem := range s.SksMinusClusterMinusVersions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListSksClusterVersionsOK = [1]string{
	0: "sks-cluster-versions",
}

// Decode decodes ListSksClusterVersionsOK from json.
func (s *ListSksClusterVersionsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListSksClusterVersionsOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sks-cluster-versions":
			if err := func() error {
				s.SksMinusClusterMinusVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SksMinusClusterMinusVersions = append(s.SksMinusClusterMinusVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sks-cluster-versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListSksClusterVersionsOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListSksClusterVersionsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListSksClusterVersionsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListSosBucketsUsageOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListSosBucketsUsageOK) encodeFields(e *jx.Encoder) {
	{
		if s.SosMinusBucketsMinusUsage != nil {
			e.FieldStart("sos-buckets-usage")
			e.ArrStart()
			for _, elem := range s.SosMinusBucketsMinusUsage {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListSosBucketsUsageOK = [1]string{
	0: "sos-buckets-usage",
}

// Decode decodes ListSosBucketsUsageOK from json.
func (s *ListSosBucketsUsageOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListSosBucketsUsageOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sos-buckets-usage":
			if err := func() error {
				s.SosMinusBucketsMinusUsage = make([]SosBucketUsage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SosBucketUsage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SosMinusBucketsMinusUsage = append(s.SosMinusBucketsMinusUsage, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sos-buckets-usage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListSosBucketsUsageOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListSosBucketsUsageOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListSosBucketsUsageOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListTemplatesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListTemplatesOK) encodeFields(e *jx.Encoder) {
	{
		if s.Templates != nil {
			e.FieldStart("templates")
			e.ArrStart()
			for _, elem := range s.Templates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListTemplatesOK = [1]string{
	0: "templates",
}

// Decode decodes ListTemplatesOK from json.
func (s *ListTemplatesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListTemplatesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templates":
			if err := func() error {
				s.Templates = make([]Template, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Template
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Templates = append(s.Templates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListTemplatesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListTemplatesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListTemplatesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListZonesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListZonesOK) encodeFields(e *jx.Encoder) {
	{
		if s.Zones != nil {
			e.FieldStart("zones")
			e.ArrStart()
			for _, elem := range s.Zones {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfListZonesOK = [1]string{
	0: "zones",
}

// Decode decodes ListZonesOK from json.
func (s *ListZonesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListZonesOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "zones":
			if err := func() error {
				s.Zones = make([]Zone, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Zone
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Zones = append(s.Zones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zones\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListZonesOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListZonesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListZonesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoadBalancerServiceHealthcheck) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoadBalancerServiceHealthcheck) encodeFields(e *jx.Encoder) {
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
	{
		if s.Interval.Set {
			e.FieldStart("interval")
			s.Interval.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Timeout.Set {
			e.FieldStart("timeout")
			s.Timeout.Encode(e)
		}
	}
	{
		if s.Retries.Set {
			e.FieldStart("retries")
			s.Retries.Encode(e)
		}
	}
	{
		if s.TLSMinusSni.Set {
			e.FieldStart("tls-sni")
			s.TLSMinusSni.Encode(e)
		}
	}
}

var jsonFieldsNameOfLoadBalancerServiceHealthcheck = [7]string{
	0: "mode",
	1: "interval",
	2: "uri",
	3: "port",
	4: "timeout",
	5: "retries",
	6: "tls-sni",
}

// Decode decodes LoadBalancerServiceHealthcheck from json.
func (s *LoadBalancerServiceHealthcheck) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoadBalancerServiceHealthcheck to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "interval":
			if err := func() error {
				s.Interval.Reset()
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "timeout":
			if err := func() error {
				s.Timeout.Reset()
				if err := s.Timeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timeout\"")
			}
		case "retries":
			if err := func() error {
				s.Retries.Reset()
				if err := s.Retries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retries\"")
			}
		case "tls-sni":
			if err := func() error {
				s.TLSMinusSni.Reset()
				if err := s.TLSMinusSni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tls-sni\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoadBalancerServiceHealthcheck")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoadBalancerServiceHealthcheck) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoadBalancerServiceHealthcheck) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoadBalancerServiceHealthcheckMode as json.
func (s LoadBalancerServiceHealthcheckMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes LoadBalancerServiceHealthcheckMode from json.
func (s *LoadBalancerServiceHealthcheckMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoadBalancerServiceHealthcheckMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch LoadBalancerServiceHealthcheckMode(v) {
	case LoadBalancerServiceHealthcheckModeTCP:
		*s = LoadBalancerServiceHealthcheckModeTCP
	case LoadBalancerServiceHealthcheckModeHTTP:
		*s = LoadBalancerServiceHealthcheckModeHTTP
	case LoadBalancerServiceHealthcheckModeHTTPS:
		*s = LoadBalancerServiceHealthcheckModeHTTPS
	default:
		*s = LoadBalancerServiceHealthcheckMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LoadBalancerServiceHealthcheckMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoadBalancerServiceHealthcheckMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Operation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Operation) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
	{
		if s.Reference.Set {
			e.FieldStart("reference")
			s.Reference.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
}

var jsonFieldsNameOfOperation = [5]string{
	0: "id",
	1: "reason",
	2: "reference",
	3: "message",
	4: "state",
}

// Decode decodes Operation from json.
func (s *Operation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Operation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		case "reference":
			if err := func() error {
				s.Reference.Reset()
				if err := s.Reference.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reference\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Operation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Operation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Operation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OperationReason as json.
func (s OperationReason) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OperationReason from json.
func (s *OperationReason) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OperationReason to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OperationReason(v) {
	case OperationReasonIncorrect:
		*s = OperationReasonIncorrect
	case OperationReasonUnknown:
		*s = OperationReasonUnknown
	case OperationReasonUnavailable:
		*s = OperationReasonUnavailable
	case OperationReasonForbidden:
		*s = OperationReasonForbidden
	case OperationReasonBusy:
		*s = OperationReasonBusy
	case OperationReasonFault:
		*s = OperationReasonFault
	case OperationReasonPartial:
		*s = OperationReasonPartial
	case OperationReasonNotFound:
		*s = OperationReasonNotFound
	case OperationReasonInterrupted:
		*s = OperationReasonInterrupted
	case OperationReasonUnsupported:
		*s = OperationReasonUnsupported
	case OperationReasonConflict:
		*s = OperationReasonConflict
	default:
		*s = OperationReason(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OperationReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OperationReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OperationReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OperationReference) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Link.Set {
			e.FieldStart("link")
			s.Link.Encode(e)
		}
	}
	{
		if s.Command.Set {
			e.FieldStart("command")
			s.Command.Encode(e)
		}
	}
}

var jsonFieldsNameOfOperationReference = [3]string{
	0: "id",
	1: "link",
	2: "command",
}

// Decode decodes OperationReference from json.
func (s *OperationReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OperationReference to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "link":
			if err := func() error {
				s.Link.Reset()
				if err := s.Link.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link\"")
			}
		case "command":
			if err := func() error {
				s.Command.Reset()
				if err := s.Command.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"command\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OperationReference")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OperationReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OperationReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OperationState as json.
func (s OperationState) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OperationState from json.
func (s *OperationState) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OperationState to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OperationState(v) {
	case OperationStateFailure:
		*s = OperationStateFailure
	case OperationStatePending:
		*s = OperationStatePending
	case OperationStateSuccess:
		*s = OperationStateSuccess
	case OperationStateTimeout:
		*s = OperationStateTimeout
	default:
		*s = OperationState(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OperationState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OperationState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessKeyResourceDomain as json.
func (o OptAccessKeyResourceDomain) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AccessKeyResourceDomain from json.
func (o *OptAccessKeyResourceDomain) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccessKeyResourceDomain to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccessKeyResourceDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccessKeyResourceDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessKeyResourceResourceMinusType as json.
func (o OptAccessKeyResourceResourceMinusType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AccessKeyResourceResourceMinusType from json.
func (o *OptAccessKeyResourceResourceMinusType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccessKeyResourceResourceMinusType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccessKeyResourceResourceMinusType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccessKeyResourceResourceMinusType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessKeyType as json.
func (o OptAccessKeyType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AccessKeyType from json.
func (o *OptAccessKeyType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccessKeyType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccessKeyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccessKeyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AccessKeyVersion as json.
func (o OptAccessKeyVersion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AccessKeyVersion from json.
func (o *OptAccessKeyVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAccessKeyVersion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAccessKeyVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAccessKeyVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRuleToSecurityGroupReqIcmp as json.
func (o OptAddRuleToSecurityGroupReqIcmp) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AddRuleToSecurityGroupReqIcmp from json.
func (o *OptAddRuleToSecurityGroupReqIcmp) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAddRuleToSecurityGroupReqIcmp to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAddRuleToSecurityGroupReqIcmp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAddRuleToSecurityGroupReqIcmp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceKafkaReqAuthenticationMinusMethods as json.
func (o OptCreateDbaasServiceKafkaReqAuthenticationMinusMethods) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServiceKafkaReqAuthenticationMinusMethods from json.
func (o *OptCreateDbaasServiceKafkaReqAuthenticationMinusMethods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServiceKafkaReqAuthenticationMinusMethods to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServiceKafkaReqAuthenticationMinusMethods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServiceKafkaReqAuthenticationMinusMethods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceKafkaReqMaintenance as json.
func (o OptCreateDbaasServiceKafkaReqMaintenance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServiceKafkaReqMaintenance from json.
func (o *OptCreateDbaasServiceKafkaReqMaintenance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServiceKafkaReqMaintenance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServiceKafkaReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServiceKafkaReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceMysqlReqBackupMinusSchedule as json.
func (o OptCreateDbaasServiceMysqlReqBackupMinusSchedule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServiceMysqlReqBackupMinusSchedule from json.
func (o *OptCreateDbaasServiceMysqlReqBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServiceMysqlReqBackupMinusSchedule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServiceMysqlReqBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServiceMysqlReqBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceMysqlReqMaintenance as json.
func (o OptCreateDbaasServiceMysqlReqMaintenance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServiceMysqlReqMaintenance from json.
func (o *OptCreateDbaasServiceMysqlReqMaintenance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServiceMysqlReqMaintenance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServiceMysqlReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServiceMysqlReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceMysqlReqMigration as json.
func (o OptCreateDbaasServiceMysqlReqMigration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServiceMysqlReqMigration from json.
func (o *OptCreateDbaasServiceMysqlReqMigration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServiceMysqlReqMigration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServiceMysqlReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServiceMysqlReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm as json.
func (o OptCreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm from json.
func (o *OptCreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceOpensearchReqIndexMinusTemplate as json.
func (o OptCreateDbaasServiceOpensearchReqIndexMinusTemplate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServiceOpensearchReqIndexMinusTemplate from json.
func (o *OptCreateDbaasServiceOpensearchReqIndexMinusTemplate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServiceOpensearchReqIndexMinusTemplate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServiceOpensearchReqIndexMinusTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServiceOpensearchReqIndexMinusTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceOpensearchReqMaintenance as json.
func (o OptCreateDbaasServiceOpensearchReqMaintenance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServiceOpensearchReqMaintenance from json.
func (o *OptCreateDbaasServiceOpensearchReqMaintenance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServiceOpensearchReqMaintenance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServiceOpensearchReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServiceOpensearchReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceOpensearchReqOpensearchMinusDashboards as json.
func (o OptCreateDbaasServiceOpensearchReqOpensearchMinusDashboards) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServiceOpensearchReqOpensearchMinusDashboards from json.
func (o *OptCreateDbaasServiceOpensearchReqOpensearchMinusDashboards) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServiceOpensearchReqOpensearchMinusDashboards to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServiceOpensearchReqOpensearchMinusDashboards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServiceOpensearchReqOpensearchMinusDashboards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServicePgReqBackupMinusSchedule as json.
func (o OptCreateDbaasServicePgReqBackupMinusSchedule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServicePgReqBackupMinusSchedule from json.
func (o *OptCreateDbaasServicePgReqBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServicePgReqBackupMinusSchedule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServicePgReqBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServicePgReqBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServicePgReqMaintenance as json.
func (o OptCreateDbaasServicePgReqMaintenance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServicePgReqMaintenance from json.
func (o *OptCreateDbaasServicePgReqMaintenance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServicePgReqMaintenance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServicePgReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServicePgReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServicePgReqMigration as json.
func (o OptCreateDbaasServicePgReqMigration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServicePgReqMigration from json.
func (o *OptCreateDbaasServicePgReqMigration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServicePgReqMigration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServicePgReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServicePgReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceRedisReqMaintenance as json.
func (o OptCreateDbaasServiceRedisReqMaintenance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServiceRedisReqMaintenance from json.
func (o *OptCreateDbaasServiceRedisReqMaintenance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServiceRedisReqMaintenance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServiceRedisReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServiceRedisReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateDbaasServiceRedisReqMigration as json.
func (o OptCreateDbaasServiceRedisReqMigration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateDbaasServiceRedisReqMigration from json.
func (o *OptCreateDbaasServiceRedisReqMigration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateDbaasServiceRedisReqMigration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateDbaasServiceRedisReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateDbaasServiceRedisReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateElasticIPReqAddressfamily as json.
func (o OptCreateElasticIPReqAddressfamily) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateElasticIPReqAddressfamily from json.
func (o *OptCreateElasticIPReqAddressfamily) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateElasticIPReqAddressfamily to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateElasticIPReqAddressfamily) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateElasticIPReqAddressfamily) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSksClusterReqCni as json.
func (o OptCreateSksClusterReqCni) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateSksClusterReqCni from json.
func (o *OptCreateSksClusterReqCni) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateSksClusterReqCni to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateSksClusterReqCni) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateSksClusterReqCni) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DNSDomainRecordType as json.
func (o OptDNSDomainRecordType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DNSDomainRecordType from json.
func (o *OptDNSDomainRecordType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDNSDomainRecordType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDNSDomainRecordType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDNSDomainRecordType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DbaasBackupConfig as json.
func (o OptDbaasBackupConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasBackupConfig from json.
func (o *OptDbaasBackupConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasBackupConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasBackupConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasBackupConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasIntegrationTypeSettings as json.
func (o OptDbaasIntegrationTypeSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasIntegrationTypeSettings from json.
func (o *OptDbaasIntegrationTypeSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasIntegrationTypeSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasIntegrationTypeSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasIntegrationTypeSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasKafkaACLID as json.
func (o OptDbaasKafkaACLID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasKafkaACLID from json.
func (o *OptDbaasKafkaACLID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasKafkaACLID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasKafkaACLID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasKafkaACLID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasNodeStateRole as json.
func (o OptDbaasNodeStateRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DbaasNodeStateRole from json.
func (o *OptDbaasNodeStateRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasNodeStateRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasNodeStateRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasNodeStateRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceKafkaAuthenticationMinusMethods as json.
func (o OptDbaasServiceKafkaAuthenticationMinusMethods) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceKafkaAuthenticationMinusMethods from json.
func (o *OptDbaasServiceKafkaAuthenticationMinusMethods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceKafkaAuthenticationMinusMethods to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceKafkaAuthenticationMinusMethods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceKafkaAuthenticationMinusMethods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceKafkaConnectionMinusInfo as json.
func (o OptDbaasServiceKafkaConnectionMinusInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceKafkaConnectionMinusInfo from json.
func (o *OptDbaasServiceKafkaConnectionMinusInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceKafkaConnectionMinusInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceKafkaConnectionMinusInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceKafkaConnectionMinusInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceMaintenance as json.
func (o OptDbaasServiceMaintenance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceMaintenance from json.
func (o *OptDbaasServiceMaintenance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceMaintenance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceMysqlBackupMinusSchedule as json.
func (o OptDbaasServiceMysqlBackupMinusSchedule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceMysqlBackupMinusSchedule from json.
func (o *OptDbaasServiceMysqlBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceMysqlBackupMinusSchedule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceMysqlBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceMysqlBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceMysqlConnectionMinusInfo as json.
func (o OptDbaasServiceMysqlConnectionMinusInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceMysqlConnectionMinusInfo from json.
func (o *OptDbaasServiceMysqlConnectionMinusInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceMysqlConnectionMinusInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceMysqlConnectionMinusInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceMysqlConnectionMinusInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceName as json.
func (o OptDbaasServiceName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceName from json.
func (o *OptDbaasServiceName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceOpensearchConnectionMinusInfo as json.
func (o OptDbaasServiceOpensearchConnectionMinusInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceOpensearchConnectionMinusInfo from json.
func (o *OptDbaasServiceOpensearchConnectionMinusInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceOpensearchConnectionMinusInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceOpensearchConnectionMinusInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceOpensearchConnectionMinusInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm as json.
func (o OptDbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm from json.
func (o *OptDbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceOpensearchIndexMinusPatternsItemSortingMinusAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceOpensearchIndexMinusTemplate as json.
func (o OptDbaasServiceOpensearchIndexMinusTemplate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceOpensearchIndexMinusTemplate from json.
func (o *OptDbaasServiceOpensearchIndexMinusTemplate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceOpensearchIndexMinusTemplate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceOpensearchIndexMinusTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceOpensearchIndexMinusTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceOpensearchOpensearchMinusDashboards as json.
func (o OptDbaasServiceOpensearchOpensearchMinusDashboards) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceOpensearchOpensearchMinusDashboards from json.
func (o *OptDbaasServiceOpensearchOpensearchMinusDashboards) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceOpensearchOpensearchMinusDashboards to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceOpensearchOpensearchMinusDashboards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceOpensearchOpensearchMinusDashboards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServicePgBackupMinusSchedule as json.
func (o OptDbaasServicePgBackupMinusSchedule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServicePgBackupMinusSchedule from json.
func (o *OptDbaasServicePgBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServicePgBackupMinusSchedule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServicePgBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServicePgBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServicePgConnectionMinusInfo as json.
func (o OptDbaasServicePgConnectionMinusInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServicePgConnectionMinusInfo from json.
func (o *OptDbaasServicePgConnectionMinusInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServicePgConnectionMinusInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServicePgConnectionMinusInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServicePgConnectionMinusInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceRedisConnectionMinusInfo as json.
func (o OptDbaasServiceRedisConnectionMinusInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceRedisConnectionMinusInfo from json.
func (o *OptDbaasServiceRedisConnectionMinusInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceRedisConnectionMinusInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceRedisConnectionMinusInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceRedisConnectionMinusInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceRedisUsersItemAccessMinusControl as json.
func (o OptDbaasServiceRedisUsersItemAccessMinusControl) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceRedisUsersItemAccessMinusControl from json.
func (o *OptDbaasServiceRedisUsersItemAccessMinusControl) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceRedisUsersItemAccessMinusControl to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceRedisUsersItemAccessMinusControl) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceRedisUsersItemAccessMinusControl) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasServiceTypeName as json.
func (o OptDbaasServiceTypeName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasServiceTypeName from json.
func (o *OptDbaasServiceTypeName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasServiceTypeName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasServiceTypeName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasServiceTypeName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaasUserPassword as json.
func (o OptDbaasUserPassword) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DbaasUserPassword from json.
func (o *OptDbaasUserPassword) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDbaasUserPassword to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDbaasUserPassword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDbaasUserPassword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeployTargetType as json.
func (o OptDeployTargetType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DeployTargetType from json.
func (o *OptDeployTargetType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDeployTargetType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDeployTargetType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDeployTargetType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DomainName as json.
func (o OptDomainName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DomainName from json.
func (o *OptDomainName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDomainName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDomainName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDomainName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ElasticIPAddressfamily as json.
func (o OptElasticIPAddressfamily) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ElasticIPAddressfamily from json.
func (o *OptElasticIPAddressfamily) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptElasticIPAddressfamily to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptElasticIPAddressfamily) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptElasticIPAddressfamily) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ElasticIPHealthcheck as json.
func (o OptElasticIPHealthcheck) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ElasticIPHealthcheck from json.
func (o *OptElasticIPHealthcheck) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptElasticIPHealthcheck to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptElasticIPHealthcheck) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptElasticIPHealthcheck) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumKafkaAuthMethod as json.
func (o OptEnumKafkaAuthMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnumKafkaAuthMethod from json.
func (o *OptEnumKafkaAuthMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnumKafkaAuthMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnumKafkaAuthMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnumKafkaAuthMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumMasterLinkStatus as json.
func (o OptEnumMasterLinkStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnumMasterLinkStatus from json.
func (o *OptEnumMasterLinkStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnumMasterLinkStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnumMasterLinkStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnumMasterLinkStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumMigrationMethod as json.
func (o OptEnumMigrationMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnumMigrationMethod from json.
func (o *OptEnumMigrationMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnumMigrationMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnumMigrationMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnumMigrationMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumMigrationStatus as json.
func (o OptEnumMigrationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnumMigrationStatus from json.
func (o *OptEnumMigrationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnumMigrationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnumMigrationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnumMigrationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumPgSynchronousReplication as json.
func (o OptEnumPgSynchronousReplication) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnumPgSynchronousReplication from json.
func (o *OptEnumPgSynchronousReplication) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnumPgSynchronousReplication to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnumPgSynchronousReplication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnumPgSynchronousReplication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumPgVariant as json.
func (o OptEnumPgVariant) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnumPgVariant from json.
func (o *OptEnumPgVariant) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnumPgVariant to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnumPgVariant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnumPgVariant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumServiceState as json.
func (o OptEnumServiceState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnumServiceState from json.
func (o *OptEnumServiceState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnumServiceState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnumServiceState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnumServiceState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumSortOrder as json.
func (o OptEnumSortOrder) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnumSortOrder from json.
func (o *OptEnumSortOrder) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnumSortOrder to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnumSortOrder) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnumSortOrder) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasServiceMetricsReqPeriod as json.
func (o OptGetDbaasServiceMetricsReqPeriod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetDbaasServiceMetricsReqPeriod from json.
func (o *OptGetDbaasServiceMetricsReqPeriod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasServiceMetricsReqPeriod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasServiceMetricsReqPeriod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasServiceMetricsReqPeriod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsKafkaOKSettings as json.
func (o OptGetDbaasSettingsKafkaOKSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsKafkaOKSettings from json.
func (o *OptGetDbaasSettingsKafkaOKSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsKafkaOKSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsKafkaOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsKafkaOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsKafkaOKSettingsKafka as json.
func (o OptGetDbaasSettingsKafkaOKSettingsKafka) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsKafkaOKSettingsKafka from json.
func (o *OptGetDbaasSettingsKafkaOKSettingsKafka) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsKafkaOKSettingsKafka to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsKafkaOKSettingsKafka) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsKafkaOKSettingsKafka) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsKafkaOKSettingsKafkaMinusConnect as json.
func (o OptGetDbaasSettingsKafkaOKSettingsKafkaMinusConnect) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsKafkaOKSettingsKafkaMinusConnect from json.
func (o *OptGetDbaasSettingsKafkaOKSettingsKafkaMinusConnect) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsKafkaOKSettingsKafkaMinusConnect to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsKafkaOKSettingsKafkaMinusConnect) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsKafkaOKSettingsKafkaMinusConnect) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsKafkaOKSettingsKafkaMinusRest as json.
func (o OptGetDbaasSettingsKafkaOKSettingsKafkaMinusRest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsKafkaOKSettingsKafkaMinusRest from json.
func (o *OptGetDbaasSettingsKafkaOKSettingsKafkaMinusRest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsKafkaOKSettingsKafkaMinusRest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsKafkaOKSettingsKafkaMinusRest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsKafkaOKSettingsKafkaMinusRest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry as json.
func (o OptGetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry from json.
func (o *OptGetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsKafkaOKSettingsSchemaMinusRegistry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsMysqlOKSettings as json.
func (o OptGetDbaasSettingsMysqlOKSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsMysqlOKSettings from json.
func (o *OptGetDbaasSettingsMysqlOKSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsMysqlOKSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsMysqlOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsMysqlOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsMysqlOKSettingsMysql as json.
func (o OptGetDbaasSettingsMysqlOKSettingsMysql) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsMysqlOKSettingsMysql from json.
func (o *OptGetDbaasSettingsMysqlOKSettingsMysql) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsMysqlOKSettingsMysql to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsMysqlOKSettingsMysql) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsMysqlOKSettingsMysql) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsOpensearchOKSettings as json.
func (o OptGetDbaasSettingsOpensearchOKSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsOpensearchOKSettings from json.
func (o *OptGetDbaasSettingsOpensearchOKSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsOpensearchOKSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsOpensearchOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsOpensearchOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsOpensearchOKSettingsOpensearch as json.
func (o OptGetDbaasSettingsOpensearchOKSettingsOpensearch) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsOpensearchOKSettingsOpensearch from json.
func (o *OptGetDbaasSettingsOpensearchOKSettingsOpensearch) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsOpensearchOKSettingsOpensearch to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsOpensearchOKSettingsOpensearch) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsOpensearchOKSettingsOpensearch) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsPgOKSettings as json.
func (o OptGetDbaasSettingsPgOKSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsPgOKSettings from json.
func (o *OptGetDbaasSettingsPgOKSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsPgOKSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsPgOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsPgOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsPgOKSettingsPg as json.
func (o OptGetDbaasSettingsPgOKSettingsPg) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsPgOKSettingsPg from json.
func (o *OptGetDbaasSettingsPgOKSettingsPg) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsPgOKSettingsPg to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsPgOKSettingsPg) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsPgOKSettingsPg) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsPgOKSettingsPgbouncer as json.
func (o OptGetDbaasSettingsPgOKSettingsPgbouncer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsPgOKSettingsPgbouncer from json.
func (o *OptGetDbaasSettingsPgOKSettingsPgbouncer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsPgOKSettingsPgbouncer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsPgOKSettingsPgbouncer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsPgOKSettingsPgbouncer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsPgOKSettingsPglookout as json.
func (o OptGetDbaasSettingsPgOKSettingsPglookout) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsPgOKSettingsPglookout from json.
func (o *OptGetDbaasSettingsPgOKSettingsPglookout) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsPgOKSettingsPglookout to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsPgOKSettingsPglookout) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsPgOKSettingsPglookout) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsPgOKSettingsTimescaledb as json.
func (o OptGetDbaasSettingsPgOKSettingsTimescaledb) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsPgOKSettingsTimescaledb from json.
func (o *OptGetDbaasSettingsPgOKSettingsTimescaledb) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsPgOKSettingsTimescaledb to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsPgOKSettingsTimescaledb) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsPgOKSettingsTimescaledb) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsRedisOKSettings as json.
func (o OptGetDbaasSettingsRedisOKSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsRedisOKSettings from json.
func (o *OptGetDbaasSettingsRedisOKSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsRedisOKSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsRedisOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsRedisOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDbaasSettingsRedisOKSettingsRedis as json.
func (o OptGetDbaasSettingsRedisOKSettingsRedis) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetDbaasSettingsRedisOKSettingsRedis from json.
func (o *OptGetDbaasSettingsRedisOKSettingsRedis) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetDbaasSettingsRedisOKSettingsRedis to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetDbaasSettingsRedisOKSettingsRedis) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetDbaasSettingsRedisOKSettingsRedis) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes netip.Addr as json.
func (o OptIPv4) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeIPv4(e, o.Value)
}

// Decode decodes netip.Addr from json.
func (o *OptIPv4) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIPv4 to nil")
	}
	o.Set = true
	v, err := json.DecodeIPv4(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIPv4) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIPv4) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IamPolicy as json.
func (o OptIamPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IamPolicy from json.
func (o *OptIamPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIamPolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIamPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIamPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IamServicePolicyRuleAction as json.
func (o OptIamServicePolicyRuleAction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IamServicePolicyRuleAction from json.
func (o *OptIamServicePolicyRuleAction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIamServicePolicyRuleAction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIamServicePolicyRuleAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIamServicePolicyRuleAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IamServicePolicyType as json.
func (o OptIamServicePolicyType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes IamServicePolicyType from json.
func (o *OptIamServicePolicyType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIamServicePolicyType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIamServicePolicyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIamServicePolicyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstanceTypeFamily as json.
func (o OptInstanceTypeFamily) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InstanceTypeFamily from json.
func (o *OptInstanceTypeFamily) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInstanceTypeFamily to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInstanceTypeFamily) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInstanceTypeFamily) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstanceTypeSize as json.
func (o OptInstanceTypeSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes InstanceTypeSize from json.
func (o *OptInstanceTypeSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInstanceTypeSize to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInstanceTypeSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInstanceTypeSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Labels as json.
func (o OptLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Labels from json.
func (o *OptLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLabels to nil")
	}
	o.Set = true
	o.Value = make(Labels)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListDbaasIntegrationSettingsOKSettings as json.
func (o OptListDbaasIntegrationSettingsOKSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ListDbaasIntegrationSettingsOKSettings from json.
func (o *OptListDbaasIntegrationSettingsOKSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptListDbaasIntegrationSettingsOKSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptListDbaasIntegrationSettingsOKSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptListDbaasIntegrationSettingsOKSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoadBalancerServiceHealthcheck as json.
func (o OptLoadBalancerServiceHealthcheck) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LoadBalancerServiceHealthcheck from json.
func (o *OptLoadBalancerServiceHealthcheck) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLoadBalancerServiceHealthcheck to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLoadBalancerServiceHealthcheck) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLoadBalancerServiceHealthcheck) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LoadBalancerServiceHealthcheckMode as json.
func (o OptLoadBalancerServiceHealthcheckMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes LoadBalancerServiceHealthcheckMode from json.
func (o *OptLoadBalancerServiceHealthcheckMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLoadBalancerServiceHealthcheckMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLoadBalancerServiceHealthcheckMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLoadBalancerServiceHealthcheckMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OperationReason as json.
func (o OptOperationReason) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OperationReason from json.
func (o *OptOperationReason) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOperationReason to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOperationReason) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOperationReason) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OperationReference as json.
func (o OptOperationReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OperationReference from json.
func (o *OptOperationReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOperationReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOperationReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOperationReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OperationState as json.
func (o OptOperationState) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes OperationState from json.
func (o *OptOperationState) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOperationState to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOperationState) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOperationState) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicIPAssignment as json.
func (o OptPublicIPAssignment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PublicIPAssignment from json.
func (o *OptPublicIPAssignment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPublicIPAssignment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPublicIPAssignment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPublicIPAssignment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisterTemplateReqBootMinusMode as json.
func (o OptRegisterTemplateReqBootMinusMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RegisterTemplateReqBootMinusMode from json.
func (o *OptRegisterTemplateReqBootMinusMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRegisterTemplateReqBootMinusMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRegisterTemplateReqBootMinusMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRegisterTemplateReqBootMinusMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecurityGroupResource as json.
func (o OptSecurityGroupResource) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SecurityGroupResource from json.
func (o *OptSecurityGroupResource) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSecurityGroupResource to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSecurityGroupResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSecurityGroupResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecurityGroupResourceVisibility as json.
func (o OptSecurityGroupResourceVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SecurityGroupResourceVisibility from json.
func (o *OptSecurityGroupResourceVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSecurityGroupResourceVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSecurityGroupResourceVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSecurityGroupResourceVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SksOidc as json.
func (o OptSksOidc) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SksOidc from json.
func (o *OptSksOidc) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSksOidc to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSksOidc) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSksOidc) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SksOidcRequiredMinusClaim as json.
func (o OptSksOidcRequiredMinusClaim) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SksOidcRequiredMinusClaim from json.
func (o *OptSksOidcRequiredMinusClaim) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSksOidcRequiredMinusClaim to nil")
	}
	o.Set = true
	o.Value = make(SksOidcRequiredMinusClaim)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSksOidcRequiredMinusClaim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSksOidcRequiredMinusClaim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartInstanceReqRescueMinusProfile as json.
func (o OptStartInstanceReqRescueMinusProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StartInstanceReqRescueMinusProfile from json.
func (o *OptStartInstanceReqRescueMinusProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStartInstanceReqRescueMinusProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStartInstanceReqRescueMinusProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStartInstanceReqRescueMinusProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Template as json.
func (o OptTemplate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Template from json.
func (o *OptTemplate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTemplate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TemplateBootMinusMode as json.
func (o OptTemplateBootMinusMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TemplateBootMinusMode from json.
func (o *OptTemplateBootMinusMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTemplateBootMinusMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTemplateBootMinusMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTemplateBootMinusMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TemplateVisibility as json.
func (o OptTemplateVisibility) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TemplateVisibility from json.
func (o *OptTemplateVisibility) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTemplateVisibility to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTemplateVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTemplateVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceKafkaReqAuthenticationMinusMethods as json.
func (o OptUpdateDbaasServiceKafkaReqAuthenticationMinusMethods) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServiceKafkaReqAuthenticationMinusMethods from json.
func (o *OptUpdateDbaasServiceKafkaReqAuthenticationMinusMethods) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServiceKafkaReqAuthenticationMinusMethods to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServiceKafkaReqAuthenticationMinusMethods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServiceKafkaReqAuthenticationMinusMethods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceKafkaReqMaintenance as json.
func (o OptUpdateDbaasServiceKafkaReqMaintenance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServiceKafkaReqMaintenance from json.
func (o *OptUpdateDbaasServiceKafkaReqMaintenance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServiceKafkaReqMaintenance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServiceKafkaReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServiceKafkaReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceMysqlReqBackupMinusSchedule as json.
func (o OptUpdateDbaasServiceMysqlReqBackupMinusSchedule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServiceMysqlReqBackupMinusSchedule from json.
func (o *OptUpdateDbaasServiceMysqlReqBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServiceMysqlReqBackupMinusSchedule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServiceMysqlReqBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServiceMysqlReqBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceMysqlReqMaintenance as json.
func (o OptUpdateDbaasServiceMysqlReqMaintenance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServiceMysqlReqMaintenance from json.
func (o *OptUpdateDbaasServiceMysqlReqMaintenance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServiceMysqlReqMaintenance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServiceMysqlReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServiceMysqlReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceMysqlReqMigration as json.
func (o OptUpdateDbaasServiceMysqlReqMigration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServiceMysqlReqMigration from json.
func (o *OptUpdateDbaasServiceMysqlReqMigration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServiceMysqlReqMigration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServiceMysqlReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServiceMysqlReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm as json.
func (o OptUpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm from json.
func (o *OptUpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceOpensearchReqIndexMinusTemplate as json.
func (o OptUpdateDbaasServiceOpensearchReqIndexMinusTemplate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServiceOpensearchReqIndexMinusTemplate from json.
func (o *OptUpdateDbaasServiceOpensearchReqIndexMinusTemplate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServiceOpensearchReqIndexMinusTemplate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServiceOpensearchReqIndexMinusTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServiceOpensearchReqIndexMinusTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceOpensearchReqMaintenance as json.
func (o OptUpdateDbaasServiceOpensearchReqMaintenance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServiceOpensearchReqMaintenance from json.
func (o *OptUpdateDbaasServiceOpensearchReqMaintenance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServiceOpensearchReqMaintenance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServiceOpensearchReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServiceOpensearchReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceOpensearchReqOpensearchMinusDashboards as json.
func (o OptUpdateDbaasServiceOpensearchReqOpensearchMinusDashboards) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServiceOpensearchReqOpensearchMinusDashboards from json.
func (o *OptUpdateDbaasServiceOpensearchReqOpensearchMinusDashboards) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServiceOpensearchReqOpensearchMinusDashboards to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServiceOpensearchReqOpensearchMinusDashboards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServiceOpensearchReqOpensearchMinusDashboards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServicePgReqBackupMinusSchedule as json.
func (o OptUpdateDbaasServicePgReqBackupMinusSchedule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServicePgReqBackupMinusSchedule from json.
func (o *OptUpdateDbaasServicePgReqBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServicePgReqBackupMinusSchedule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServicePgReqBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServicePgReqBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServicePgReqMaintenance as json.
func (o OptUpdateDbaasServicePgReqMaintenance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServicePgReqMaintenance from json.
func (o *OptUpdateDbaasServicePgReqMaintenance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServicePgReqMaintenance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServicePgReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServicePgReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServicePgReqMigration as json.
func (o OptUpdateDbaasServicePgReqMigration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServicePgReqMigration from json.
func (o *OptUpdateDbaasServicePgReqMigration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServicePgReqMigration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServicePgReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServicePgReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceRedisReqMaintenance as json.
func (o OptUpdateDbaasServiceRedisReqMaintenance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServiceRedisReqMaintenance from json.
func (o *OptUpdateDbaasServiceRedisReqMaintenance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServiceRedisReqMaintenance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServiceRedisReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServiceRedisReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceRedisReqMigration as json.
func (o OptUpdateDbaasServiceRedisReqMigration) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateDbaasServiceRedisReqMigration from json.
func (o *OptUpdateDbaasServiceRedisReqMigration) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateDbaasServiceRedisReqMigration to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateDbaasServiceRedisReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateDbaasServiceRedisReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLoadBalancerServiceReqProtocol as json.
func (o OptUpdateLoadBalancerServiceReqProtocol) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateLoadBalancerServiceReqProtocol from json.
func (o *OptUpdateLoadBalancerServiceReqProtocol) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateLoadBalancerServiceReqProtocol to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateLoadBalancerServiceReqProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateLoadBalancerServiceReqProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLoadBalancerServiceReqStrategy as json.
func (o OptUpdateLoadBalancerServiceReqStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateLoadBalancerServiceReqStrategy from json.
func (o *OptUpdateLoadBalancerServiceReqStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateLoadBalancerServiceReqStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateLoadBalancerServiceReqStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateLoadBalancerServiceReqStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ZoneName as json.
func (o OptZoneName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ZoneName from json.
func (o *OptZoneName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptZoneName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptZoneName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptZoneName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PrivateNetwork) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PrivateNetwork) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Netmask.Set {
			e.FieldStart("netmask")
			s.Netmask.Encode(e)
		}
	}
	{
		if s.StartMinusIP.Set {
			e.FieldStart("start-ip")
			s.StartMinusIP.Encode(e)
		}
	}
	{
		if s.EndMinusIP.Set {
			e.FieldStart("end-ip")
			s.EndMinusIP.Encode(e)
		}
	}
	{
		if s.Leases != nil {
			e.FieldStart("leases")
			e.ArrStart()
			for _, elem := range s.Leases {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfPrivateNetwork = [8]string{
	0: "id",
	1: "name",
	2: "description",
	3: "netmask",
	4: "start-ip",
	5: "end-ip",
	6: "leases",
	7: "labels",
}

// Decode decodes PrivateNetwork from json.
func (s *PrivateNetwork) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PrivateNetwork to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "netmask":
			if err := func() error {
				s.Netmask.Reset()
				if err := s.Netmask.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"netmask\"")
			}
		case "start-ip":
			if err := func() error {
				s.StartMinusIP.Reset()
				if err := s.StartMinusIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start-ip\"")
			}
		case "end-ip":
			if err := func() error {
				s.EndMinusIP.Reset()
				if err := s.EndMinusIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end-ip\"")
			}
		case "leases":
			if err := func() error {
				s.Leases = make([]PrivateNetworkLease, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PrivateNetworkLease
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Leases = append(s.Leases, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"leases\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PrivateNetwork")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PrivateNetwork) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PrivateNetwork) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PrivateNetworkLease) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PrivateNetworkLease) encodeFields(e *jx.Encoder) {
	{
		if s.IP.Set {
			e.FieldStart("ip")
			s.IP.Encode(e)
		}
	}
	{
		if s.InstanceMinusID.Set {
			e.FieldStart("instance-id")
			s.InstanceMinusID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPrivateNetworkLease = [2]string{
	0: "ip",
	1: "instance-id",
}

// Decode decodes PrivateNetworkLease from json.
func (s *PrivateNetworkLease) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PrivateNetworkLease to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ip":
			if err := func() error {
				s.IP.Reset()
				if err := s.IP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip\"")
			}
		case "instance-id":
			if err := func() error {
				s.InstanceMinusID.Reset()
				if err := s.InstanceMinusID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance-id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PrivateNetworkLease")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PrivateNetworkLease) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PrivateNetworkLease) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PromoteSnapshotToTemplateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PromoteSnapshotToTemplateReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.DefaultMinusUser.Set {
			e.FieldStart("default-user")
			s.DefaultMinusUser.Encode(e)
		}
	}
	{
		if s.SSHMinusKeyMinusEnabled.Set {
			e.FieldStart("ssh-key-enabled")
			s.SSHMinusKeyMinusEnabled.Encode(e)
		}
	}
	{
		if s.PasswordMinusEnabled.Set {
			e.FieldStart("password-enabled")
			s.PasswordMinusEnabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfPromoteSnapshotToTemplateReq = [5]string{
	0: "name",
	1: "description",
	2: "default-user",
	3: "ssh-key-enabled",
	4: "password-enabled",
}

// Decode decodes PromoteSnapshotToTemplateReq from json.
func (s *PromoteSnapshotToTemplateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PromoteSnapshotToTemplateReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "default-user":
			if err := func() error {
				s.DefaultMinusUser.Reset()
				if err := s.DefaultMinusUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default-user\"")
			}
		case "ssh-key-enabled":
			if err := func() error {
				s.SSHMinusKeyMinusEnabled.Reset()
				if err := s.SSHMinusKeyMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh-key-enabled\"")
			}
		case "password-enabled":
			if err := func() error {
				s.PasswordMinusEnabled.Reset()
				if err := s.PasswordMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password-enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PromoteSnapshotToTemplateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPromoteSnapshotToTemplateReq) {
					name = jsonFieldsNameOfPromoteSnapshotToTemplateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PromoteSnapshotToTemplateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PromoteSnapshotToTemplateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicIPAssignment as json.
func (s PublicIPAssignment) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PublicIPAssignment from json.
func (s *PublicIPAssignment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicIPAssignment to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PublicIPAssignment(v) {
	case PublicIPAssignmentInet4:
		*s = PublicIPAssignmentInet4
	case PublicIPAssignmentDual:
		*s = PublicIPAssignmentDual
	case PublicIPAssignmentNone:
		*s = PublicIPAssignmentNone
	default:
		*s = PublicIPAssignment(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PublicIPAssignment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicIPAssignment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Quota) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Quota) encodeFields(e *jx.Encoder) {
	{
		if s.Resource.Set {
			e.FieldStart("resource")
			s.Resource.Encode(e)
		}
	}
	{
		if s.Usage.Set {
			e.FieldStart("usage")
			s.Usage.Encode(e)
		}
	}
	{
		if s.Limit.Set {
			e.FieldStart("limit")
			s.Limit.Encode(e)
		}
	}
}

var jsonFieldsNameOfQuota = [3]string{
	0: "resource",
	1: "usage",
	2: "limit",
}

// Decode decodes Quota from json.
func (s *Quota) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Quota to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "resource":
			if err := func() error {
				s.Resource.Reset()
				if err := s.Resource.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resource\"")
			}
		case "usage":
			if err := func() error {
				s.Usage.Reset()
				if err := s.Usage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usage\"")
			}
		case "limit":
			if err := func() error {
				s.Limit.Reset()
				if err := s.Limit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Quota")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Quota) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Quota) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterSSHKeyReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterSSHKeyReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("public-key")
		e.Str(s.PublicMinusKey)
	}
}

var jsonFieldsNameOfRegisterSSHKeyReq = [2]string{
	0: "name",
	1: "public-key",
}

// Decode decodes RegisterSSHKeyReq from json.
func (s *RegisterSSHKeyReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterSSHKeyReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "public-key":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PublicMinusKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public-key\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterSSHKeyReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterSSHKeyReq) {
					name = jsonFieldsNameOfRegisterSSHKeyReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterSSHKeyReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterSSHKeyReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterTemplateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterTemplateReq) encodeFields(e *jx.Encoder) {
	{
		if s.Maintainer.Set {
			e.FieldStart("maintainer")
			s.Maintainer.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("ssh-key-enabled")
		e.Bool(s.SSHMinusKeyMinusEnabled)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.DefaultMinusUser.Set {
			e.FieldStart("default-user")
			s.DefaultMinusUser.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		e.FieldStart("password-enabled")
		e.Bool(s.PasswordMinusEnabled)
	}
	{
		if s.Build.Set {
			e.FieldStart("build")
			s.Build.Encode(e)
		}
	}
	{
		e.FieldStart("checksum")
		e.Str(s.Checksum)
	}
	{
		if s.BootMinusMode.Set {
			e.FieldStart("boot-mode")
			s.BootMinusMode.Encode(e)
		}
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegisterTemplateReq = [12]string{
	0:  "maintainer",
	1:  "description",
	2:  "ssh-key-enabled",
	3:  "name",
	4:  "default-user",
	5:  "size",
	6:  "password-enabled",
	7:  "build",
	8:  "checksum",
	9:  "boot-mode",
	10: "url",
	11: "version",
}

// Decode decodes RegisterTemplateReq from json.
func (s *RegisterTemplateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterTemplateReq to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maintainer":
			if err := func() error {
				s.Maintainer.Reset()
				if err := s.Maintainer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainer\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "ssh-key-enabled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.SSHMinusKeyMinusEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh-key-enabled\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "default-user":
			if err := func() error {
				s.DefaultMinusUser.Reset()
				if err := s.DefaultMinusUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default-user\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "password-enabled":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.PasswordMinusEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password-enabled\"")
			}
		case "build":
			if err := func() error {
				s.Build.Reset()
				if err := s.Build.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"build\"")
			}
		case "checksum":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Checksum = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checksum\"")
			}
		case "boot-mode":
			if err := func() error {
				s.BootMinusMode.Reset()
				if err := s.BootMinusMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boot-mode\"")
			}
		case "url":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterTemplateReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b01001100,
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterTemplateReq) {
					name = jsonFieldsNameOfRegisterTemplateReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterTemplateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterTemplateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegisterTemplateReqBootMinusMode as json.
func (s RegisterTemplateReqBootMinusMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RegisterTemplateReqBootMinusMode from json.
func (s *RegisterTemplateReqBootMinusMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterTemplateReqBootMinusMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RegisterTemplateReqBootMinusMode(v) {
	case RegisterTemplateReqBootMinusModeLegacy:
		*s = RegisterTemplateReqBootMinusModeLegacy
	case RegisterTemplateReqBootMinusModeUefi:
		*s = RegisterTemplateReqBootMinusModeUefi
	default:
		*s = RegisterTemplateReqBootMinusMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RegisterTemplateReqBootMinusMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterTemplateReqBootMinusMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveExternalSourceFromSecurityGroupReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveExternalSourceFromSecurityGroupReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cidr")
		e.Str(s.Cidr)
	}
}

var jsonFieldsNameOfRemoveExternalSourceFromSecurityGroupReq = [1]string{
	0: "cidr",
}

// Decode decodes RemoveExternalSourceFromSecurityGroupReq from json.
func (s *RemoveExternalSourceFromSecurityGroupReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveExternalSourceFromSecurityGroupReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cidr":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Cidr = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cidr\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveExternalSourceFromSecurityGroupReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveExternalSourceFromSecurityGroupReq) {
					name = jsonFieldsNameOfRemoveExternalSourceFromSecurityGroupReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveExternalSourceFromSecurityGroupReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveExternalSourceFromSecurityGroupReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveInstanceProtectionOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveInstanceProtectionOK) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRemoveInstanceProtectionOK = [0]string{}

// Decode decodes RemoveInstanceProtectionOK from json.
func (s *RemoveInstanceProtectionOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveInstanceProtectionOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveInstanceProtectionOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveInstanceProtectionOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveInstanceProtectionOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetDbaasKafkaUserPasswordReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetDbaasKafkaUserPasswordReq) encodeFields(e *jx.Encoder) {
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfResetDbaasKafkaUserPasswordReq = [1]string{
	0: "password",
}

// Decode decodes ResetDbaasKafkaUserPasswordReq from json.
func (s *ResetDbaasKafkaUserPasswordReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetDbaasKafkaUserPasswordReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetDbaasKafkaUserPasswordReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetDbaasKafkaUserPasswordReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetDbaasKafkaUserPasswordReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetDbaasPostgresUserPasswordReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetDbaasPostgresUserPasswordReq) encodeFields(e *jx.Encoder) {
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
}

var jsonFieldsNameOfResetDbaasPostgresUserPasswordReq = [1]string{
	0: "password",
}

// Decode decodes ResetDbaasPostgresUserPasswordReq from json.
func (s *ResetDbaasPostgresUserPasswordReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetDbaasPostgresUserPasswordReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetDbaasPostgresUserPasswordReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetDbaasPostgresUserPasswordReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetDbaasPostgresUserPasswordReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetInstanceReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetInstanceReq) encodeFields(e *jx.Encoder) {
	{
		if s.Template.Set {
			e.FieldStart("template")
			s.Template.Encode(e)
		}
	}
	{
		if s.DiskMinusSize.Set {
			e.FieldStart("disk-size")
			s.DiskMinusSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfResetInstanceReq = [2]string{
	0: "template",
	1: "disk-size",
}

// Decode decodes ResetInstanceReq from json.
func (s *ResetInstanceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetInstanceReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "template":
			if err := func() error {
				s.Template.Reset()
				if err := s.Template.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"template\"")
			}
		case "disk-size":
			if err := func() error {
				s.DiskMinusSize.Reset()
				if err := s.DiskMinusSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk-size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetInstanceReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetInstanceReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetInstanceReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResizeInstanceDiskReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResizeInstanceDiskReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("disk-size")
		e.Int64(s.DiskMinusSize)
	}
}

var jsonFieldsNameOfResizeInstanceDiskReq = [1]string{
	0: "disk-size",
}

// Decode decodes ResizeInstanceDiskReq from json.
func (s *ResizeInstanceDiskReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResizeInstanceDiskReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "disk-size":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.DiskMinusSize = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disk-size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResizeInstanceDiskReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResizeInstanceDiskReq) {
					name = jsonFieldsNameOfResizeInstanceDiskReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResizeInstanceDiskReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResizeInstanceDiskReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReverseDNSRecord) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReverseDNSRecord) encodeFields(e *jx.Encoder) {
	{
		if s.DomainMinusName.Set {
			e.FieldStart("domain-name")
			s.DomainMinusName.Encode(e)
		}
	}
}

var jsonFieldsNameOfReverseDNSRecord = [1]string{
	0: "domain-name",
}

// Decode decodes ReverseDNSRecord from json.
func (s *ReverseDNSRecord) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReverseDNSRecord to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain-name":
			if err := func() error {
				s.DomainMinusName.Reset()
				if err := s.DomainMinusName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain-name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReverseDNSRecord")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReverseDNSRecord) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReverseDNSRecord) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevertInstanceToSnapshotReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevertInstanceToSnapshotReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
}

var jsonFieldsNameOfRevertInstanceToSnapshotReq = [1]string{
	0: "id",
}

// Decode decodes RevertInstanceToSnapshotReq from json.
func (s *RevertInstanceToSnapshotReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevertInstanceToSnapshotReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevertInstanceToSnapshotReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevertInstanceToSnapshotReq) {
					name = jsonFieldsNameOfRevertInstanceToSnapshotReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevertInstanceToSnapshotReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevertInstanceToSnapshotReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SSHKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SSHKey) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
}

var jsonFieldsNameOfSSHKey = [2]string{
	0: "name",
	1: "fingerprint",
}

// Decode decodes SSHKey from json.
func (s *SSHKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SSHKey to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SSHKey")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SSHKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SSHKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScaleInstancePoolReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScaleInstancePoolReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("size")
		e.Int64(s.Size)
	}
}

var jsonFieldsNameOfScaleInstancePoolReq = [1]string{
	0: "size",
}

// Decode decodes ScaleInstancePoolReq from json.
func (s *ScaleInstancePoolReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScaleInstancePoolReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "size":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.Size = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScaleInstancePoolReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScaleInstancePoolReq) {
					name = jsonFieldsNameOfScaleInstancePoolReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScaleInstancePoolReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScaleInstancePoolReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScaleInstanceReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScaleInstanceReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("instance-type")
		s.InstanceMinusType.Encode(e)
	}
}

var jsonFieldsNameOfScaleInstanceReq = [1]string{
	0: "instance-type",
}

// Decode decodes ScaleInstanceReq from json.
func (s *ScaleInstanceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScaleInstanceReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "instance-type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.InstanceMinusType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance-type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScaleInstanceReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScaleInstanceReq) {
					name = jsonFieldsNameOfScaleInstanceReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScaleInstanceReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScaleInstanceReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ScaleSksNodepoolReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ScaleSksNodepoolReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("size")
		e.Int64(s.Size)
	}
}

var jsonFieldsNameOfScaleSksNodepoolReq = [1]string{
	0: "size",
}

// Decode decodes ScaleSksNodepoolReq from json.
func (s *ScaleSksNodepoolReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScaleSksNodepoolReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "size":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int64()
				s.Size = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ScaleSksNodepoolReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfScaleSksNodepoolReq) {
					name = jsonFieldsNameOfScaleSksNodepoolReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ScaleSksNodepoolReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScaleSksNodepoolReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecurityGroupResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecurityGroupResource) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
}

var jsonFieldsNameOfSecurityGroupResource = [3]string{
	0: "id",
	1: "name",
	2: "visibility",
}

// Decode decodes SecurityGroupResource from json.
func (s *SecurityGroupResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecurityGroupResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecurityGroupResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecurityGroupResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecurityGroupResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecurityGroupResourceVisibility as json.
func (s SecurityGroupResourceVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SecurityGroupResourceVisibility from json.
func (s *SecurityGroupResourceVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecurityGroupResourceVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SecurityGroupResourceVisibility(v) {
	case SecurityGroupResourceVisibilityPrivate:
		*s = SecurityGroupResourceVisibilityPrivate
	case SecurityGroupResourceVisibilityPublic:
		*s = SecurityGroupResourceVisibilityPublic
	default:
		*s = SecurityGroupResourceVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecurityGroupResourceVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecurityGroupResourceVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SksClusterDeprecatedResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SksClusterDeprecatedResource) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SksClusterDeprecatedResource from json.
func (s *SksClusterDeprecatedResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SksClusterDeprecatedResource to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SksClusterDeprecatedResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SksClusterDeprecatedResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SksClusterDeprecatedResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SksKubeconfigRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SksKubeconfigRequest) encodeFields(e *jx.Encoder) {
	{
		if s.TTL.Set {
			e.FieldStart("ttl")
			s.TTL.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSksKubeconfigRequest = [3]string{
	0: "ttl",
	1: "user",
	2: "groups",
}

// Decode decodes SksKubeconfigRequest from json.
func (s *SksKubeconfigRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SksKubeconfigRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ttl":
			if err := func() error {
				s.TTL.Reset()
				if err := s.TTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttl\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SksKubeconfigRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SksKubeconfigRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SksKubeconfigRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SksOidc) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SksOidc) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("client-id")
		e.Str(s.ClientMinusID)
	}
	{
		e.FieldStart("issuer-url")
		e.Str(s.IssuerMinusURL)
	}
	{
		if s.UsernameMinusClaim.Set {
			e.FieldStart("username-claim")
			s.UsernameMinusClaim.Encode(e)
		}
	}
	{
		if s.UsernameMinusPrefix.Set {
			e.FieldStart("username-prefix")
			s.UsernameMinusPrefix.Encode(e)
		}
	}
	{
		if s.GroupsMinusClaim.Set {
			e.FieldStart("groups-claim")
			s.GroupsMinusClaim.Encode(e)
		}
	}
	{
		if s.GroupsMinusPrefix.Set {
			e.FieldStart("groups-prefix")
			s.GroupsMinusPrefix.Encode(e)
		}
	}
	{
		if s.RequiredMinusClaim.Set {
			e.FieldStart("required-claim")
			s.RequiredMinusClaim.Encode(e)
		}
	}
}

var jsonFieldsNameOfSksOidc = [7]string{
	0: "client-id",
	1: "issuer-url",
	2: "username-claim",
	3: "username-prefix",
	4: "groups-claim",
	5: "groups-prefix",
	6: "required-claim",
}

// Decode decodes SksOidc from json.
func (s *SksOidc) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SksOidc to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "client-id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ClientMinusID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client-id\"")
			}
		case "issuer-url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.IssuerMinusURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuer-url\"")
			}
		case "username-claim":
			if err := func() error {
				s.UsernameMinusClaim.Reset()
				if err := s.UsernameMinusClaim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username-claim\"")
			}
		case "username-prefix":
			if err := func() error {
				s.UsernameMinusPrefix.Reset()
				if err := s.UsernameMinusPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username-prefix\"")
			}
		case "groups-claim":
			if err := func() error {
				s.GroupsMinusClaim.Reset()
				if err := s.GroupsMinusClaim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups-claim\"")
			}
		case "groups-prefix":
			if err := func() error {
				s.GroupsMinusPrefix.Reset()
				if err := s.GroupsMinusPrefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups-prefix\"")
			}
		case "required-claim":
			if err := func() error {
				s.RequiredMinusClaim.Reset()
				if err := s.RequiredMinusClaim.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required-claim\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SksOidc")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSksOidc) {
					name = jsonFieldsNameOfSksOidc[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SksOidc) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SksOidc) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SksOidcRequiredMinusClaim) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SksOidcRequiredMinusClaim) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SksOidcRequiredMinusClaim from json.
func (s *SksOidcRequiredMinusClaim) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SksOidcRequiredMinusClaim to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SksOidcRequiredMinusClaim")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SksOidcRequiredMinusClaim) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SksOidcRequiredMinusClaim) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SosBucketUsage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SosBucketUsage) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.CreatedMinusAt.Set {
			e.FieldStart("created-at")
			s.CreatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ZoneMinusName.Set {
			e.FieldStart("zone-name")
			s.ZoneMinusName.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
}

var jsonFieldsNameOfSosBucketUsage = [4]string{
	0: "name",
	1: "created-at",
	2: "zone-name",
	3: "size",
}

// Decode decodes SosBucketUsage from json.
func (s *SosBucketUsage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SosBucketUsage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "created-at":
			if err := func() error {
				s.CreatedMinusAt.Reset()
				if err := s.CreatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created-at\"")
			}
		case "zone-name":
			if err := func() error {
				s.ZoneMinusName.Reset()
				if err := s.ZoneMinusName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zone-name\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SosBucketUsage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SosBucketUsage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SosBucketUsage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StartInstanceReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StartInstanceReq) encodeFields(e *jx.Encoder) {
	{
		if s.RescueMinusProfile.Set {
			e.FieldStart("rescue-profile")
			s.RescueMinusProfile.Encode(e)
		}
	}
}

var jsonFieldsNameOfStartInstanceReq = [1]string{
	0: "rescue-profile",
}

// Decode decodes StartInstanceReq from json.
func (s *StartInstanceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartInstanceReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rescue-profile":
			if err := func() error {
				s.RescueMinusProfile.Reset()
				if err := s.RescueMinusProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rescue-profile\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StartInstanceReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StartInstanceReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartInstanceReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StartInstanceReqRescueMinusProfile as json.
func (s StartInstanceReqRescueMinusProfile) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StartInstanceReqRescueMinusProfile from json.
func (s *StartInstanceReqRescueMinusProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StartInstanceReqRescueMinusProfile to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StartInstanceReqRescueMinusProfile(v) {
	case StartInstanceReqRescueMinusProfileNetbootEfi:
		*s = StartInstanceReqRescueMinusProfileNetbootEfi
	case StartInstanceReqRescueMinusProfileNetboot:
		*s = StartInstanceReqRescueMinusProfileNetboot
	default:
		*s = StartInstanceReqRescueMinusProfile(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StartInstanceReqRescueMinusProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StartInstanceReqRescueMinusProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Template) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Template) encodeFields(e *jx.Encoder) {
	{
		if s.Maintainer.Set {
			e.FieldStart("maintainer")
			s.Maintainer.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.SSHMinusKeyMinusEnabled.Set {
			e.FieldStart("ssh-key-enabled")
			s.SSHMinusKeyMinusEnabled.Encode(e)
		}
	}
	{
		if s.Family.Set {
			e.FieldStart("family")
			s.Family.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.DefaultMinusUser.Set {
			e.FieldStart("default-user")
			s.DefaultMinusUser.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
	{
		if s.PasswordMinusEnabled.Set {
			e.FieldStart("password-enabled")
			s.PasswordMinusEnabled.Encode(e)
		}
	}
	{
		if s.Build.Set {
			e.FieldStart("build")
			s.Build.Encode(e)
		}
	}
	{
		if s.Checksum.Set {
			e.FieldStart("checksum")
			s.Checksum.Encode(e)
		}
	}
	{
		if s.BootMinusMode.Set {
			e.FieldStart("boot-mode")
			s.BootMinusMode.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Zones != nil {
			e.FieldStart("zones")
			e.ArrStart()
			for _, elem := range s.Zones {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.CreatedMinusAt.Set {
			e.FieldStart("created-at")
			s.CreatedMinusAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Visibility.Set {
			e.FieldStart("visibility")
			s.Visibility.Encode(e)
		}
	}
}

var jsonFieldsNameOfTemplate = [17]string{
	0:  "maintainer",
	1:  "description",
	2:  "ssh-key-enabled",
	3:  "family",
	4:  "name",
	5:  "default-user",
	6:  "size",
	7:  "password-enabled",
	8:  "build",
	9:  "checksum",
	10: "boot-mode",
	11: "id",
	12: "zones",
	13: "url",
	14: "version",
	15: "created-at",
	16: "visibility",
}

// Decode decodes Template from json.
func (s *Template) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Template to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maintainer":
			if err := func() error {
				s.Maintainer.Reset()
				if err := s.Maintainer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintainer\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "ssh-key-enabled":
			if err := func() error {
				s.SSHMinusKeyMinusEnabled.Reset()
				if err := s.SSHMinusKeyMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssh-key-enabled\"")
			}
		case "family":
			if err := func() error {
				s.Family.Reset()
				if err := s.Family.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"family\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "default-user":
			if err := func() error {
				s.DefaultMinusUser.Reset()
				if err := s.DefaultMinusUser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default-user\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "password-enabled":
			if err := func() error {
				s.PasswordMinusEnabled.Reset()
				if err := s.PasswordMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password-enabled\"")
			}
		case "build":
			if err := func() error {
				s.Build.Reset()
				if err := s.Build.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"build\"")
			}
		case "checksum":
			if err := func() error {
				s.Checksum.Reset()
				if err := s.Checksum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checksum\"")
			}
		case "boot-mode":
			if err := func() error {
				s.BootMinusMode.Reset()
				if err := s.BootMinusMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boot-mode\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "zones":
			if err := func() error {
				s.Zones = make([]ZoneName, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ZoneName
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Zones = append(s.Zones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zones\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "created-at":
			if err := func() error {
				s.CreatedMinusAt.Reset()
				if err := s.CreatedMinusAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created-at\"")
			}
		case "visibility":
			if err := func() error {
				s.Visibility.Reset()
				if err := s.Visibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"visibility\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Template")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Template) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Template) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TemplateBootMinusMode as json.
func (s TemplateBootMinusMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TemplateBootMinusMode from json.
func (s *TemplateBootMinusMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TemplateBootMinusMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TemplateBootMinusMode(v) {
	case TemplateBootMinusModeLegacy:
		*s = TemplateBootMinusModeLegacy
	case TemplateBootMinusModeUefi:
		*s = TemplateBootMinusModeUefi
	default:
		*s = TemplateBootMinusMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TemplateBootMinusMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TemplateBootMinusMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TemplateVisibility as json.
func (s TemplateVisibility) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TemplateVisibility from json.
func (s *TemplateVisibility) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TemplateVisibility to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TemplateVisibility(v) {
	case TemplateVisibilityPrivate:
		*s = TemplateVisibilityPrivate
	case TemplateVisibilityPublic:
		*s = TemplateVisibilityPublic
	default:
		*s = TemplateVisibility(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TemplateVisibility) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TemplateVisibility) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDNSDomainRecordReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDNSDomainRecordReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.TTL.Set {
			e.FieldStart("ttl")
			s.TTL.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDNSDomainRecordReq = [4]string{
	0: "name",
	1: "content",
	2: "ttl",
	3: "priority",
}

// Decode decodes UpdateDNSDomainRecordReq from json.
func (s *UpdateDNSDomainRecordReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDNSDomainRecordReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "ttl":
			if err := func() error {
				s.TTL.Reset()
				if err := s.TTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ttl\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDNSDomainRecordReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDNSDomainRecordReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDNSDomainRecordReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasIntegrationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasIntegrationReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("settings")
		s.Settings.Encode(e)
	}
}

var jsonFieldsNameOfUpdateDbaasIntegrationReq = [1]string{
	0: "settings",
}

// Decode decodes UpdateDbaasIntegrationReq from json.
func (s *UpdateDbaasIntegrationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasIntegrationReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "settings":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasIntegrationReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateDbaasIntegrationReq) {
					name = jsonFieldsNameOfUpdateDbaasIntegrationReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasIntegrationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasIntegrationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasIntegrationReqSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasIntegrationReqSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasIntegrationReqSettings = [0]string{}

// Decode decodes UpdateDbaasIntegrationReqSettings from json.
func (s *UpdateDbaasIntegrationReqSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasIntegrationReqSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasIntegrationReqSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasIntegrationReqSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasIntegrationReqSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasPostgresAllowReplicationReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasPostgresAllowReplicationReq) encodeFields(e *jx.Encoder) {
	{
		if s.AllowMinusReplication.Set {
			e.FieldStart("allow-replication")
			s.AllowMinusReplication.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasPostgresAllowReplicationReq = [1]string{
	0: "allow-replication",
}

// Decode decodes UpdateDbaasPostgresAllowReplicationReq from json.
func (s *UpdateDbaasPostgresAllowReplicationReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasPostgresAllowReplicationReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allow-replication":
			if err := func() error {
				s.AllowMinusReplication.Reset()
				if err := s.AllowMinusReplication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow-replication\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasPostgresAllowReplicationReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasPostgresAllowReplicationReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasPostgresAllowReplicationReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceKafkaReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceKafkaReq) encodeFields(e *jx.Encoder) {
	{
		if s.AuthenticationMinusMethods.Set {
			e.FieldStart("authentication-methods")
			s.AuthenticationMinusMethods.Encode(e)
		}
	}
	{
		if s.KafkaMinusRestMinusEnabled.Set {
			e.FieldStart("kafka-rest-enabled")
			s.KafkaMinusRestMinusEnabled.Encode(e)
		}
	}
	{
		if s.KafkaMinusConnectMinusEnabled.Set {
			e.FieldStart("kafka-connect-enabled")
			s.KafkaMinusConnectMinusEnabled.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SchemaMinusRegistryMinusSettings != nil {
			e.FieldStart("schema-registry-settings")
			s.SchemaMinusRegistryMinusSettings.Encode(e)
		}
	}
	{
		if s.KafkaMinusRestMinusSettings != nil {
			e.FieldStart("kafka-rest-settings")
			s.KafkaMinusRestMinusSettings.Encode(e)
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.KafkaMinusConnectMinusSettings != nil {
			e.FieldStart("kafka-connect-settings")
			s.KafkaMinusConnectMinusSettings.Encode(e)
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.KafkaMinusSettings != nil {
			e.FieldStart("kafka-settings")
			s.KafkaMinusSettings.Encode(e)
		}
	}
	{
		if s.SchemaMinusRegistryMinusEnabled.Set {
			e.FieldStart("schema-registry-enabled")
			s.SchemaMinusRegistryMinusEnabled.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServiceKafkaReq = [12]string{
	0:  "authentication-methods",
	1:  "kafka-rest-enabled",
	2:  "kafka-connect-enabled",
	3:  "ip-filter",
	4:  "schema-registry-settings",
	5:  "kafka-rest-settings",
	6:  "termination-protection",
	7:  "kafka-connect-settings",
	8:  "maintenance",
	9:  "kafka-settings",
	10: "schema-registry-enabled",
	11: "plan",
}

// Decode decodes UpdateDbaasServiceKafkaReq from json.
func (s *UpdateDbaasServiceKafkaReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceKafkaReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "authentication-methods":
			if err := func() error {
				s.AuthenticationMinusMethods.Reset()
				if err := s.AuthenticationMinusMethods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authentication-methods\"")
			}
		case "kafka-rest-enabled":
			if err := func() error {
				s.KafkaMinusRestMinusEnabled.Reset()
				if err := s.KafkaMinusRestMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-rest-enabled\"")
			}
		case "kafka-connect-enabled":
			if err := func() error {
				s.KafkaMinusConnectMinusEnabled.Reset()
				if err := s.KafkaMinusConnectMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-connect-enabled\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "schema-registry-settings":
			if err := func() error {
				s.SchemaMinusRegistryMinusSettings = nil
				var elem UpdateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.SchemaMinusRegistryMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema-registry-settings\"")
			}
		case "kafka-rest-settings":
			if err := func() error {
				s.KafkaMinusRestMinusSettings = nil
				var elem UpdateDbaasServiceKafkaReqKafkaMinusRestMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.KafkaMinusRestMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-rest-settings\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "kafka-connect-settings":
			if err := func() error {
				s.KafkaMinusConnectMinusSettings = nil
				var elem UpdateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.KafkaMinusConnectMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-connect-settings\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "kafka-settings":
			if err := func() error {
				s.KafkaMinusSettings = nil
				var elem UpdateDbaasServiceKafkaReqKafkaMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.KafkaMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kafka-settings\"")
			}
		case "schema-registry-enabled":
			if err := func() error {
				s.SchemaMinusRegistryMinusEnabled.Reset()
				if err := s.SchemaMinusRegistryMinusEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema-registry-enabled\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceKafkaReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceKafkaReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceKafkaReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceKafkaReqAuthenticationMinusMethods) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceKafkaReqAuthenticationMinusMethods) encodeFields(e *jx.Encoder) {
	{
		if s.Certificate.Set {
			e.FieldStart("certificate")
			s.Certificate.Encode(e)
		}
	}
	{
		if s.Sasl.Set {
			e.FieldStart("sasl")
			s.Sasl.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServiceKafkaReqAuthenticationMinusMethods = [2]string{
	0: "certificate",
	1: "sasl",
}

// Decode decodes UpdateDbaasServiceKafkaReqAuthenticationMinusMethods from json.
func (s *UpdateDbaasServiceKafkaReqAuthenticationMinusMethods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceKafkaReqAuthenticationMinusMethods to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificate":
			if err := func() error {
				s.Certificate.Reset()
				if err := s.Certificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		case "sasl":
			if err := func() error {
				s.Sasl.Reset()
				if err := s.Sasl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sasl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceKafkaReqAuthenticationMinusMethods")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceKafkaReqAuthenticationMinusMethods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceKafkaReqAuthenticationMinusMethods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings = [0]string{}

// Decode decodes UpdateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings from json.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusConnectMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusRestMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusRestMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasServiceKafkaReqKafkaMinusRestMinusSettings = [0]string{}

// Decode decodes UpdateDbaasServiceKafkaReqKafkaMinusRestMinusSettings from json.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusRestMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceKafkaReqKafkaMinusRestMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceKafkaReqKafkaMinusRestMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusRestMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusRestMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasServiceKafkaReqKafkaMinusSettings = [0]string{}

// Decode decodes UpdateDbaasServiceKafkaReqKafkaMinusSettings from json.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceKafkaReqKafkaMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceKafkaReqKafkaMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceKafkaReqKafkaMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceKafkaReqMaintenance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceKafkaReqMaintenance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dow")
		s.Dow.Encode(e)
	}
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfUpdateDbaasServiceKafkaReqMaintenance = [2]string{
	0: "dow",
	1: "time",
}

// Decode decodes UpdateDbaasServiceKafkaReqMaintenance from json.
func (s *UpdateDbaasServiceKafkaReqMaintenance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceKafkaReqMaintenance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dow":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dow\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceKafkaReqMaintenance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateDbaasServiceKafkaReqMaintenance) {
					name = jsonFieldsNameOfUpdateDbaasServiceKafkaReqMaintenance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceKafkaReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceKafkaReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceKafkaReqMaintenanceDow as json.
func (s UpdateDbaasServiceKafkaReqMaintenanceDow) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateDbaasServiceKafkaReqMaintenanceDow from json.
func (s *UpdateDbaasServiceKafkaReqMaintenanceDow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceKafkaReqMaintenanceDow to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateDbaasServiceKafkaReqMaintenanceDow(v) {
	case UpdateDbaasServiceKafkaReqMaintenanceDowSaturday:
		*s = UpdateDbaasServiceKafkaReqMaintenanceDowSaturday
	case UpdateDbaasServiceKafkaReqMaintenanceDowTuesday:
		*s = UpdateDbaasServiceKafkaReqMaintenanceDowTuesday
	case UpdateDbaasServiceKafkaReqMaintenanceDowNever:
		*s = UpdateDbaasServiceKafkaReqMaintenanceDowNever
	case UpdateDbaasServiceKafkaReqMaintenanceDowWednesday:
		*s = UpdateDbaasServiceKafkaReqMaintenanceDowWednesday
	case UpdateDbaasServiceKafkaReqMaintenanceDowSunday:
		*s = UpdateDbaasServiceKafkaReqMaintenanceDowSunday
	case UpdateDbaasServiceKafkaReqMaintenanceDowFriday:
		*s = UpdateDbaasServiceKafkaReqMaintenanceDowFriday
	case UpdateDbaasServiceKafkaReqMaintenanceDowMonday:
		*s = UpdateDbaasServiceKafkaReqMaintenanceDowMonday
	case UpdateDbaasServiceKafkaReqMaintenanceDowThursday:
		*s = UpdateDbaasServiceKafkaReqMaintenanceDowThursday
	default:
		*s = UpdateDbaasServiceKafkaReqMaintenanceDow(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateDbaasServiceKafkaReqMaintenanceDow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceKafkaReqMaintenanceDow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings = [0]string{}

// Decode decodes UpdateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings from json.
func (s *UpdateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceKafkaReqSchemaMinusRegistryMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceMysqlReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceMysqlReq) encodeFields(e *jx.Encoder) {
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MysqlMinusSettings != nil {
			e.FieldStart("mysql-settings")
			s.MysqlMinusSettings.Encode(e)
		}
	}
	{
		if s.Migration.Set {
			e.FieldStart("migration")
			s.Migration.Encode(e)
		}
	}
	{
		if s.BinlogMinusRetentionMinusPeriod.Set {
			e.FieldStart("binlog-retention-period")
			s.BinlogMinusRetentionMinusPeriod.Encode(e)
		}
	}
	{
		if s.BackupMinusSchedule.Set {
			e.FieldStart("backup-schedule")
			s.BackupMinusSchedule.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServiceMysqlReq = [8]string{
	0: "maintenance",
	1: "plan",
	2: "termination-protection",
	3: "ip-filter",
	4: "mysql-settings",
	5: "migration",
	6: "binlog-retention-period",
	7: "backup-schedule",
}

// Decode decodes UpdateDbaasServiceMysqlReq from json.
func (s *UpdateDbaasServiceMysqlReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceMysqlReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "mysql-settings":
			if err := func() error {
				s.MysqlMinusSettings = nil
				var elem UpdateDbaasServiceMysqlReqMysqlMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.MysqlMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mysql-settings\"")
			}
		case "migration":
			if err := func() error {
				s.Migration.Reset()
				if err := s.Migration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migration\"")
			}
		case "binlog-retention-period":
			if err := func() error {
				s.BinlogMinusRetentionMinusPeriod.Reset()
				if err := s.BinlogMinusRetentionMinusPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"binlog-retention-period\"")
			}
		case "backup-schedule":
			if err := func() error {
				s.BackupMinusSchedule.Reset()
				if err := s.BackupMinusSchedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-schedule\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceMysqlReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceMysqlReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceMysqlReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceMysqlReqBackupMinusSchedule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceMysqlReqBackupMinusSchedule) encodeFields(e *jx.Encoder) {
	{
		if s.BackupMinusHour.Set {
			e.FieldStart("backup-hour")
			s.BackupMinusHour.Encode(e)
		}
	}
	{
		if s.BackupMinusMinute.Set {
			e.FieldStart("backup-minute")
			s.BackupMinusMinute.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServiceMysqlReqBackupMinusSchedule = [2]string{
	0: "backup-hour",
	1: "backup-minute",
}

// Decode decodes UpdateDbaasServiceMysqlReqBackupMinusSchedule from json.
func (s *UpdateDbaasServiceMysqlReqBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceMysqlReqBackupMinusSchedule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backup-hour":
			if err := func() error {
				s.BackupMinusHour.Reset()
				if err := s.BackupMinusHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-hour\"")
			}
		case "backup-minute":
			if err := func() error {
				s.BackupMinusMinute.Reset()
				if err := s.BackupMinusMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-minute\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceMysqlReqBackupMinusSchedule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceMysqlReqBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceMysqlReqBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceMysqlReqMaintenance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceMysqlReqMaintenance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dow")
		s.Dow.Encode(e)
	}
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfUpdateDbaasServiceMysqlReqMaintenance = [2]string{
	0: "dow",
	1: "time",
}

// Decode decodes UpdateDbaasServiceMysqlReqMaintenance from json.
func (s *UpdateDbaasServiceMysqlReqMaintenance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceMysqlReqMaintenance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dow":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dow\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceMysqlReqMaintenance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateDbaasServiceMysqlReqMaintenance) {
					name = jsonFieldsNameOfUpdateDbaasServiceMysqlReqMaintenance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceMysqlReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceMysqlReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceMysqlReqMaintenanceDow as json.
func (s UpdateDbaasServiceMysqlReqMaintenanceDow) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateDbaasServiceMysqlReqMaintenanceDow from json.
func (s *UpdateDbaasServiceMysqlReqMaintenanceDow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceMysqlReqMaintenanceDow to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateDbaasServiceMysqlReqMaintenanceDow(v) {
	case UpdateDbaasServiceMysqlReqMaintenanceDowSaturday:
		*s = UpdateDbaasServiceMysqlReqMaintenanceDowSaturday
	case UpdateDbaasServiceMysqlReqMaintenanceDowTuesday:
		*s = UpdateDbaasServiceMysqlReqMaintenanceDowTuesday
	case UpdateDbaasServiceMysqlReqMaintenanceDowNever:
		*s = UpdateDbaasServiceMysqlReqMaintenanceDowNever
	case UpdateDbaasServiceMysqlReqMaintenanceDowWednesday:
		*s = UpdateDbaasServiceMysqlReqMaintenanceDowWednesday
	case UpdateDbaasServiceMysqlReqMaintenanceDowSunday:
		*s = UpdateDbaasServiceMysqlReqMaintenanceDowSunday
	case UpdateDbaasServiceMysqlReqMaintenanceDowFriday:
		*s = UpdateDbaasServiceMysqlReqMaintenanceDowFriday
	case UpdateDbaasServiceMysqlReqMaintenanceDowMonday:
		*s = UpdateDbaasServiceMysqlReqMaintenanceDowMonday
	case UpdateDbaasServiceMysqlReqMaintenanceDowThursday:
		*s = UpdateDbaasServiceMysqlReqMaintenanceDowThursday
	default:
		*s = UpdateDbaasServiceMysqlReqMaintenanceDow(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateDbaasServiceMysqlReqMaintenanceDow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceMysqlReqMaintenanceDow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceMysqlReqMigration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceMysqlReqMigration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.Ssl.Set {
			e.FieldStart("ssl")
			s.Ssl.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Dbname.Set {
			e.FieldStart("dbname")
			s.Dbname.Encode(e)
		}
	}
	{
		if s.IgnoreMinusDbs.Set {
			e.FieldStart("ignore-dbs")
			s.IgnoreMinusDbs.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServiceMysqlReqMigration = [8]string{
	0: "host",
	1: "port",
	2: "password",
	3: "ssl",
	4: "username",
	5: "dbname",
	6: "ignore-dbs",
	7: "method",
}

// Decode decodes UpdateDbaasServiceMysqlReqMigration from json.
func (s *UpdateDbaasServiceMysqlReqMigration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceMysqlReqMigration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "ssl":
			if err := func() error {
				s.Ssl.Reset()
				if err := s.Ssl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssl\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "dbname":
			if err := func() error {
				s.Dbname.Reset()
				if err := s.Dbname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbname\"")
			}
		case "ignore-dbs":
			if err := func() error {
				s.IgnoreMinusDbs.Reset()
				if err := s.IgnoreMinusDbs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore-dbs\"")
			}
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceMysqlReqMigration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateDbaasServiceMysqlReqMigration) {
					name = jsonFieldsNameOfUpdateDbaasServiceMysqlReqMigration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceMysqlReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceMysqlReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceMysqlReqMysqlMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceMysqlReqMysqlMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasServiceMysqlReqMysqlMinusSettings = [0]string{}

// Decode decodes UpdateDbaasServiceMysqlReqMysqlMinusSettings from json.
func (s *UpdateDbaasServiceMysqlReqMysqlMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceMysqlReqMysqlMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceMysqlReqMysqlMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceMysqlReqMysqlMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceMysqlReqMysqlMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceOpensearchReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceOpensearchReq) encodeFields(e *jx.Encoder) {
	{
		if s.MaxMinusIndexMinusCount.Set {
			e.FieldStart("max-index-count")
			s.MaxMinusIndexMinusCount.Encode(e)
		}
	}
	{
		if s.KeepMinusIndexMinusRefreshMinusInterval.Set {
			e.FieldStart("keep-index-refresh-interval")
			s.KeepMinusIndexMinusRefreshMinusInterval.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.IndexMinusPatterns != nil {
			e.FieldStart("index-patterns")
			e.ArrStart()
			for _, elem := range s.IndexMinusPatterns {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.IndexMinusTemplate.Set {
			e.FieldStart("index-template")
			s.IndexMinusTemplate.Encode(e)
		}
	}
	{
		if s.OpensearchMinusSettings != nil {
			e.FieldStart("opensearch-settings")
			s.OpensearchMinusSettings.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.OpensearchMinusDashboards.Set {
			e.FieldStart("opensearch-dashboards")
			s.OpensearchMinusDashboards.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServiceOpensearchReq = [10]string{
	0: "max-index-count",
	1: "keep-index-refresh-interval",
	2: "ip-filter",
	3: "termination-protection",
	4: "index-patterns",
	5: "maintenance",
	6: "index-template",
	7: "opensearch-settings",
	8: "plan",
	9: "opensearch-dashboards",
}

// Decode decodes UpdateDbaasServiceOpensearchReq from json.
func (s *UpdateDbaasServiceOpensearchReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceOpensearchReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max-index-count":
			if err := func() error {
				s.MaxMinusIndexMinusCount.Reset()
				if err := s.MaxMinusIndexMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-index-count\"")
			}
		case "keep-index-refresh-interval":
			if err := func() error {
				s.KeepMinusIndexMinusRefreshMinusInterval.Reset()
				if err := s.KeepMinusIndexMinusRefreshMinusInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keep-index-refresh-interval\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "index-patterns":
			if err := func() error {
				s.IndexMinusPatterns = make([]UpdateDbaasServiceOpensearchReqIndexMinusPatternsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateDbaasServiceOpensearchReqIndexMinusPatternsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.IndexMinusPatterns = append(s.IndexMinusPatterns, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index-patterns\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "index-template":
			if err := func() error {
				s.IndexMinusTemplate.Reset()
				if err := s.IndexMinusTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index-template\"")
			}
		case "opensearch-settings":
			if err := func() error {
				s.OpensearchMinusSettings = nil
				var elem UpdateDbaasServiceOpensearchReqOpensearchMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.OpensearchMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opensearch-settings\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "opensearch-dashboards":
			if err := func() error {
				s.OpensearchMinusDashboards.Reset()
				if err := s.OpensearchMinusDashboards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opensearch-dashboards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceOpensearchReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceOpensearchReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceOpensearchReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusPatternsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusPatternsItem) encodeFields(e *jx.Encoder) {
	{
		if s.MaxMinusIndexMinusCount.Set {
			e.FieldStart("max-index-count")
			s.MaxMinusIndexMinusCount.Encode(e)
		}
	}
	{
		if s.SortingMinusAlgorithm.Set {
			e.FieldStart("sorting-algorithm")
			s.SortingMinusAlgorithm.Encode(e)
		}
	}
	{
		if s.Pattern.Set {
			e.FieldStart("pattern")
			s.Pattern.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServiceOpensearchReqIndexMinusPatternsItem = [3]string{
	0: "max-index-count",
	1: "sorting-algorithm",
	2: "pattern",
}

// Decode decodes UpdateDbaasServiceOpensearchReqIndexMinusPatternsItem from json.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusPatternsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceOpensearchReqIndexMinusPatternsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "max-index-count":
			if err := func() error {
				s.MaxMinusIndexMinusCount.Reset()
				if err := s.MaxMinusIndexMinusCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-index-count\"")
			}
		case "sorting-algorithm":
			if err := func() error {
				s.SortingMinusAlgorithm.Reset()
				if err := s.SortingMinusAlgorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sorting-algorithm\"")
			}
		case "pattern":
			if err := func() error {
				s.Pattern.Reset()
				if err := s.Pattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceOpensearchReqIndexMinusPatternsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusPatternsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusPatternsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm as json.
func (s UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm from json.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm(v) {
	case UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithmAlphabetical:
		*s = UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithmAlphabetical
	case UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithmCreationDate:
		*s = UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithmCreationDate
	default:
		*s = UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusPatternsItemSortingMinusAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusTemplate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusTemplate) encodeFields(e *jx.Encoder) {
	{
		if s.MappingMinusNestedMinusObjectsMinusLimit.Set {
			e.FieldStart("mapping-nested-objects-limit")
			s.MappingMinusNestedMinusObjectsMinusLimit.Encode(e)
		}
	}
	{
		if s.NumberMinusOfMinusReplicas.Set {
			e.FieldStart("number-of-replicas")
			s.NumberMinusOfMinusReplicas.Encode(e)
		}
	}
	{
		if s.NumberMinusOfMinusShards.Set {
			e.FieldStart("number-of-shards")
			s.NumberMinusOfMinusShards.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServiceOpensearchReqIndexMinusTemplate = [3]string{
	0: "mapping-nested-objects-limit",
	1: "number-of-replicas",
	2: "number-of-shards",
}

// Decode decodes UpdateDbaasServiceOpensearchReqIndexMinusTemplate from json.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusTemplate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceOpensearchReqIndexMinusTemplate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mapping-nested-objects-limit":
			if err := func() error {
				s.MappingMinusNestedMinusObjectsMinusLimit.Reset()
				if err := s.MappingMinusNestedMinusObjectsMinusLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapping-nested-objects-limit\"")
			}
		case "number-of-replicas":
			if err := func() error {
				s.NumberMinusOfMinusReplicas.Reset()
				if err := s.NumberMinusOfMinusReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number-of-replicas\"")
			}
		case "number-of-shards":
			if err := func() error {
				s.NumberMinusOfMinusShards.Reset()
				if err := s.NumberMinusOfMinusShards.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number-of-shards\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceOpensearchReqIndexMinusTemplate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusTemplate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceOpensearchReqIndexMinusTemplate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceOpensearchReqMaintenance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceOpensearchReqMaintenance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dow")
		s.Dow.Encode(e)
	}
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfUpdateDbaasServiceOpensearchReqMaintenance = [2]string{
	0: "dow",
	1: "time",
}

// Decode decodes UpdateDbaasServiceOpensearchReqMaintenance from json.
func (s *UpdateDbaasServiceOpensearchReqMaintenance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceOpensearchReqMaintenance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dow":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dow\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceOpensearchReqMaintenance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateDbaasServiceOpensearchReqMaintenance) {
					name = jsonFieldsNameOfUpdateDbaasServiceOpensearchReqMaintenance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceOpensearchReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceOpensearchReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceOpensearchReqMaintenanceDow as json.
func (s UpdateDbaasServiceOpensearchReqMaintenanceDow) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateDbaasServiceOpensearchReqMaintenanceDow from json.
func (s *UpdateDbaasServiceOpensearchReqMaintenanceDow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceOpensearchReqMaintenanceDow to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateDbaasServiceOpensearchReqMaintenanceDow(v) {
	case UpdateDbaasServiceOpensearchReqMaintenanceDowSaturday:
		*s = UpdateDbaasServiceOpensearchReqMaintenanceDowSaturday
	case UpdateDbaasServiceOpensearchReqMaintenanceDowTuesday:
		*s = UpdateDbaasServiceOpensearchReqMaintenanceDowTuesday
	case UpdateDbaasServiceOpensearchReqMaintenanceDowNever:
		*s = UpdateDbaasServiceOpensearchReqMaintenanceDowNever
	case UpdateDbaasServiceOpensearchReqMaintenanceDowWednesday:
		*s = UpdateDbaasServiceOpensearchReqMaintenanceDowWednesday
	case UpdateDbaasServiceOpensearchReqMaintenanceDowSunday:
		*s = UpdateDbaasServiceOpensearchReqMaintenanceDowSunday
	case UpdateDbaasServiceOpensearchReqMaintenanceDowFriday:
		*s = UpdateDbaasServiceOpensearchReqMaintenanceDowFriday
	case UpdateDbaasServiceOpensearchReqMaintenanceDowMonday:
		*s = UpdateDbaasServiceOpensearchReqMaintenanceDowMonday
	case UpdateDbaasServiceOpensearchReqMaintenanceDowThursday:
		*s = UpdateDbaasServiceOpensearchReqMaintenanceDowThursday
	default:
		*s = UpdateDbaasServiceOpensearchReqMaintenanceDow(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateDbaasServiceOpensearchReqMaintenanceDow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceOpensearchReqMaintenanceDow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceOpensearchReqOpensearchMinusDashboards) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceOpensearchReqOpensearchMinusDashboards) encodeFields(e *jx.Encoder) {
	{
		if s.OpensearchMinusRequestMinusTimeout.Set {
			e.FieldStart("opensearch-request-timeout")
			s.OpensearchMinusRequestMinusTimeout.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.MaxMinusOldMinusSpaceMinusSize.Set {
			e.FieldStart("max-old-space-size")
			s.MaxMinusOldMinusSpaceMinusSize.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServiceOpensearchReqOpensearchMinusDashboards = [3]string{
	0: "opensearch-request-timeout",
	1: "enabled",
	2: "max-old-space-size",
}

// Decode decodes UpdateDbaasServiceOpensearchReqOpensearchMinusDashboards from json.
func (s *UpdateDbaasServiceOpensearchReqOpensearchMinusDashboards) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceOpensearchReqOpensearchMinusDashboards to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "opensearch-request-timeout":
			if err := func() error {
				s.OpensearchMinusRequestMinusTimeout.Reset()
				if err := s.OpensearchMinusRequestMinusTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"opensearch-request-timeout\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "max-old-space-size":
			if err := func() error {
				s.MaxMinusOldMinusSpaceMinusSize.Reset()
				if err := s.MaxMinusOldMinusSpaceMinusSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"max-old-space-size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceOpensearchReqOpensearchMinusDashboards")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceOpensearchReqOpensearchMinusDashboards) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceOpensearchReqOpensearchMinusDashboards) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceOpensearchReqOpensearchMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceOpensearchReqOpensearchMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasServiceOpensearchReqOpensearchMinusSettings = [0]string{}

// Decode decodes UpdateDbaasServiceOpensearchReqOpensearchMinusSettings from json.
func (s *UpdateDbaasServiceOpensearchReqOpensearchMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceOpensearchReqOpensearchMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceOpensearchReqOpensearchMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceOpensearchReqOpensearchMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceOpensearchReqOpensearchMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServicePgReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServicePgReq) encodeFields(e *jx.Encoder) {
	{
		if s.PgbouncerMinusSettings != nil {
			e.FieldStart("pgbouncer-settings")
			s.PgbouncerMinusSettings.Encode(e)
		}
	}
	{
		if s.BackupMinusSchedule.Set {
			e.FieldStart("backup-schedule")
			s.BackupMinusSchedule.Encode(e)
		}
	}
	{
		if s.Variant.Set {
			e.FieldStart("variant")
			s.Variant.Encode(e)
		}
	}
	{
		if s.TimescaledbMinusSettings != nil {
			e.FieldStart("timescaledb-settings")
			s.TimescaledbMinusSettings.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.SynchronousMinusReplication.Set {
			e.FieldStart("synchronous-replication")
			s.SynchronousMinusReplication.Encode(e)
		}
	}
	{
		if s.PglookoutMinusSettings != nil {
			e.FieldStart("pglookout-settings")
			s.PglookoutMinusSettings.Encode(e)
		}
	}
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.WorkMinusMem.Set {
			e.FieldStart("work-mem")
			s.WorkMinusMem.Encode(e)
		}
	}
	{
		if s.SharedMinusBuffersMinusPercentage.Set {
			e.FieldStart("shared-buffers-percentage")
			s.SharedMinusBuffersMinusPercentage.Encode(e)
		}
	}
	{
		if s.PgMinusSettings != nil {
			e.FieldStart("pg-settings")
			s.PgMinusSettings.Encode(e)
		}
	}
	{
		if s.Migration.Set {
			e.FieldStart("migration")
			s.Migration.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServicePgReq = [14]string{
	0:  "pgbouncer-settings",
	1:  "backup-schedule",
	2:  "variant",
	3:  "timescaledb-settings",
	4:  "ip-filter",
	5:  "termination-protection",
	6:  "synchronous-replication",
	7:  "pglookout-settings",
	8:  "maintenance",
	9:  "plan",
	10: "work-mem",
	11: "shared-buffers-percentage",
	12: "pg-settings",
	13: "migration",
}

// Decode decodes UpdateDbaasServicePgReq from json.
func (s *UpdateDbaasServicePgReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServicePgReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pgbouncer-settings":
			if err := func() error {
				s.PgbouncerMinusSettings = nil
				var elem UpdateDbaasServicePgReqPgbouncerMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PgbouncerMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pgbouncer-settings\"")
			}
		case "backup-schedule":
			if err := func() error {
				s.BackupMinusSchedule.Reset()
				if err := s.BackupMinusSchedule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-schedule\"")
			}
		case "variant":
			if err := func() error {
				s.Variant.Reset()
				if err := s.Variant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variant\"")
			}
		case "timescaledb-settings":
			if err := func() error {
				s.TimescaledbMinusSettings = nil
				var elem UpdateDbaasServicePgReqTimescaledbMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TimescaledbMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timescaledb-settings\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "synchronous-replication":
			if err := func() error {
				s.SynchronousMinusReplication.Reset()
				if err := s.SynchronousMinusReplication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synchronous-replication\"")
			}
		case "pglookout-settings":
			if err := func() error {
				s.PglookoutMinusSettings = nil
				var elem UpdateDbaasServicePgReqPglookoutMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PglookoutMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pglookout-settings\"")
			}
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "work-mem":
			if err := func() error {
				s.WorkMinusMem.Reset()
				if err := s.WorkMinusMem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"work-mem\"")
			}
		case "shared-buffers-percentage":
			if err := func() error {
				s.SharedMinusBuffersMinusPercentage.Reset()
				if err := s.SharedMinusBuffersMinusPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shared-buffers-percentage\"")
			}
		case "pg-settings":
			if err := func() error {
				s.PgMinusSettings = nil
				var elem UpdateDbaasServicePgReqPgMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.PgMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pg-settings\"")
			}
		case "migration":
			if err := func() error {
				s.Migration.Reset()
				if err := s.Migration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migration\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServicePgReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServicePgReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServicePgReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServicePgReqBackupMinusSchedule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServicePgReqBackupMinusSchedule) encodeFields(e *jx.Encoder) {
	{
		if s.BackupMinusHour.Set {
			e.FieldStart("backup-hour")
			s.BackupMinusHour.Encode(e)
		}
	}
	{
		if s.BackupMinusMinute.Set {
			e.FieldStart("backup-minute")
			s.BackupMinusMinute.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServicePgReqBackupMinusSchedule = [2]string{
	0: "backup-hour",
	1: "backup-minute",
}

// Decode decodes UpdateDbaasServicePgReqBackupMinusSchedule from json.
func (s *UpdateDbaasServicePgReqBackupMinusSchedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServicePgReqBackupMinusSchedule to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "backup-hour":
			if err := func() error {
				s.BackupMinusHour.Reset()
				if err := s.BackupMinusHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-hour\"")
			}
		case "backup-minute":
			if err := func() error {
				s.BackupMinusMinute.Reset()
				if err := s.BackupMinusMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"backup-minute\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServicePgReqBackupMinusSchedule")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServicePgReqBackupMinusSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServicePgReqBackupMinusSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServicePgReqMaintenance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServicePgReqMaintenance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dow")
		s.Dow.Encode(e)
	}
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfUpdateDbaasServicePgReqMaintenance = [2]string{
	0: "dow",
	1: "time",
}

// Decode decodes UpdateDbaasServicePgReqMaintenance from json.
func (s *UpdateDbaasServicePgReqMaintenance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServicePgReqMaintenance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dow":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dow\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServicePgReqMaintenance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateDbaasServicePgReqMaintenance) {
					name = jsonFieldsNameOfUpdateDbaasServicePgReqMaintenance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServicePgReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServicePgReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServicePgReqMaintenanceDow as json.
func (s UpdateDbaasServicePgReqMaintenanceDow) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateDbaasServicePgReqMaintenanceDow from json.
func (s *UpdateDbaasServicePgReqMaintenanceDow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServicePgReqMaintenanceDow to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateDbaasServicePgReqMaintenanceDow(v) {
	case UpdateDbaasServicePgReqMaintenanceDowSaturday:
		*s = UpdateDbaasServicePgReqMaintenanceDowSaturday
	case UpdateDbaasServicePgReqMaintenanceDowTuesday:
		*s = UpdateDbaasServicePgReqMaintenanceDowTuesday
	case UpdateDbaasServicePgReqMaintenanceDowNever:
		*s = UpdateDbaasServicePgReqMaintenanceDowNever
	case UpdateDbaasServicePgReqMaintenanceDowWednesday:
		*s = UpdateDbaasServicePgReqMaintenanceDowWednesday
	case UpdateDbaasServicePgReqMaintenanceDowSunday:
		*s = UpdateDbaasServicePgReqMaintenanceDowSunday
	case UpdateDbaasServicePgReqMaintenanceDowFriday:
		*s = UpdateDbaasServicePgReqMaintenanceDowFriday
	case UpdateDbaasServicePgReqMaintenanceDowMonday:
		*s = UpdateDbaasServicePgReqMaintenanceDowMonday
	case UpdateDbaasServicePgReqMaintenanceDowThursday:
		*s = UpdateDbaasServicePgReqMaintenanceDowThursday
	default:
		*s = UpdateDbaasServicePgReqMaintenanceDow(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateDbaasServicePgReqMaintenanceDow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServicePgReqMaintenanceDow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServicePgReqMigration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServicePgReqMigration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.Ssl.Set {
			e.FieldStart("ssl")
			s.Ssl.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Dbname.Set {
			e.FieldStart("dbname")
			s.Dbname.Encode(e)
		}
	}
	{
		if s.IgnoreMinusDbs.Set {
			e.FieldStart("ignore-dbs")
			s.IgnoreMinusDbs.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServicePgReqMigration = [8]string{
	0: "host",
	1: "port",
	2: "password",
	3: "ssl",
	4: "username",
	5: "dbname",
	6: "ignore-dbs",
	7: "method",
}

// Decode decodes UpdateDbaasServicePgReqMigration from json.
func (s *UpdateDbaasServicePgReqMigration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServicePgReqMigration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "ssl":
			if err := func() error {
				s.Ssl.Reset()
				if err := s.Ssl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssl\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "dbname":
			if err := func() error {
				s.Dbname.Reset()
				if err := s.Dbname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbname\"")
			}
		case "ignore-dbs":
			if err := func() error {
				s.IgnoreMinusDbs.Reset()
				if err := s.IgnoreMinusDbs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore-dbs\"")
			}
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServicePgReqMigration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateDbaasServicePgReqMigration) {
					name = jsonFieldsNameOfUpdateDbaasServicePgReqMigration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServicePgReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServicePgReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServicePgReqPgMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServicePgReqPgMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasServicePgReqPgMinusSettings = [0]string{}

// Decode decodes UpdateDbaasServicePgReqPgMinusSettings from json.
func (s *UpdateDbaasServicePgReqPgMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServicePgReqPgMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServicePgReqPgMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServicePgReqPgMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServicePgReqPgMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServicePgReqPgbouncerMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServicePgReqPgbouncerMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasServicePgReqPgbouncerMinusSettings = [0]string{}

// Decode decodes UpdateDbaasServicePgReqPgbouncerMinusSettings from json.
func (s *UpdateDbaasServicePgReqPgbouncerMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServicePgReqPgbouncerMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServicePgReqPgbouncerMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServicePgReqPgbouncerMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServicePgReqPgbouncerMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServicePgReqPglookoutMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServicePgReqPglookoutMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasServicePgReqPglookoutMinusSettings = [0]string{}

// Decode decodes UpdateDbaasServicePgReqPglookoutMinusSettings from json.
func (s *UpdateDbaasServicePgReqPglookoutMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServicePgReqPglookoutMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServicePgReqPglookoutMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServicePgReqPglookoutMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServicePgReqPglookoutMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServicePgReqTimescaledbMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServicePgReqTimescaledbMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasServicePgReqTimescaledbMinusSettings = [0]string{}

// Decode decodes UpdateDbaasServicePgReqTimescaledbMinusSettings from json.
func (s *UpdateDbaasServicePgReqTimescaledbMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServicePgReqTimescaledbMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServicePgReqTimescaledbMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServicePgReqTimescaledbMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServicePgReqTimescaledbMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceRedisReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceRedisReq) encodeFields(e *jx.Encoder) {
	{
		if s.Maintenance.Set {
			e.FieldStart("maintenance")
			s.Maintenance.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
	{
		if s.TerminationMinusProtection.Set {
			e.FieldStart("termination-protection")
			s.TerminationMinusProtection.Encode(e)
		}
	}
	{
		if s.IPMinusFilter != nil {
			e.FieldStart("ip-filter")
			e.ArrStart()
			for _, elem := range s.IPMinusFilter {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Migration.Set {
			e.FieldStart("migration")
			s.Migration.Encode(e)
		}
	}
	{
		if s.RedisMinusSettings != nil {
			e.FieldStart("redis-settings")
			s.RedisMinusSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServiceRedisReq = [6]string{
	0: "maintenance",
	1: "plan",
	2: "termination-protection",
	3: "ip-filter",
	4: "migration",
	5: "redis-settings",
}

// Decode decodes UpdateDbaasServiceRedisReq from json.
func (s *UpdateDbaasServiceRedisReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceRedisReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maintenance":
			if err := func() error {
				s.Maintenance.Reset()
				if err := s.Maintenance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maintenance\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		case "termination-protection":
			if err := func() error {
				s.TerminationMinusProtection.Reset()
				if err := s.TerminationMinusProtection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termination-protection\"")
			}
		case "ip-filter":
			if err := func() error {
				s.IPMinusFilter = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IPMinusFilter = append(s.IPMinusFilter, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip-filter\"")
			}
		case "migration":
			if err := func() error {
				s.Migration.Reset()
				if err := s.Migration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"migration\"")
			}
		case "redis-settings":
			if err := func() error {
				s.RedisMinusSettings = nil
				var elem UpdateDbaasServiceRedisReqRedisMinusSettings
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RedisMinusSettings = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"redis-settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceRedisReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceRedisReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceRedisReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceRedisReqMaintenance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceRedisReqMaintenance) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dow")
		s.Dow.Encode(e)
	}
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
}

var jsonFieldsNameOfUpdateDbaasServiceRedisReqMaintenance = [2]string{
	0: "dow",
	1: "time",
}

// Decode decodes UpdateDbaasServiceRedisReqMaintenance from json.
func (s *UpdateDbaasServiceRedisReqMaintenance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceRedisReqMaintenance to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dow":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Dow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dow\"")
			}
		case "time":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceRedisReqMaintenance")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateDbaasServiceRedisReqMaintenance) {
					name = jsonFieldsNameOfUpdateDbaasServiceRedisReqMaintenance[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceRedisReqMaintenance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceRedisReqMaintenance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDbaasServiceRedisReqMaintenanceDow as json.
func (s UpdateDbaasServiceRedisReqMaintenanceDow) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateDbaasServiceRedisReqMaintenanceDow from json.
func (s *UpdateDbaasServiceRedisReqMaintenanceDow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceRedisReqMaintenanceDow to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateDbaasServiceRedisReqMaintenanceDow(v) {
	case UpdateDbaasServiceRedisReqMaintenanceDowSaturday:
		*s = UpdateDbaasServiceRedisReqMaintenanceDowSaturday
	case UpdateDbaasServiceRedisReqMaintenanceDowTuesday:
		*s = UpdateDbaasServiceRedisReqMaintenanceDowTuesday
	case UpdateDbaasServiceRedisReqMaintenanceDowNever:
		*s = UpdateDbaasServiceRedisReqMaintenanceDowNever
	case UpdateDbaasServiceRedisReqMaintenanceDowWednesday:
		*s = UpdateDbaasServiceRedisReqMaintenanceDowWednesday
	case UpdateDbaasServiceRedisReqMaintenanceDowSunday:
		*s = UpdateDbaasServiceRedisReqMaintenanceDowSunday
	case UpdateDbaasServiceRedisReqMaintenanceDowFriday:
		*s = UpdateDbaasServiceRedisReqMaintenanceDowFriday
	case UpdateDbaasServiceRedisReqMaintenanceDowMonday:
		*s = UpdateDbaasServiceRedisReqMaintenanceDowMonday
	case UpdateDbaasServiceRedisReqMaintenanceDowThursday:
		*s = UpdateDbaasServiceRedisReqMaintenanceDowThursday
	default:
		*s = UpdateDbaasServiceRedisReqMaintenanceDow(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateDbaasServiceRedisReqMaintenanceDow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceRedisReqMaintenanceDow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceRedisReqMigration) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceRedisReqMigration) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		e.FieldStart("port")
		e.Int64(s.Port)
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.Ssl.Set {
			e.FieldStart("ssl")
			s.Ssl.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Dbname.Set {
			e.FieldStart("dbname")
			s.Dbname.Encode(e)
		}
	}
	{
		if s.IgnoreMinusDbs.Set {
			e.FieldStart("ignore-dbs")
			s.IgnoreMinusDbs.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateDbaasServiceRedisReqMigration = [8]string{
	0: "host",
	1: "port",
	2: "password",
	3: "ssl",
	4: "username",
	5: "dbname",
	6: "ignore-dbs",
	7: "method",
}

// Decode decodes UpdateDbaasServiceRedisReqMigration from json.
func (s *UpdateDbaasServiceRedisReqMigration) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceRedisReqMigration to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "host":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int64()
				s.Port = int64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "ssl":
			if err := func() error {
				s.Ssl.Reset()
				if err := s.Ssl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssl\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "dbname":
			if err := func() error {
				s.Dbname.Reset()
				if err := s.Dbname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbname\"")
			}
		case "ignore-dbs":
			if err := func() error {
				s.IgnoreMinusDbs.Reset()
				if err := s.IgnoreMinusDbs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ignore-dbs\"")
			}
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceRedisReqMigration")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateDbaasServiceRedisReqMigration) {
					name = jsonFieldsNameOfUpdateDbaasServiceRedisReqMigration[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceRedisReqMigration) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceRedisReqMigration) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateDbaasServiceRedisReqRedisMinusSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateDbaasServiceRedisReqRedisMinusSettings) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateDbaasServiceRedisReqRedisMinusSettings = [0]string{}

// Decode decodes UpdateDbaasServiceRedisReqRedisMinusSettings from json.
func (s *UpdateDbaasServiceRedisReqRedisMinusSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDbaasServiceRedisReqRedisMinusSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateDbaasServiceRedisReqRedisMinusSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDbaasServiceRedisReqRedisMinusSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDbaasServiceRedisReqRedisMinusSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateElasticIPReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateElasticIPReq) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Healthcheck.Set {
			e.FieldStart("healthcheck")
			s.Healthcheck.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateElasticIPReq = [3]string{
	0: "description",
	1: "healthcheck",
	2: "labels",
}

// Decode decodes UpdateElasticIPReq from json.
func (s *UpdateElasticIPReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateElasticIPReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "healthcheck":
			if err := func() error {
				s.Healthcheck.Reset()
				if err := s.Healthcheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthcheck\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateElasticIPReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateElasticIPReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateElasticIPReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateIamRoleReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateIamRoleReq) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateIamRoleReq = [2]string{
	0: "description",
	1: "labels",
}

// Decode decodes UpdateIamRoleReq from json.
func (s *UpdateIamRoleReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateIamRoleReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateIamRoleReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateIamRoleReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateIamRoleReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInstanceReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInstanceReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.UserMinusData.Set {
			e.FieldStart("user-data")
			s.UserMinusData.Encode(e)
		}
	}
	{
		if s.PublicMinusIPMinusAssignment.Set {
			e.FieldStart("public-ip-assignment")
			s.PublicMinusIPMinusAssignment.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateInstanceReq = [4]string{
	0: "name",
	1: "user-data",
	2: "public-ip-assignment",
	3: "labels",
}

// Decode decodes UpdateInstanceReq from json.
func (s *UpdateInstanceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInstanceReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "user-data":
			if err := func() error {
				s.UserMinusData.Reset()
				if err := s.UserMinusData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user-data\"")
			}
		case "public-ip-assignment":
			if err := func() error {
				s.PublicMinusIPMinusAssignment.Reset()
				if err := s.PublicMinusIPMinusAssignment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"public-ip-assignment\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInstanceReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInstanceReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInstanceReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateLoadBalancerReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateLoadBalancerReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateLoadBalancerReq = [3]string{
	0: "name",
	1: "description",
	2: "labels",
}

// Decode decodes UpdateLoadBalancerReq from json.
func (s *UpdateLoadBalancerReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLoadBalancerReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateLoadBalancerReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLoadBalancerReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLoadBalancerReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateLoadBalancerServiceReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateLoadBalancerServiceReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
	{
		if s.Strategy.Set {
			e.FieldStart("strategy")
			s.Strategy.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.TargetMinusPort.Set {
			e.FieldStart("target-port")
			s.TargetMinusPort.Encode(e)
		}
	}
	{
		if s.Healthcheck.Set {
			e.FieldStart("healthcheck")
			s.Healthcheck.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateLoadBalancerServiceReq = [7]string{
	0: "name",
	1: "description",
	2: "protocol",
	3: "strategy",
	4: "port",
	5: "target-port",
	6: "healthcheck",
}

// Decode decodes UpdateLoadBalancerServiceReq from json.
func (s *UpdateLoadBalancerServiceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLoadBalancerServiceReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "strategy":
			if err := func() error {
				s.Strategy.Reset()
				if err := s.Strategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"strategy\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "target-port":
			if err := func() error {
				s.TargetMinusPort.Reset()
				if err := s.TargetMinusPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"target-port\"")
			}
		case "healthcheck":
			if err := func() error {
				s.Healthcheck.Reset()
				if err := s.Healthcheck.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"healthcheck\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateLoadBalancerServiceReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateLoadBalancerServiceReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLoadBalancerServiceReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLoadBalancerServiceReqProtocol as json.
func (s UpdateLoadBalancerServiceReqProtocol) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateLoadBalancerServiceReqProtocol from json.
func (s *UpdateLoadBalancerServiceReqProtocol) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLoadBalancerServiceReqProtocol to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateLoadBalancerServiceReqProtocol(v) {
	case UpdateLoadBalancerServiceReqProtocolTCP:
		*s = UpdateLoadBalancerServiceReqProtocolTCP
	case UpdateLoadBalancerServiceReqProtocolUDP:
		*s = UpdateLoadBalancerServiceReqProtocolUDP
	default:
		*s = UpdateLoadBalancerServiceReqProtocol(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateLoadBalancerServiceReqProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLoadBalancerServiceReqProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateLoadBalancerServiceReqStrategy as json.
func (s UpdateLoadBalancerServiceReqStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateLoadBalancerServiceReqStrategy from json.
func (s *UpdateLoadBalancerServiceReqStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateLoadBalancerServiceReqStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateLoadBalancerServiceReqStrategy(v) {
	case UpdateLoadBalancerServiceReqStrategyRoundRobin:
		*s = UpdateLoadBalancerServiceReqStrategyRoundRobin
	case UpdateLoadBalancerServiceReqStrategySourceHash:
		*s = UpdateLoadBalancerServiceReqStrategySourceHash
	default:
		*s = UpdateLoadBalancerServiceReqStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateLoadBalancerServiceReqStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateLoadBalancerServiceReqStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdatePrivateNetworkReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdatePrivateNetworkReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Netmask.Set {
			e.FieldStart("netmask")
			s.Netmask.Encode(e)
		}
	}
	{
		if s.StartMinusIP.Set {
			e.FieldStart("start-ip")
			s.StartMinusIP.Encode(e)
		}
	}
	{
		if s.EndMinusIP.Set {
			e.FieldStart("end-ip")
			s.EndMinusIP.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdatePrivateNetworkReq = [6]string{
	0: "name",
	1: "description",
	2: "netmask",
	3: "start-ip",
	4: "end-ip",
	5: "labels",
}

// Decode decodes UpdatePrivateNetworkReq from json.
func (s *UpdatePrivateNetworkReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdatePrivateNetworkReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "netmask":
			if err := func() error {
				s.Netmask.Reset()
				if err := s.Netmask.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"netmask\"")
			}
		case "start-ip":
			if err := func() error {
				s.StartMinusIP.Reset()
				if err := s.StartMinusIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start-ip\"")
			}
		case "end-ip":
			if err := func() error {
				s.EndMinusIP.Reset()
				if err := s.EndMinusIP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end-ip\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdatePrivateNetworkReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdatePrivateNetworkReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdatePrivateNetworkReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateReverseDNSElasticIPReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateReverseDNSElasticIPReq) encodeFields(e *jx.Encoder) {
	{
		if s.DomainMinusName.Set {
			e.FieldStart("domain-name")
			s.DomainMinusName.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateReverseDNSElasticIPReq = [1]string{
	0: "domain-name",
}

// Decode decodes UpdateReverseDNSElasticIPReq from json.
func (s *UpdateReverseDNSElasticIPReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateReverseDNSElasticIPReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain-name":
			if err := func() error {
				s.DomainMinusName.Reset()
				if err := s.DomainMinusName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain-name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateReverseDNSElasticIPReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateReverseDNSElasticIPReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateReverseDNSElasticIPReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateReverseDNSInstanceReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateReverseDNSInstanceReq) encodeFields(e *jx.Encoder) {
	{
		if s.DomainMinusName.Set {
			e.FieldStart("domain-name")
			s.DomainMinusName.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateReverseDNSInstanceReq = [1]string{
	0: "domain-name",
}

// Decode decodes UpdateReverseDNSInstanceReq from json.
func (s *UpdateReverseDNSInstanceReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateReverseDNSInstanceReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain-name":
			if err := func() error {
				s.DomainMinusName.Reset()
				if err := s.DomainMinusName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain-name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateReverseDNSInstanceReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateReverseDNSInstanceReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateReverseDNSInstanceReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSksClusterReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSksClusterReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Labels.Set {
			e.FieldStart("labels")
			s.Labels.Encode(e)
		}
	}
	{
		if s.AutoMinusUpgrade.Set {
			e.FieldStart("auto-upgrade")
			s.AutoMinusUpgrade.Encode(e)
		}
	}
	{
		if s.Addons != nil {
			e.FieldStart("addons")
			e.ArrStart()
			for _, elem := range s.Addons {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateSksClusterReq = [5]string{
	0: "name",
	1: "description",
	2: "labels",
	3: "auto-upgrade",
	4: "addons",
}

// Decode decodes UpdateSksClusterReq from json.
func (s *UpdateSksClusterReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSksClusterReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "labels":
			if err := func() error {
				s.Labels.Reset()
				if err := s.Labels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"labels\"")
			}
		case "auto-upgrade":
			if err := func() error {
				s.AutoMinusUpgrade.Reset()
				if err := s.AutoMinusUpgrade.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auto-upgrade\"")
			}
		case "addons":
			if err := func() error {
				s.Addons = make([]UpdateSksClusterReqAddonsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateSksClusterReqAddonsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Addons = append(s.Addons, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addons\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSksClusterReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSksClusterReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSksClusterReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSksClusterReqAddonsItem as json.
func (s UpdateSksClusterReqAddonsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateSksClusterReqAddonsItem from json.
func (s *UpdateSksClusterReqAddonsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSksClusterReqAddonsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateSksClusterReqAddonsItem(v) {
	case UpdateSksClusterReqAddonsItemExoscaleCloudController:
		*s = UpdateSksClusterReqAddonsItemExoscaleCloudController
	case UpdateSksClusterReqAddonsItemMetricsServer:
		*s = UpdateSksClusterReqAddonsItemMetricsServer
	default:
		*s = UpdateSksClusterReqAddonsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSksClusterReqAddonsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSksClusterReqAddonsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateReq) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTemplateReq = [2]string{
	0: "name",
	1: "description",
}

// Decode decodes UpdateTemplateReq from json.
func (s *UpdateTemplateReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpgradeSksClusterReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpgradeSksClusterReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
}

var jsonFieldsNameOfUpgradeSksClusterReq = [1]string{
	0: "version",
}

// Decode decodes UpgradeSksClusterReq from json.
func (s *UpgradeSksClusterReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpgradeSksClusterReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpgradeSksClusterReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpgradeSksClusterReq) {
					name = jsonFieldsNameOfUpgradeSksClusterReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpgradeSksClusterReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpgradeSksClusterReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Zone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Zone) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfZone = [1]string{
	0: "name",
}

// Decode decodes Zone from json.
func (s *Zone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Zone to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Zone")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Zone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Zone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ZoneName as json.
func (s ZoneName) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ZoneName from json.
func (s *ZoneName) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ZoneName to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ZoneName(v) {
	case ZoneNameChDk2:
		*s = ZoneNameChDk2
	case ZoneNameDeMuc1:
		*s = ZoneNameDeMuc1
	case ZoneNameChGva2:
		*s = ZoneNameChGva2
	case ZoneNameAtVie1:
		*s = ZoneNameAtVie1
	case ZoneNameDeFra1:
		*s = ZoneNameDeFra1
	case ZoneNameBgSof1:
		*s = ZoneNameBgSof1
	case ZoneNameAtVie2:
		*s = ZoneNameAtVie2
	default:
		*s = ZoneName(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ZoneName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ZoneName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
