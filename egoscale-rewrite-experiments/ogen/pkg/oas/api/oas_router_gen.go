// Code generated by ogen, DO NOT EDIT.

package api

import (
	"net/http"
	"net/url"
	"strings"

	"github.com/ogen-go/ogen/uri"
)

// ServeHTTP serves http request as defined by OpenAPI v3 specification,
// calling handler that matches the path or returning not found error.
func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	elem := r.URL.Path
	elemIsEscaped := false
	if rawPath := r.URL.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
			elemIsEscaped = strings.ContainsRune(elem, '%')
		}
	}
	if prefix := s.cfg.Prefix; len(prefix) > 0 {
		if strings.HasPrefix(elem, prefix) {
			// Cut prefix from the path.
			elem = strings.TrimPrefix(elem, prefix)
		} else {
			// Prefix doesn't match.
			s.notFound(w, r)
			return
		}
	}
	if len(elem) == 0 {
		s.notFound(w, r)
		return
	}
	args := [3]string{}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "ccess-key"
					if l := len("ccess-key"); len(elem) >= l && elem[0:l] == "ccess-key" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListAccessKeysRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateAccessKeyRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '-': // Prefix: "-"
						if l := len("-"); len(elem) >= l && elem[0:l] == "-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'k': // Prefix: "known-operations"
							if l := len("known-operations"); len(elem) >= l && elem[0:l] == "known-operations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListAccessKeyKnownOperationsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'o': // Prefix: "operations"
							if l := len("operations"); len(elem) >= l && elem[0:l] == "operations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListAccessKeyOperationsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "key"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleRevokeAccessKeyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetAccessKeyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
					}
				case 'n': // Prefix: "nti-affinity-group"
					if l := len("nti-affinity-group"); len(elem) >= l && elem[0:l] == "nti-affinity-group" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "POST":
							s.handleCreateAntiAffinityGroupRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteAntiAffinityGroupRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}
					}
				case 'p': // Prefix: "pi-key"
					if l := len("pi-key"); len(elem) >= l && elem[0:l] == "pi-key" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListAPIKeysRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateAPIKeyRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteAPIKeyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetAPIKeyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
					}
				}
			case 'd': // Prefix: "d"
				if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'b': // Prefix: "baas-"
					if l := len("baas-"); len(elem) >= l && elem[0:l] == "baas-" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "ca-certificate"
						if l := len("ca-certificate"); len(elem) >= l && elem[0:l] == "ca-certificate" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetDbaasCaCertificateRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					case 'i': // Prefix: "integration"
						if l := len("integration"); len(elem) >= l && elem[0:l] == "integration" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "POST":
								s.handleCreateDbaasIntegrationRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "POST")
							}

							return
						}
						switch elem[0] {
						case '-': // Prefix: "-"
							if l := len("-"); len(elem) >= l && elem[0:l] == "-" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "settings/"
								if l := len("settings/"); len(elem) >= l && elem[0:l] == "settings/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "integration-type"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "source-type"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "dest-type"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleListDbaasIntegrationSettingsRequest([3]string{
													args[0],
													args[1],
													args[2],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									}
								}
							case 't': // Prefix: "types"
								if l := len("types"); len(elem) >= l && elem[0:l] == "types" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleListDbaasIntegrationTypesRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleDeleteDbaasIntegrationRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetDbaasIntegrationRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleUpdateDbaasIntegrationRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}
						}
					case 'k': // Prefix: "kafka/"
						if l := len("kafka/"); len(elem) >= l && elem[0:l] == "kafka/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetDbaasServiceKafkaRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateDbaasServiceKafkaRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateDbaasServiceKafkaRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "acl-config"
								if l := len("acl-config"); len(elem) >= l && elem[0:l] == "acl-config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetDbaasKafkaACLConfigRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'm': // Prefix: "maintenance/start"
								if l := len("maintenance/start"); len(elem) >= l && elem[0:l] == "maintenance/start" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "PUT":
										s.handleStartDbaasKafkaMaintenanceRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PUT")
									}

									return
								}
							case 's': // Prefix: "schema-registry/acl-config"
								if l := len("schema-registry/acl-config"); len(elem) >= l && elem[0:l] == "schema-registry/acl-config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleCreateDbaasKafkaSchemaRegistryACLConfigRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "acl-id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleDeleteDbaasKafkaSchemaRegistryACLConfigRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE")
										}

										return
									}
								}
							case 't': // Prefix: "topic/acl-config"
								if l := len("topic/acl-config"); len(elem) >= l && elem[0:l] == "topic/acl-config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleCreateDbaasKafkaTopicACLConfigRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "acl-id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleDeleteDbaasKafkaTopicACLConfigRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE")
										}

										return
									}
								}
							case 'u': // Prefix: "user"
								if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleCreateDbaasKafkaUserRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "DELETE":
											s.handleDeleteDbaasKafkaUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/password/reset"
										if l := len("/password/reset"); len(elem) >= l && elem[0:l] == "/password/reset" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "PUT":
												s.handleResetDbaasKafkaUserPasswordRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "PUT")
											}

											return
										}
									}
								}
							}
						}
					case 'm': // Prefix: "m"
						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'i': // Prefix: "igration-status/"
							if l := len("igration-status/"); len(elem) >= l && elem[0:l] == "igration-status/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "name"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetDbaasMigrationStatusRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'y': // Prefix: "ysql/"
							if l := len("ysql/"); len(elem) >= l && elem[0:l] == "ysql/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleGetDbaasServiceMysqlRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "POST":
									s.handleCreateDbaasServiceMysqlRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleUpdateDbaasServiceMysqlRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET,POST,PUT")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/m"
								if l := len("/m"); len(elem) >= l && elem[0:l] == "/m" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "aintenance/start"
									if l := len("aintenance/start"); len(elem) >= l && elem[0:l] == "aintenance/start" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PUT":
											s.handleStartDbaasMysqlMaintenanceRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
								case 'i': // Prefix: "igration/stop"
									if l := len("igration/stop"); len(elem) >= l && elem[0:l] == "igration/stop" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleStopDbaasMysqlMigrationRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
								}
							}
						}
					case 'o': // Prefix: "opensearch/"
						if l := len("opensearch/"); len(elem) >= l && elem[0:l] == "opensearch/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetDbaasServiceOpensearchRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateDbaasServiceOpensearchRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateDbaasServiceOpensearchRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/maintenance/start"
							if l := len("/maintenance/start"); len(elem) >= l && elem[0:l] == "/maintenance/start" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "PUT":
									s.handleStartDbaasOpensearchMaintenanceRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "PUT")
								}

								return
							}
						}
					case 'p': // Prefix: "postgres/"
						if l := len("postgres/"); len(elem) >= l && elem[0:l] == "postgres/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "service-name"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetDbaasServicePgRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateDbaasServicePgRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateDbaasServicePgRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'm': // Prefix: "m"
								if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "aintenance/start"
									if l := len("aintenance/start"); len(elem) >= l && elem[0:l] == "aintenance/start" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PUT":
											s.handleStartDbaasPgMaintenanceRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
								case 'i': // Prefix: "igration/stop"
									if l := len("igration/stop"); len(elem) >= l && elem[0:l] == "igration/stop" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleStopDbaasPgMigrationRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
								}
							case 'u': // Prefix: "user"
								if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "POST":
										s.handleCreateDbaasPostgresUserRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch r.Method {
										case "DELETE":
											s.handleDeleteDbaasPostgresUserRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "allow-replication"
											if l := len("allow-replication"); len(elem) >= l && elem[0:l] == "allow-replication" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "PUT":
													s.handleUpdateDbaasPostgresAllowReplicationRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "PUT")
												}

												return
											}
										case 'p': // Prefix: "password/reset"
											if l := len("password/reset"); len(elem) >= l && elem[0:l] == "password/reset" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												// Leaf node.
												switch r.Method {
												case "PUT":
													s.handleResetDbaasPostgresUserPasswordRequest([2]string{
														args[0],
														args[1],
													}, elemIsEscaped, w, r)
												default:
													s.notAllowed(w, r, "PUT")
												}

												return
											}
										}
									}
								}
							}
						}
					case 'r': // Prefix: "redis/"
						if l := len("redis/"); len(elem) >= l && elem[0:l] == "redis/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleGetDbaasServiceRedisRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateDbaasServiceRedisRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateDbaasServiceRedisRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/m"
							if l := len("/m"); len(elem) >= l && elem[0:l] == "/m" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "aintenance/start"
								if l := len("aintenance/start"); len(elem) >= l && elem[0:l] == "aintenance/start" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "PUT":
										s.handleStartDbaasRedisMaintenanceRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PUT")
									}

									return
								}
							case 'i': // Prefix: "igration/stop"
								if l := len("igration/stop"); len(elem) >= l && elem[0:l] == "igration/stop" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleStopDbaasRedisMigrationRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
							}
						}
					case 's': // Prefix: "se"
						if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'r': // Prefix: "rvice"
							if l := len("rvice"); len(elem) >= l && elem[0:l] == "rvice" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleListDbaasServicesRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '-': // Prefix: "-"
								if l := len("-"); len(elem) >= l && elem[0:l] == "-" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'l': // Prefix: "logs/"
									if l := len("logs/"); len(elem) >= l && elem[0:l] == "logs/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "service-name"
									// Leaf parameter
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleGetDbaasServiceLogsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
								case 'm': // Prefix: "metrics/"
									if l := len("metrics/"); len(elem) >= l && elem[0:l] == "metrics/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "service-name"
									// Leaf parameter
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleGetDbaasServiceMetricsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
								case 't': // Prefix: "type"
									if l := len("type"); len(elem) >= l && elem[0:l] == "type" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch r.Method {
										case "GET":
											s.handleListDbaasServiceTypesRequest([0]string{}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "service-type-name"
										// Leaf parameter
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "GET":
												s.handleGetDbaasServiceTypeRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "GET")
											}

											return
										}
									}
								}
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "name"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteDbaasServiceRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}
							}
						case 't': // Prefix: "ttings-"
							if l := len("ttings-"); len(elem) >= l && elem[0:l] == "ttings-" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'k': // Prefix: "kafka"
								if l := len("kafka"); len(elem) >= l && elem[0:l] == "kafka" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetDbaasSettingsKafkaRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'm': // Prefix: "mysql"
								if l := len("mysql"); len(elem) >= l && elem[0:l] == "mysql" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetDbaasSettingsMysqlRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'o': // Prefix: "opensearch"
								if l := len("opensearch"); len(elem) >= l && elem[0:l] == "opensearch" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetDbaasSettingsOpensearchRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'p': // Prefix: "pg"
								if l := len("pg"); len(elem) >= l && elem[0:l] == "pg" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetDbaasSettingsPgRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'r': // Prefix: "redis"
								if l := len("redis"); len(elem) >= l && elem[0:l] == "redis" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetDbaasSettingsRedisRequest([0]string{}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					case 't': // Prefix: "task"
						if l := len("task"); len(elem) >= l && elem[0:l] == "task" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-migration-check/"
							if l := len("-migration-check/"); len(elem) >= l && elem[0:l] == "-migration-check/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "service"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleCreateDbaasTaskMigrationCheckRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "service"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetDbaasTaskRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					}
				case 'e': // Prefix: "eploy-target"
					if l := len("eploy-target"); len(elem) >= l && elem[0:l] == "eploy-target" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListDeployTargetsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetDeployTargetRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					}
				case 'n': // Prefix: "ns-domain"
					if l := len("ns-domain"); len(elem) >= l && elem[0:l] == "ns-domain" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListDNSDomainsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateDNSDomainRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "domain-id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteDNSDomainRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetDNSDomainRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'r': // Prefix: "record"
								if l := len("record"); len(elem) >= l && elem[0:l] == "record" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "GET":
										s.handleListDNSDomainRecordsRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									case "POST":
										s.handleCreateDNSDomainRecordRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET,POST")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "record-id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleDeleteDNSDomainRecordRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "GET":
											s.handleGetDNSDomainRecordRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										case "PUT":
											s.handleUpdateDNSDomainRecordRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE,GET,PUT")
										}

										return
									}
								}
							case 'z': // Prefix: "zone"
								if l := len("zone"); len(elem) >= l && elem[0:l] == "zone" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetDNSDomainZoneFileRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					}
				}
			case 'e': // Prefix: "e"
				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "lastic-ip"
					if l := len("lastic-ip"); len(elem) >= l && elem[0:l] == "lastic-ip" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListElasticIpsRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleCreateElasticIPRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteElasticIPRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetElasticIPRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateElasticIPRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "field"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleResetElasticIPFieldRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}
						}
					}
				case 'v': // Prefix: "vent"
					if l := len("vent"); len(elem) >= l && elem[0:l] == "vent" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleListEventsRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
				}
			case 'i': // Prefix: "i"
				if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "am-"
					if l := len("am-"); len(elem) >= l && elem[0:l] == "am-" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'o': // Prefix: "organization-policy"
						if l := len("organization-policy"); len(elem) >= l && elem[0:l] == "organization-policy" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleGetIamOrganizationPolicyRequest([0]string{}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateIamOrganizationPolicyRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,PUT")
							}

							return
						}
					case 'r': // Prefix: "role"
						if l := len("role"); len(elem) >= l && elem[0:l] == "role" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch r.Method {
							case "GET":
								s.handleListIamRolesRequest([0]string{}, elemIsEscaped, w, r)
							case "POST":
								s.handleCreateIamRoleRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET,POST")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Match until ":"
							idx := strings.IndexByte(elem, ':')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteIamRoleRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "GET":
									s.handleGetIamRoleRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleUpdateIamRoleRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,GET,PUT")
								}

								return
							}
							switch elem[0] {
							case ':': // Prefix: ":policy"
								if l := len(":policy"); len(elem) >= l && elem[0:l] == ":policy" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "PUT":
										s.handleUpdateIamRolePolicyRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PUT")
									}

									return
								}
							}
						}
					}
				case 'n': // Prefix: "nstance"
					if l := len("nstance"); len(elem) >= l && elem[0:l] == "nstance" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '-': // Prefix: "-"
						if l := len("-"); len(elem) >= l && elem[0:l] == "-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "pool/"
							if l := len("pool/"); len(elem) >= l && elem[0:l] == "pool/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Match until one of "/:"
							idx := strings.IndexAny(elem, "/:")
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteInstancePoolRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "field"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleResetInstancePoolFieldRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}
							case ':': // Prefix: ":"
								if l := len(":"); len(elem) >= l && elem[0:l] == ":" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "evict"
									if l := len("evict"); len(elem) >= l && elem[0:l] == "evict" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PUT":
											s.handleEvictInstancePoolMembersRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
								case 's': // Prefix: "scale"
									if l := len("scale"); len(elem) >= l && elem[0:l] == "scale" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PUT":
											s.handleScaleInstancePoolRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
								}
							}
						case 't': // Prefix: "type"
							if l := len("type"); len(elem) >= l && elem[0:l] == "type" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "GET":
									s.handleListInstanceTypesRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleGetInstanceTypeRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							}
						}
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until one of "/:"
						idx := strings.IndexAny(elem, "/:")
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteInstanceRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateInstanceRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "field"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleResetInstanceFieldRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}
						case ':': // Prefix: ":"
							if l := len(":"); len(elem) >= l && elem[0:l] == ":" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "add-protection"
								if l := len("add-protection"); len(elem) >= l && elem[0:l] == "add-protection" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "PUT":
										s.handleAddInstanceProtectionRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PUT")
									}

									return
								}
							case 'c': // Prefix: "create-snapshot"
								if l := len("create-snapshot"); len(elem) >= l && elem[0:l] == "create-snapshot" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "POST":
										s.handleCreateSnapshotRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "POST")
									}

									return
								}
							case 'p': // Prefix: "password"
								if l := len("password"); len(elem) >= l && elem[0:l] == "password" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "GET":
										s.handleRevealInstancePasswordRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "GET")
									}

									return
								}
							case 'r': // Prefix: "re"
								if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "boot"
									if l := len("boot"); len(elem) >= l && elem[0:l] == "boot" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PUT":
											s.handleRebootInstanceRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
								case 'm': // Prefix: "move-protection"
									if l := len("move-protection"); len(elem) >= l && elem[0:l] == "move-protection" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PUT":
											s.handleRemoveInstanceProtectionRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
								case 's': // Prefix: "s"
									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "et"
										if l := len("et"); len(elem) >= l && elem[0:l] == "et" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "PUT":
												s.handleResetInstanceRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "PUT")
											}

											return
										}
									case 'i': // Prefix: "ize-disk"
										if l := len("ize-disk"); len(elem) >= l && elem[0:l] == "ize-disk" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "PUT":
												s.handleResizeInstanceDiskRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "PUT")
											}

											return
										}
									}
								case 'v': // Prefix: "vert-snapshot"
									if l := len("vert-snapshot"); len(elem) >= l && elem[0:l] == "vert-snapshot" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "POST":
											s.handleRevertInstanceToSnapshotRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "POST")
										}

										return
									}
								}
							case 's': // Prefix: "s"
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "cale"
									if l := len("cale"); len(elem) >= l && elem[0:l] == "cale" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PUT":
											s.handleScaleInstanceRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
								case 't': // Prefix: "t"
									if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "art"
										if l := len("art"); len(elem) >= l && elem[0:l] == "art" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "PUT":
												s.handleStartInstanceRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "PUT")
											}

											return
										}
									case 'o': // Prefix: "op"
										if l := len("op"); len(elem) >= l && elem[0:l] == "op" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "PUT":
												s.handleStopInstanceRequest([1]string{
													args[0],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "PUT")
											}

											return
										}
									}
								}
							}
						}
					}
				}
			case 'l': // Prefix: "load-balancer"
				if l := len("load-balancer"); len(elem) >= l && elem[0:l] == "load-balancer" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "POST":
						s.handleCreateLoadBalancerRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleDeleteLoadBalancerRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "PUT":
							s.handleUpdateLoadBalancerRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,PUT")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "service/"
							if l := len("service/"); len(elem) >= l && elem[0:l] == "service/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "service-id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch r.Method {
								case "DELETE":
									s.handleDeleteLoadBalancerServiceRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								case "PUT":
									s.handleUpdateLoadBalancerServiceRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE,PUT")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "field"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleResetLoadBalancerServiceFieldRequest([3]string{
											args[0],
											args[1],
											args[2],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}
							}
						}
						// Param: "field"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleResetLoadBalancerFieldRequest([2]string{
									args[0],
									args[1],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}
					}
				}
			case 'o': // Prefix: "operation/"
				if l := len("operation/"); len(elem) >= l && elem[0:l] == "operation/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "id"
				// Leaf parameter
				args[0] = elem
				elem = ""

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleGetOperationRequest([1]string{
							args[0],
						}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
			case 'p': // Prefix: "private-network"
				if l := len("private-network"); len(elem) >= l && elem[0:l] == "private-network" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleListPrivateNetworksRequest([0]string{}, elemIsEscaped, w, r)
					case "POST":
						s.handleCreatePrivateNetworkRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until one of "/:"
					idx := strings.IndexAny(elem, "/:")
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleDeletePrivateNetworkRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetPrivateNetworkRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "PUT":
							s.handleUpdatePrivateNetworkRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,PUT")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "field"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleResetPrivateNetworkFieldRequest([2]string{
									args[0],
									args[1],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}
					case ':': // Prefix: ":attach"
						if l := len(":attach"); len(elem) >= l && elem[0:l] == ":attach" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "PUT":
								s.handleAttachInstanceToPrivateNetworkRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "PUT")
							}

							return
						}
					}
				}
			case 'q': // Prefix: "quota"
				if l := len("quota"); len(elem) >= l && elem[0:l] == "quota" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleListQuotasRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "entity"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "GET":
							s.handleGetQuotaRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET")
						}

						return
					}
				}
			case 'r': // Prefix: "reverse-dns/"
				if l := len("reverse-dns/"); len(elem) >= l && elem[0:l] == "reverse-dns/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "elastic-ip/"
					if l := len("elastic-ip/"); len(elem) >= l && elem[0:l] == "elastic-ip/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "DELETE":
							s.handleDeleteReverseDNSElasticIPRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetReverseDNSElasticIPRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "POST":
							s.handleUpdateReverseDNSElasticIPRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,POST")
						}

						return
					}
				case 'i': // Prefix: "instance/"
					if l := len("instance/"); len(elem) >= l && elem[0:l] == "instance/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "DELETE":
							s.handleDeleteReverseDNSInstanceRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetReverseDNSInstanceRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "POST":
							s.handleUpdateReverseDNSInstanceRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,POST")
						}

						return
					}
				}
			case 's': // Prefix: "s"
				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "ecurity-group"
					if l := len("ecurity-group"); len(elem) >= l && elem[0:l] == "ecurity-group" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "POST":
							s.handleCreateSecurityGroupRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until one of "/:"
						idx := strings.IndexAny(elem, "/:")
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteSecurityGroupRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/rules"
							if l := len("/rules"); len(elem) >= l && elem[0:l] == "/rules" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch r.Method {
								case "POST":
									s.handleAddRuleToSecurityGroupRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "rule-id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "DELETE":
										s.handleDeleteRuleFromSecurityGroupRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}
							}
						case ':': // Prefix: ":"
							if l := len(":"); len(elem) >= l && elem[0:l] == ":" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "add-source"
								if l := len("add-source"); len(elem) >= l && elem[0:l] == "add-source" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "PUT":
										s.handleAddExternalSourceToSecurityGroupRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PUT")
									}

									return
								}
							case 'r': // Prefix: "remove-source"
								if l := len("remove-source"); len(elem) >= l && elem[0:l] == "remove-source" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									// Leaf node.
									switch r.Method {
									case "PUT":
										s.handleRemoveExternalSourceFromSecurityGroupRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PUT")
									}

									return
								}
							}
						}
					}
				case 'k': // Prefix: "ks-cluster"
					if l := len("ks-cluster"); len(elem) >= l && elem[0:l] == "ks-cluster" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "POST":
							s.handleCreateSksClusterRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "POST")
						}

						return
					}
					switch elem[0] {
					case '-': // Prefix: "-"
						if l := len("-"); len(elem) >= l && elem[0:l] == "-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "deprecated-resources/"
							if l := len("deprecated-resources/"); len(elem) >= l && elem[0:l] == "deprecated-resources/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListSksClusterDeprecatedResourcesRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						case 'k': // Prefix: "kubeconfig/"
							if l := len("kubeconfig/"); len(elem) >= l && elem[0:l] == "kubeconfig/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleGenerateSksClusterKubeconfigRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
						case 'v': // Prefix: "version"
							if l := len("version"); len(elem) >= l && elem[0:l] == "version" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleListSksClusterVersionsRequest([0]string{}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch r.Method {
							case "DELETE":
								s.handleDeleteSksClusterRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "PUT":
								s.handleUpdateSksClusterRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,PUT")
							}

							return
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "authority/"
								if l := len("authority/"); len(elem) >= l && elem[0:l] == "authority/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "authority"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/cert"
									if l := len("/cert"); len(elem) >= l && elem[0:l] == "/cert" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "GET":
											s.handleGetSksClusterAuthorityCertRequest([2]string{
												args[0],
												args[1],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "GET")
										}

										return
									}
								}
							case 'n': // Prefix: "nodepool/"
								if l := len("nodepool/"); len(elem) >= l && elem[0:l] == "nodepool/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "sks-nodepool-id"
								// Match until one of "/:"
								idx := strings.IndexAny(elem, "/:")
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch r.Method {
									case "DELETE":
										s.handleDeleteSksNodepoolRequest([2]string{
											args[0],
											args[1],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "DELETE")
									}

									return
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "field"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "DELETE":
											s.handleResetSksNodepoolFieldRequest([3]string{
												args[0],
												args[1],
												args[2],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "DELETE")
										}

										return
									}
								case ':': // Prefix: ":"
									if l := len(":"); len(elem) >= l && elem[0:l] == ":" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "evict"
										if l := len("evict"); len(elem) >= l && elem[0:l] == "evict" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "PUT":
												s.handleEvictSksNodepoolMembersRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "PUT")
											}

											return
										}
									case 's': // Prefix: "scale"
										if l := len("scale"); len(elem) >= l && elem[0:l] == "scale" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											// Leaf node.
											switch r.Method {
											case "PUT":
												s.handleScaleSksNodepoolRequest([2]string{
													args[0],
													args[1],
												}, elemIsEscaped, w, r)
											default:
												s.notAllowed(w, r, "PUT")
											}

											return
										}
									}
								}
							case 'r': // Prefix: "rotate-"
								if l := len("rotate-"); len(elem) >= l && elem[0:l] == "rotate-" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "ccm-credentials"
									if l := len("ccm-credentials"); len(elem) >= l && elem[0:l] == "ccm-credentials" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PUT":
											s.handleRotateSksCcmCredentialsRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
								case 'o': // Prefix: "operators-ca"
									if l := len("operators-ca"); len(elem) >= l && elem[0:l] == "operators-ca" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PUT":
											s.handleRotateSksOperatorsCaRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
								}
							case 'u': // Prefix: "upgrade"
								if l := len("upgrade"); len(elem) >= l && elem[0:l] == "upgrade" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch r.Method {
									case "PUT":
										s.handleUpgradeSksClusterRequest([1]string{
											args[0],
										}, elemIsEscaped, w, r)
									default:
										s.notAllowed(w, r, "PUT")
									}

									return
								}
								switch elem[0] {
								case '-': // Prefix: "-service-level"
									if l := len("-service-level"); len(elem) >= l && elem[0:l] == "-service-level" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										// Leaf node.
										switch r.Method {
										case "PUT":
											s.handleUpgradeSksClusterServiceLevelRequest([1]string{
												args[0],
											}, elemIsEscaped, w, r)
										default:
											s.notAllowed(w, r, "PUT")
										}

										return
									}
								}
							}
							// Param: "field"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "DELETE":
									s.handleResetSksClusterFieldRequest([2]string{
										args[0],
										args[1],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "DELETE")
								}

								return
							}
						}
					}
				case 'n': // Prefix: "napshot/"
					if l := len("napshot/"); len(elem) >= l && elem[0:l] == "napshot/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until ":"
					idx := strings.IndexByte(elem, ':')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch r.Method {
						case "DELETE":
							s.handleDeleteSnapshotRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE")
						}

						return
					}
					switch elem[0] {
					case ':': // Prefix: ":"
						if l := len(":"); len(elem) >= l && elem[0:l] == ":" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "export"
							if l := len("export"); len(elem) >= l && elem[0:l] == "export" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handleExportSnapshotRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
						case 'p': // Prefix: "promote"
							if l := len("promote"); len(elem) >= l && elem[0:l] == "promote" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "POST":
									s.handlePromoteSnapshotToTemplateRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "POST")
								}

								return
							}
						}
					}
				case 'o': // Prefix: "os"
					if l := len("os"); len(elem) >= l && elem[0:l] == "os" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '-': // Prefix: "-buckets-usage"
						if l := len("-buckets-usage"); len(elem) >= l && elem[0:l] == "-buckets-usage" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "GET":
								s.handleListSosBucketsUsageRequest([0]string{}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "GET")
							}

							return
						}
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "bucket"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/presigned-url"
							if l := len("/presigned-url"); len(elem) >= l && elem[0:l] == "/presigned-url" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								// Leaf node.
								switch r.Method {
								case "GET":
									s.handleGetSosPresignedURLRequest([1]string{
										args[0],
									}, elemIsEscaped, w, r)
								default:
									s.notAllowed(w, r, "GET")
								}

								return
							}
						}
					}
				case 's': // Prefix: "sh-key"
					if l := len("sh-key"); len(elem) >= l && elem[0:l] == "sh-key" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch r.Method {
						case "GET":
							s.handleListSSHKeysRequest([0]string{}, elemIsEscaped, w, r)
						case "POST":
							s.handleRegisterSSHKeyRequest([0]string{}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "GET,POST")
						}

						return
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							// Leaf node.
							switch r.Method {
							case "DELETE":
								s.handleDeleteSSHKeyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							case "GET":
								s.handleGetSSHKeyRequest([1]string{
									args[0],
								}, elemIsEscaped, w, r)
							default:
								s.notAllowed(w, r, "DELETE,GET")
							}

							return
						}
					}
				}
			case 't': // Prefix: "template"
				if l := len("template"); len(elem) >= l && elem[0:l] == "template" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch r.Method {
					case "GET":
						s.handleListTemplatesRequest([0]string{}, elemIsEscaped, w, r)
					case "POST":
						s.handleRegisterTemplateRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET,POST")
					}

					return
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						// Leaf node.
						switch r.Method {
						case "DELETE":
							s.handleDeleteTemplateRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "GET":
							s.handleGetTemplateRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "POST":
							s.handleCopyTemplateRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						case "PUT":
							s.handleUpdateTemplateRequest([1]string{
								args[0],
							}, elemIsEscaped, w, r)
						default:
							s.notAllowed(w, r, "DELETE,GET,POST,PUT")
						}

						return
					}
				}
			case 'z': // Prefix: "zone"
				if l := len("zone"); len(elem) >= l && elem[0:l] == "zone" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					// Leaf node.
					switch r.Method {
					case "GET":
						s.handleListZonesRequest([0]string{}, elemIsEscaped, w, r)
					default:
						s.notAllowed(w, r, "GET")
					}

					return
				}
			}
		}
	}
	s.notFound(w, r)
}

// Route is route object.
type Route struct {
	name        string
	operationID string
	pathPattern string
	count       int
	args        [3]string
}

// Name returns ogen operation name.
//
// It is guaranteed to be unique and not empty.
func (r Route) Name() string {
	return r.name
}

// OperationID returns OpenAPI operationId.
func (r Route) OperationID() string {
	return r.operationID
}

// PathPattern returns OpenAPI path.
func (r Route) PathPattern() string {
	return r.pathPattern
}

// Args returns parsed arguments.
func (r Route) Args() []string {
	return r.args[:r.count]
}

// FindRoute finds Route for given method and path.
//
// Note: this method does not unescape path or handle reserved characters in path properly. Use FindPath instead.
func (s *Server) FindRoute(method, path string) (Route, bool) {
	return s.FindPath(method, &url.URL{Path: path})
}

// FindPath finds Route for given method and URL.
func (s *Server) FindPath(method string, u *url.URL) (r Route, _ bool) {
	var (
		elem = u.Path
		args = r.args
	)
	if rawPath := u.RawPath; rawPath != "" {
		if normalized, ok := uri.NormalizeEscapedPath(rawPath); ok {
			elem = normalized
		}
		defer func() {
			for i, arg := range r.args[:r.count] {
				if unescaped, err := url.PathUnescape(arg); err == nil {
					r.args[i] = unescaped
				}
			}
		}()
	}

	// Static code generated router with unwrapped path search.
	switch {
	default:
		if len(elem) == 0 {
			break
		}
		switch elem[0] {
		case '/': // Prefix: "/"
			if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
				elem = elem[l:]
			} else {
				break
			}

			if len(elem) == 0 {
				break
			}
			switch elem[0] {
			case 'a': // Prefix: "a"
				if l := len("a"); len(elem) >= l && elem[0:l] == "a" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'c': // Prefix: "ccess-key"
					if l := len("ccess-key"); len(elem) >= l && elem[0:l] == "ccess-key" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListAccessKeys"
							r.operationID = "list-access-keys"
							r.pathPattern = "/access-key"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateAccessKey"
							r.operationID = "create-access-key"
							r.pathPattern = "/access-key"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '-': // Prefix: "-"
						if l := len("-"); len(elem) >= l && elem[0:l] == "-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'k': // Prefix: "known-operations"
							if l := len("known-operations"); len(elem) >= l && elem[0:l] == "known-operations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ListAccessKeyKnownOperations
									r.name = "ListAccessKeyKnownOperations"
									r.operationID = "list-access-key-known-operations"
									r.pathPattern = "/access-key-known-operations"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						case 'o': // Prefix: "operations"
							if l := len("operations"); len(elem) >= l && elem[0:l] == "operations" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ListAccessKeyOperations
									r.name = "ListAccessKeyOperations"
									r.operationID = "list-access-key-operations"
									r.pathPattern = "/access-key-operations"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						}
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "key"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: RevokeAccessKey
								r.name = "RevokeAccessKey"
								r.operationID = "revoke-access-key"
								r.pathPattern = "/access-key/{key}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								// Leaf: GetAccessKey
								r.name = "GetAccessKey"
								r.operationID = "get-access-key"
								r.pathPattern = "/access-key/{key}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					}
				case 'n': // Prefix: "nti-affinity-group"
					if l := len("nti-affinity-group"); len(elem) >= l && elem[0:l] == "nti-affinity-group" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "POST":
							r.name = "CreateAntiAffinityGroup"
							r.operationID = "create-anti-affinity-group"
							r.pathPattern = "/anti-affinity-group"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: DeleteAntiAffinityGroup
								r.name = "DeleteAntiAffinityGroup"
								r.operationID = "delete-anti-affinity-group"
								r.pathPattern = "/anti-affinity-group/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					}
				case 'p': // Prefix: "pi-key"
					if l := len("pi-key"); len(elem) >= l && elem[0:l] == "pi-key" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListAPIKeys"
							r.operationID = "list-api-keys"
							r.pathPattern = "/api-key"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateAPIKey"
							r.operationID = "create-api-key"
							r.pathPattern = "/api-key"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: DeleteAPIKey
								r.name = "DeleteAPIKey"
								r.operationID = "delete-api-key"
								r.pathPattern = "/api-key/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								// Leaf: GetAPIKey
								r.name = "GetAPIKey"
								r.operationID = "get-api-key"
								r.pathPattern = "/api-key/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					}
				}
			case 'd': // Prefix: "d"
				if l := len("d"); len(elem) >= l && elem[0:l] == "d" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'b': // Prefix: "baas-"
					if l := len("baas-"); len(elem) >= l && elem[0:l] == "baas-" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'c': // Prefix: "ca-certificate"
						if l := len("ca-certificate"); len(elem) >= l && elem[0:l] == "ca-certificate" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetDbaasCaCertificate
								r.name = "GetDbaasCaCertificate"
								r.operationID = "get-dbaas-ca-certificate"
								r.pathPattern = "/dbaas-ca-certificate"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					case 'i': // Prefix: "integration"
						if l := len("integration"); len(elem) >= l && elem[0:l] == "integration" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "POST":
								r.name = "CreateDbaasIntegration"
								r.operationID = "create-dbaas-integration"
								r.pathPattern = "/dbaas-integration"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '-': // Prefix: "-"
							if l := len("-"); len(elem) >= l && elem[0:l] == "-" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 's': // Prefix: "settings/"
								if l := len("settings/"); len(elem) >= l && elem[0:l] == "settings/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "integration-type"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[0] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "source-type"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "dest-type"
										// Leaf parameter
										args[2] = elem
										elem = ""

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: ListDbaasIntegrationSettings
												r.name = "ListDbaasIntegrationSettings"
												r.operationID = "list-dbaas-integration-settings"
												r.pathPattern = "/dbaas-integration-settings/{integration-type}/{source-type}/{dest-type}"
												r.args = args
												r.count = 3
												return r, true
											default:
												return
											}
										}
									}
								}
							case 't': // Prefix: "types"
								if l := len("types"); len(elem) >= l && elem[0:l] == "types" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: ListDbaasIntegrationTypes
										r.name = "ListDbaasIntegrationTypes"
										r.operationID = "list-dbaas-integration-types"
										r.pathPattern = "/dbaas-integration-types"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
							}
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: DeleteDbaasIntegration
									r.name = "DeleteDbaasIntegration"
									r.operationID = "delete-dbaas-integration"
									r.pathPattern = "/dbaas-integration/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									// Leaf: GetDbaasIntegration
									r.name = "GetDbaasIntegration"
									r.operationID = "get-dbaas-integration"
									r.pathPattern = "/dbaas-integration/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "PUT":
									// Leaf: UpdateDbaasIntegration
									r.name = "UpdateDbaasIntegration"
									r.operationID = "update-dbaas-integration"
									r.pathPattern = "/dbaas-integration/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					case 'k': // Prefix: "kafka/"
						if l := len("kafka/"); len(elem) >= l && elem[0:l] == "kafka/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "GetDbaasServiceKafka"
								r.operationID = "get-dbaas-service-kafka"
								r.pathPattern = "/dbaas-kafka/{name}"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = "CreateDbaasServiceKafka"
								r.operationID = "create-dbaas-service-kafka"
								r.pathPattern = "/dbaas-kafka/{name}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = "UpdateDbaasServiceKafka"
								r.operationID = "update-dbaas-service-kafka"
								r.pathPattern = "/dbaas-kafka/{name}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "acl-config"
								if l := len("acl-config"); len(elem) >= l && elem[0:l] == "acl-config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetDbaasKafkaACLConfig
										r.name = "GetDbaasKafkaACLConfig"
										r.operationID = "get-dbaas-kafka-acl-config"
										r.pathPattern = "/dbaas-kafka/{name}/acl-config"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'm': // Prefix: "maintenance/start"
								if l := len("maintenance/start"); len(elem) >= l && elem[0:l] == "maintenance/start" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "PUT":
										// Leaf: StartDbaasKafkaMaintenance
										r.name = "StartDbaasKafkaMaintenance"
										r.operationID = "start-dbaas-kafka-maintenance"
										r.pathPattern = "/dbaas-kafka/{name}/maintenance/start"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 's': // Prefix: "schema-registry/acl-config"
								if l := len("schema-registry/acl-config"); len(elem) >= l && elem[0:l] == "schema-registry/acl-config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = "CreateDbaasKafkaSchemaRegistryACLConfig"
										r.operationID = "create-dbaas-kafka-schema-registry-acl-config"
										r.pathPattern = "/dbaas-kafka/{name}/schema-registry/acl-config"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "acl-id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: DeleteDbaasKafkaSchemaRegistryACLConfig
											r.name = "DeleteDbaasKafkaSchemaRegistryACLConfig"
											r.operationID = "delete-dbaas-kafka-schema-registry-acl-config"
											r.pathPattern = "/dbaas-kafka/{name}/schema-registry/acl-config/{acl-id}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								}
							case 't': // Prefix: "topic/acl-config"
								if l := len("topic/acl-config"); len(elem) >= l && elem[0:l] == "topic/acl-config" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = "CreateDbaasKafkaTopicACLConfig"
										r.operationID = "create-dbaas-kafka-topic-acl-config"
										r.pathPattern = "/dbaas-kafka/{name}/topic/acl-config"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "acl-id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: DeleteDbaasKafkaTopicACLConfig
											r.name = "DeleteDbaasKafkaTopicACLConfig"
											r.operationID = "delete-dbaas-kafka-topic-acl-config"
											r.pathPattern = "/dbaas-kafka/{name}/topic/acl-config/{acl-id}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								}
							case 'u': // Prefix: "user"
								if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = "CreateDbaasKafkaUser"
										r.operationID = "create-dbaas-kafka-user"
										r.pathPattern = "/dbaas-kafka/{service-name}/user"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											r.name = "DeleteDbaasKafkaUser"
											r.operationID = "delete-dbaas-kafka-user"
											r.pathPattern = "/dbaas-kafka/{service-name}/user/{username}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/password/reset"
										if l := len("/password/reset"); len(elem) >= l && elem[0:l] == "/password/reset" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "PUT":
												// Leaf: ResetDbaasKafkaUserPassword
												r.name = "ResetDbaasKafkaUserPassword"
												r.operationID = "reset-dbaas-kafka-user-password"
												r.pathPattern = "/dbaas-kafka/{service-name}/user/{username}/password/reset"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									}
								}
							}
						}
					case 'm': // Prefix: "m"
						if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'i': // Prefix: "igration-status/"
							if l := len("igration-status/"); len(elem) >= l && elem[0:l] == "igration-status/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "name"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetDbaasMigrationStatus
									r.name = "GetDbaasMigrationStatus"
									r.operationID = "get-dbaas-migration-status"
									r.pathPattern = "/dbaas-migration-status/{name}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'y': // Prefix: "ysql/"
							if l := len("ysql/"); len(elem) >= l && elem[0:l] == "ysql/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "name"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "GetDbaasServiceMysql"
									r.operationID = "get-dbaas-service-mysql"
									r.pathPattern = "/dbaas-mysql/{name}"
									r.args = args
									r.count = 1
									return r, true
								case "POST":
									r.name = "CreateDbaasServiceMysql"
									r.operationID = "create-dbaas-service-mysql"
									r.pathPattern = "/dbaas-mysql/{name}"
									r.args = args
									r.count = 1
									return r, true
								case "PUT":
									r.name = "UpdateDbaasServiceMysql"
									r.operationID = "update-dbaas-service-mysql"
									r.pathPattern = "/dbaas-mysql/{name}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/m"
								if l := len("/m"); len(elem) >= l && elem[0:l] == "/m" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "aintenance/start"
									if l := len("aintenance/start"); len(elem) >= l && elem[0:l] == "aintenance/start" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											// Leaf: StartDbaasMysqlMaintenance
											r.name = "StartDbaasMysqlMaintenance"
											r.operationID = "start-dbaas-mysql-maintenance"
											r.pathPattern = "/dbaas-mysql/{name}/maintenance/start"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'i': // Prefix: "igration/stop"
									if l := len("igration/stop"); len(elem) >= l && elem[0:l] == "igration/stop" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: StopDbaasMysqlMigration
											r.name = "StopDbaasMysqlMigration"
											r.operationID = "stop-dbaas-mysql-migration"
											r.pathPattern = "/dbaas-mysql/{name}/migration/stop"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							}
						}
					case 'o': // Prefix: "opensearch/"
						if l := len("opensearch/"); len(elem) >= l && elem[0:l] == "opensearch/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "GetDbaasServiceOpensearch"
								r.operationID = "get-dbaas-service-opensearch"
								r.pathPattern = "/dbaas-opensearch/{name}"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = "CreateDbaasServiceOpensearch"
								r.operationID = "create-dbaas-service-opensearch"
								r.pathPattern = "/dbaas-opensearch/{name}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = "UpdateDbaasServiceOpensearch"
								r.operationID = "update-dbaas-service-opensearch"
								r.pathPattern = "/dbaas-opensearch/{name}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/maintenance/start"
							if l := len("/maintenance/start"); len(elem) >= l && elem[0:l] == "/maintenance/start" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "PUT":
									// Leaf: StartDbaasOpensearchMaintenance
									r.name = "StartDbaasOpensearchMaintenance"
									r.operationID = "start-dbaas-opensearch-maintenance"
									r.pathPattern = "/dbaas-opensearch/{name}/maintenance/start"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					case 'p': // Prefix: "postgres/"
						if l := len("postgres/"); len(elem) >= l && elem[0:l] == "postgres/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "service-name"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "GetDbaasServicePg"
								r.operationID = "get-dbaas-service-pg"
								r.pathPattern = "/dbaas-postgres/{name}"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = "CreateDbaasServicePg"
								r.operationID = "create-dbaas-service-pg"
								r.pathPattern = "/dbaas-postgres/{name}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = "UpdateDbaasServicePg"
								r.operationID = "update-dbaas-service-pg"
								r.pathPattern = "/dbaas-postgres/{name}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'm': // Prefix: "m"
								if l := len("m"); len(elem) >= l && elem[0:l] == "m" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'a': // Prefix: "aintenance/start"
									if l := len("aintenance/start"); len(elem) >= l && elem[0:l] == "aintenance/start" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											// Leaf: StartDbaasPgMaintenance
											r.name = "StartDbaasPgMaintenance"
											r.operationID = "start-dbaas-pg-maintenance"
											r.pathPattern = "/dbaas-postgres/{name}/maintenance/start"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'i': // Prefix: "igration/stop"
									if l := len("igration/stop"); len(elem) >= l && elem[0:l] == "igration/stop" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: StopDbaasPgMigration
											r.name = "StopDbaasPgMigration"
											r.operationID = "stop-dbaas-pg-migration"
											r.pathPattern = "/dbaas-postgres/{name}/migration/stop"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							case 'u': // Prefix: "user"
								if l := len("user"); len(elem) >= l && elem[0:l] == "user" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										r.name = "CreateDbaasPostgresUser"
										r.operationID = "create-dbaas-postgres-user"
										r.pathPattern = "/dbaas-postgres/{service-name}/user"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "username"
									// Match until "/"
									idx := strings.IndexByte(elem, '/')
									if idx < 0 {
										idx = len(elem)
									}
									args[1] = elem[:idx]
									elem = elem[idx:]

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											r.name = "DeleteDbaasPostgresUser"
											r.operationID = "delete-dbaas-postgres-user"
											r.pathPattern = "/dbaas-postgres/{service-name}/user/{username}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											break
										}
										switch elem[0] {
										case 'a': // Prefix: "allow-replication"
											if l := len("allow-replication"); len(elem) >= l && elem[0:l] == "allow-replication" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "PUT":
													// Leaf: UpdateDbaasPostgresAllowReplication
													r.name = "UpdateDbaasPostgresAllowReplication"
													r.operationID = "update-dbaas-postgres-allow-replication"
													r.pathPattern = "/dbaas-postgres/{service-name}/user/{username}/allow-replication"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										case 'p': // Prefix: "password/reset"
											if l := len("password/reset"); len(elem) >= l && elem[0:l] == "password/reset" {
												elem = elem[l:]
											} else {
												break
											}

											if len(elem) == 0 {
												switch method {
												case "PUT":
													// Leaf: ResetDbaasPostgresUserPassword
													r.name = "ResetDbaasPostgresUserPassword"
													r.operationID = "reset-dbaas-postgres-user-password"
													r.pathPattern = "/dbaas-postgres/{service-name}/user/{username}/password/reset"
													r.args = args
													r.count = 2
													return r, true
												default:
													return
												}
											}
										}
									}
								}
							}
						}
					case 'r': // Prefix: "redis/"
						if l := len("redis/"); len(elem) >= l && elem[0:l] == "redis/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "GetDbaasServiceRedis"
								r.operationID = "get-dbaas-service-redis"
								r.pathPattern = "/dbaas-redis/{name}"
								r.args = args
								r.count = 1
								return r, true
							case "POST":
								r.name = "CreateDbaasServiceRedis"
								r.operationID = "create-dbaas-service-redis"
								r.pathPattern = "/dbaas-redis/{name}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = "UpdateDbaasServiceRedis"
								r.operationID = "update-dbaas-service-redis"
								r.pathPattern = "/dbaas-redis/{name}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/m"
							if l := len("/m"); len(elem) >= l && elem[0:l] == "/m" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "aintenance/start"
								if l := len("aintenance/start"); len(elem) >= l && elem[0:l] == "aintenance/start" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "PUT":
										// Leaf: StartDbaasRedisMaintenance
										r.name = "StartDbaasRedisMaintenance"
										r.operationID = "start-dbaas-redis-maintenance"
										r.pathPattern = "/dbaas-redis/{name}/maintenance/start"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'i': // Prefix: "igration/stop"
								if l := len("igration/stop"); len(elem) >= l && elem[0:l] == "igration/stop" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: StopDbaasRedisMigration
										r.name = "StopDbaasRedisMigration"
										r.operationID = "stop-dbaas-redis-migration"
										r.pathPattern = "/dbaas-redis/{name}/migration/stop"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					case 's': // Prefix: "se"
						if l := len("se"); len(elem) >= l && elem[0:l] == "se" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'r': // Prefix: "rvice"
							if l := len("rvice"); len(elem) >= l && elem[0:l] == "rvice" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "ListDbaasServices"
									r.operationID = "list-dbaas-services"
									r.pathPattern = "/dbaas-service"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '-': // Prefix: "-"
								if l := len("-"); len(elem) >= l && elem[0:l] == "-" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'l': // Prefix: "logs/"
									if l := len("logs/"); len(elem) >= l && elem[0:l] == "logs/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "service-name"
									// Leaf parameter
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: GetDbaasServiceLogs
											r.name = "GetDbaasServiceLogs"
											r.operationID = "get-dbaas-service-logs"
											r.pathPattern = "/dbaas-service-logs/{service-name}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'm': // Prefix: "metrics/"
									if l := len("metrics/"); len(elem) >= l && elem[0:l] == "metrics/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "service-name"
									// Leaf parameter
									args[0] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: GetDbaasServiceMetrics
											r.name = "GetDbaasServiceMetrics"
											r.operationID = "get-dbaas-service-metrics"
											r.pathPattern = "/dbaas-service-metrics/{service-name}"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 't': // Prefix: "type"
									if l := len("type"); len(elem) >= l && elem[0:l] == "type" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											r.name = "ListDbaasServiceTypes"
											r.operationID = "list-dbaas-service-types"
											r.pathPattern = "/dbaas-service-type"
											r.args = args
											r.count = 0
											return r, true
										default:
											return
										}
									}
									switch elem[0] {
									case '/': // Prefix: "/"
										if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
											elem = elem[l:]
										} else {
											break
										}

										// Param: "service-type-name"
										// Leaf parameter
										args[0] = elem
										elem = ""

										if len(elem) == 0 {
											switch method {
											case "GET":
												// Leaf: GetDbaasServiceType
												r.name = "GetDbaasServiceType"
												r.operationID = "get-dbaas-service-type"
												r.pathPattern = "/dbaas-service-type/{service-type-name}"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									}
								}
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "name"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: DeleteDbaasService
										r.name = "DeleteDbaasService"
										r.operationID = "delete-dbaas-service"
										r.pathPattern = "/dbaas-service/{name}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						case 't': // Prefix: "ttings-"
							if l := len("ttings-"); len(elem) >= l && elem[0:l] == "ttings-" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'k': // Prefix: "kafka"
								if l := len("kafka"); len(elem) >= l && elem[0:l] == "kafka" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetDbaasSettingsKafka
										r.name = "GetDbaasSettingsKafka"
										r.operationID = "get-dbaas-settings-kafka"
										r.pathPattern = "/dbaas-settings-kafka"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
							case 'm': // Prefix: "mysql"
								if l := len("mysql"); len(elem) >= l && elem[0:l] == "mysql" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetDbaasSettingsMysql
										r.name = "GetDbaasSettingsMysql"
										r.operationID = "get-dbaas-settings-mysql"
										r.pathPattern = "/dbaas-settings-mysql"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
							case 'o': // Prefix: "opensearch"
								if l := len("opensearch"); len(elem) >= l && elem[0:l] == "opensearch" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetDbaasSettingsOpensearch
										r.name = "GetDbaasSettingsOpensearch"
										r.operationID = "get-dbaas-settings-opensearch"
										r.pathPattern = "/dbaas-settings-opensearch"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
							case 'p': // Prefix: "pg"
								if l := len("pg"); len(elem) >= l && elem[0:l] == "pg" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetDbaasSettingsPg
										r.name = "GetDbaasSettingsPg"
										r.operationID = "get-dbaas-settings-pg"
										r.pathPattern = "/dbaas-settings-pg"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
							case 'r': // Prefix: "redis"
								if l := len("redis"); len(elem) >= l && elem[0:l] == "redis" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetDbaasSettingsRedis
										r.name = "GetDbaasSettingsRedis"
										r.operationID = "get-dbaas-settings-redis"
										r.pathPattern = "/dbaas-settings-redis"
										r.args = args
										r.count = 0
										return r, true
									default:
										return
									}
								}
							}
						}
					case 't': // Prefix: "task"
						if l := len("task"); len(elem) >= l && elem[0:l] == "task" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '-': // Prefix: "-migration-check/"
							if l := len("-migration-check/"); len(elem) >= l && elem[0:l] == "-migration-check/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "service"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: CreateDbaasTaskMigrationCheck
									r.name = "CreateDbaasTaskMigrationCheck"
									r.operationID = "create-dbaas-task-migration-check"
									r.pathPattern = "/dbaas-task-migration-check/{service}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "service"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetDbaasTask
										r.name = "GetDbaasTask"
										r.operationID = "get-dbaas-task"
										r.pathPattern = "/dbaas-task/{service}/{id}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
							}
						}
					}
				case 'e': // Prefix: "eploy-target"
					if l := len("eploy-target"); len(elem) >= l && elem[0:l] == "eploy-target" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListDeployTargets"
							r.operationID = "list-deploy-targets"
							r.pathPattern = "/deploy-target"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetDeployTarget
								r.name = "GetDeployTarget"
								r.operationID = "get-deploy-target"
								r.pathPattern = "/deploy-target/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					}
				case 'n': // Prefix: "ns-domain"
					if l := len("ns-domain"); len(elem) >= l && elem[0:l] == "ns-domain" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListDNSDomains"
							r.operationID = "list-dns-domains"
							r.pathPattern = "/dns-domain"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateDNSDomain"
							r.operationID = "create-dns-domain"
							r.pathPattern = "/dns-domain"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "domain-id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteDNSDomain"
								r.operationID = "delete-dns-domain"
								r.pathPattern = "/dns-domain/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "GetDNSDomain"
								r.operationID = "get-dns-domain"
								r.pathPattern = "/dns-domain/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'r': // Prefix: "record"
								if l := len("record"); len(elem) >= l && elem[0:l] == "record" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										r.name = "ListDNSDomainRecords"
										r.operationID = "list-dns-domain-records"
										r.pathPattern = "/dns-domain/{domain-id}/record"
										r.args = args
										r.count = 1
										return r, true
									case "POST":
										r.name = "CreateDNSDomainRecord"
										r.operationID = "create-dns-domain-record"
										r.pathPattern = "/dns-domain/{domain-id}/record"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "record-id"
									// Leaf parameter
									args[1] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: DeleteDNSDomainRecord
											r.name = "DeleteDNSDomainRecord"
											r.operationID = "delete-dns-domain-record"
											r.pathPattern = "/dns-domain/{domain-id}/record/{record-id}"
											r.args = args
											r.count = 2
											return r, true
										case "GET":
											// Leaf: GetDNSDomainRecord
											r.name = "GetDNSDomainRecord"
											r.operationID = "get-dns-domain-record"
											r.pathPattern = "/dns-domain/{domain-id}/record/{record-id}"
											r.args = args
											r.count = 2
											return r, true
										case "PUT":
											// Leaf: UpdateDNSDomainRecord
											r.name = "UpdateDNSDomainRecord"
											r.operationID = "update-dns-domain-record"
											r.pathPattern = "/dns-domain/{domain-id}/record/{record-id}"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								}
							case 'z': // Prefix: "zone"
								if l := len("zone"); len(elem) >= l && elem[0:l] == "zone" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetDNSDomainZoneFile
										r.name = "GetDNSDomainZoneFile"
										r.operationID = "get-dns-domain-zone-file"
										r.pathPattern = "/dns-domain/{id}/zone"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					}
				}
			case 'e': // Prefix: "e"
				if l := len("e"); len(elem) >= l && elem[0:l] == "e" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'l': // Prefix: "lastic-ip"
					if l := len("lastic-ip"); len(elem) >= l && elem[0:l] == "lastic-ip" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListElasticIps"
							r.operationID = "list-elastic-ips"
							r.pathPattern = "/elastic-ip"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "CreateElasticIP"
							r.operationID = "create-elastic-ip"
							r.pathPattern = "/elastic-ip"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteElasticIP"
								r.operationID = "delete-elastic-ip"
								r.pathPattern = "/elastic-ip/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								r.name = "GetElasticIP"
								r.operationID = "get-elastic-ip"
								r.pathPattern = "/elastic-ip/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = "UpdateElasticIP"
								r.operationID = "update-elastic-ip"
								r.pathPattern = "/elastic-ip/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "field"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: ResetElasticIPField
									r.name = "ResetElasticIPField"
									r.operationID = "reset-elastic-ip-field"
									r.pathPattern = "/elastic-ip/{id}/{field}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
						}
					}
				case 'v': // Prefix: "vent"
					if l := len("vent"); len(elem) >= l && elem[0:l] == "vent" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: ListEvents
							r.name = "ListEvents"
							r.operationID = "list-events"
							r.pathPattern = "/event"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
				}
			case 'i': // Prefix: "i"
				if l := len("i"); len(elem) >= l && elem[0:l] == "i" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'a': // Prefix: "am-"
					if l := len("am-"); len(elem) >= l && elem[0:l] == "am-" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case 'o': // Prefix: "organization-policy"
						if l := len("organization-policy"); len(elem) >= l && elem[0:l] == "organization-policy" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: GetIamOrganizationPolicy
								r.name = "GetIamOrganizationPolicy"
								r.operationID = "get-iam-organization-policy"
								r.pathPattern = "/iam-organization-policy"
								r.args = args
								r.count = 0
								return r, true
							case "PUT":
								// Leaf: UpdateIamOrganizationPolicy
								r.name = "UpdateIamOrganizationPolicy"
								r.operationID = "update-iam-organization-policy"
								r.pathPattern = "/iam-organization-policy"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					case 'r': // Prefix: "role"
						if l := len("role"); len(elem) >= l && elem[0:l] == "role" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								r.name = "ListIamRoles"
								r.operationID = "list-iam-roles"
								r.pathPattern = "/iam-role"
								r.args = args
								r.count = 0
								return r, true
							case "POST":
								r.name = "CreateIamRole"
								r.operationID = "create-iam-role"
								r.pathPattern = "/iam-role"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Match until ":"
							idx := strings.IndexByte(elem, ':')
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = "DeleteIamRole"
									r.operationID = "delete-iam-role"
									r.pathPattern = "/iam-role/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "GET":
									r.name = "GetIamRole"
									r.operationID = "get-iam-role"
									r.pathPattern = "/iam-role/{id}"
									r.args = args
									r.count = 1
									return r, true
								case "PUT":
									r.name = "UpdateIamRole"
									r.operationID = "update-iam-role"
									r.pathPattern = "/iam-role/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case ':': // Prefix: ":policy"
								if l := len(":policy"); len(elem) >= l && elem[0:l] == ":policy" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "PUT":
										// Leaf: UpdateIamRolePolicy
										r.name = "UpdateIamRolePolicy"
										r.operationID = "update-iam-role-policy"
										r.pathPattern = "/iam-role/{id}:policy"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					}
				case 'n': // Prefix: "nstance"
					if l := len("nstance"); len(elem) >= l && elem[0:l] == "nstance" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '-': // Prefix: "-"
						if l := len("-"); len(elem) >= l && elem[0:l] == "-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'p': // Prefix: "pool/"
							if l := len("pool/"); len(elem) >= l && elem[0:l] == "pool/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Match until one of "/:"
							idx := strings.IndexAny(elem, "/:")
							if idx < 0 {
								idx = len(elem)
							}
							args[0] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = "DeleteInstancePool"
									r.operationID = "delete-instance-pool"
									r.pathPattern = "/instance-pool/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "field"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: ResetInstancePoolField
										r.name = "ResetInstancePoolField"
										r.operationID = "reset-instance-pool-field"
										r.pathPattern = "/instance-pool/{id}/{field}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
							case ':': // Prefix: ":"
								if l := len(":"); len(elem) >= l && elem[0:l] == ":" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'e': // Prefix: "evict"
									if l := len("evict"); len(elem) >= l && elem[0:l] == "evict" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											// Leaf: EvictInstancePoolMembers
											r.name = "EvictInstancePoolMembers"
											r.operationID = "evict-instance-pool-members"
											r.pathPattern = "/instance-pool/{id}:evict"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 's': // Prefix: "scale"
									if l := len("scale"); len(elem) >= l && elem[0:l] == "scale" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											// Leaf: ScaleInstancePool
											r.name = "ScaleInstancePool"
											r.operationID = "scale-instance-pool"
											r.pathPattern = "/instance-pool/{id}:scale"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							}
						case 't': // Prefix: "type"
							if l := len("type"); len(elem) >= l && elem[0:l] == "type" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									r.name = "ListInstanceTypes"
									r.operationID = "list-instance-types"
									r.pathPattern = "/instance-type"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "id"
								// Leaf parameter
								args[0] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: GetInstanceType
										r.name = "GetInstanceType"
										r.operationID = "get-instance-type"
										r.pathPattern = "/instance-type/{id}"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until one of "/:"
						idx := strings.IndexAny(elem, "/:")
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteInstance"
								r.operationID = "delete-instance"
								r.pathPattern = "/instance/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = "UpdateInstance"
								r.operationID = "update-instance"
								r.pathPattern = "/instance/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "field"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: ResetInstanceField
									r.name = "ResetInstanceField"
									r.operationID = "reset-instance-field"
									r.pathPattern = "/instance/{id}/{field}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
						case ':': // Prefix: ":"
							if l := len(":"); len(elem) >= l && elem[0:l] == ":" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "add-protection"
								if l := len("add-protection"); len(elem) >= l && elem[0:l] == "add-protection" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "PUT":
										// Leaf: AddInstanceProtection
										r.name = "AddInstanceProtection"
										r.operationID = "add-instance-protection"
										r.pathPattern = "/instance/{id}:add-protection"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'c': // Prefix: "create-snapshot"
								if l := len("create-snapshot"); len(elem) >= l && elem[0:l] == "create-snapshot" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "POST":
										// Leaf: CreateSnapshot
										r.name = "CreateSnapshot"
										r.operationID = "create-snapshot"
										r.pathPattern = "/instance/{id}:create-snapshot"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'p': // Prefix: "password"
								if l := len("password"); len(elem) >= l && elem[0:l] == "password" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "GET":
										// Leaf: RevealInstancePassword
										r.name = "RevealInstancePassword"
										r.operationID = "reveal-instance-password"
										r.pathPattern = "/instance/{id}:password"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'r': // Prefix: "re"
								if l := len("re"); len(elem) >= l && elem[0:l] == "re" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'b': // Prefix: "boot"
									if l := len("boot"); len(elem) >= l && elem[0:l] == "boot" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											// Leaf: RebootInstance
											r.name = "RebootInstance"
											r.operationID = "reboot-instance"
											r.pathPattern = "/instance/{id}:reboot"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'm': // Prefix: "move-protection"
									if l := len("move-protection"); len(elem) >= l && elem[0:l] == "move-protection" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											// Leaf: RemoveInstanceProtection
											r.name = "RemoveInstanceProtection"
											r.operationID = "remove-instance-protection"
											r.pathPattern = "/instance/{id}:remove-protection"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 's': // Prefix: "s"
									if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "et"
										if l := len("et"); len(elem) >= l && elem[0:l] == "et" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "PUT":
												// Leaf: ResetInstance
												r.name = "ResetInstance"
												r.operationID = "reset-instance"
												r.pathPattern = "/instance/{id}:reset"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									case 'i': // Prefix: "ize-disk"
										if l := len("ize-disk"); len(elem) >= l && elem[0:l] == "ize-disk" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "PUT":
												// Leaf: ResizeInstanceDisk
												r.name = "ResizeInstanceDisk"
												r.operationID = "resize-instance-disk"
												r.pathPattern = "/instance/{id}:resize-disk"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									}
								case 'v': // Prefix: "vert-snapshot"
									if l := len("vert-snapshot"); len(elem) >= l && elem[0:l] == "vert-snapshot" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "POST":
											// Leaf: RevertInstanceToSnapshot
											r.name = "RevertInstanceToSnapshot"
											r.operationID = "revert-instance-to-snapshot"
											r.pathPattern = "/instance/{instance-id}:revert-snapshot"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							case 's': // Prefix: "s"
								if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "cale"
									if l := len("cale"); len(elem) >= l && elem[0:l] == "cale" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											// Leaf: ScaleInstance
											r.name = "ScaleInstance"
											r.operationID = "scale-instance"
											r.pathPattern = "/instance/{id}:scale"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 't': // Prefix: "t"
									if l := len("t"); len(elem) >= l && elem[0:l] == "t" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'a': // Prefix: "art"
										if l := len("art"); len(elem) >= l && elem[0:l] == "art" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "PUT":
												// Leaf: StartInstance
												r.name = "StartInstance"
												r.operationID = "start-instance"
												r.pathPattern = "/instance/{id}:start"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									case 'o': // Prefix: "op"
										if l := len("op"); len(elem) >= l && elem[0:l] == "op" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "PUT":
												// Leaf: StopInstance
												r.name = "StopInstance"
												r.operationID = "stop-instance"
												r.pathPattern = "/instance/{id}:stop"
												r.args = args
												r.count = 1
												return r, true
											default:
												return
											}
										}
									}
								}
							}
						}
					}
				}
			case 'l': // Prefix: "load-balancer"
				if l := len("load-balancer"); len(elem) >= l && elem[0:l] == "load-balancer" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "POST":
						r.name = "CreateLoadBalancer"
						r.operationID = "create-load-balancer"
						r.pathPattern = "/load-balancer"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until "/"
					idx := strings.IndexByte(elem, '/')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = "DeleteLoadBalancer"
							r.operationID = "delete-load-balancer"
							r.pathPattern = "/load-balancer/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "PUT":
							r.name = "UpdateLoadBalancer"
							r.operationID = "update-load-balancer"
							r.pathPattern = "/load-balancer/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 's': // Prefix: "service/"
							if l := len("service/"); len(elem) >= l && elem[0:l] == "service/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "service-id"
							// Match until "/"
							idx := strings.IndexByte(elem, '/')
							if idx < 0 {
								idx = len(elem)
							}
							args[1] = elem[:idx]
							elem = elem[idx:]

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									r.name = "DeleteLoadBalancerService"
									r.operationID = "delete-load-balancer-service"
									r.pathPattern = "/load-balancer/{id}/service/{service-id}"
									r.args = args
									r.count = 2
									return r, true
								case "PUT":
									r.name = "UpdateLoadBalancerService"
									r.operationID = "update-load-balancer-service"
									r.pathPattern = "/load-balancer/{id}/service/{service-id}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "field"
								// Leaf parameter
								args[2] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: ResetLoadBalancerServiceField
										r.name = "ResetLoadBalancerServiceField"
										r.operationID = "reset-load-balancer-service-field"
										r.pathPattern = "/load-balancer/{id}/service/{service-id}/{field}"
										r.args = args
										r.count = 3
										return r, true
									default:
										return
									}
								}
							}
						}
						// Param: "field"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: ResetLoadBalancerField
								r.name = "ResetLoadBalancerField"
								r.operationID = "reset-load-balancer-field"
								r.pathPattern = "/load-balancer/{id}/{field}"
								r.args = args
								r.count = 2
								return r, true
							default:
								return
							}
						}
					}
				}
			case 'o': // Prefix: "operation/"
				if l := len("operation/"); len(elem) >= l && elem[0:l] == "operation/" {
					elem = elem[l:]
				} else {
					break
				}

				// Param: "id"
				// Leaf parameter
				args[0] = elem
				elem = ""

				if len(elem) == 0 {
					switch method {
					case "GET":
						// Leaf: GetOperation
						r.name = "GetOperation"
						r.operationID = "get-operation"
						r.pathPattern = "/operation/{id}"
						r.args = args
						r.count = 1
						return r, true
					default:
						return
					}
				}
			case 'p': // Prefix: "private-network"
				if l := len("private-network"); len(elem) >= l && elem[0:l] == "private-network" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "ListPrivateNetworks"
						r.operationID = "list-private-networks"
						r.pathPattern = "/private-network"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = "CreatePrivateNetwork"
						r.operationID = "create-private-network"
						r.pathPattern = "/private-network"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until one of "/:"
					idx := strings.IndexAny(elem, "/:")
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = "DeletePrivateNetwork"
							r.operationID = "delete-private-network"
							r.pathPattern = "/private-network/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							r.name = "GetPrivateNetwork"
							r.operationID = "get-private-network"
							r.pathPattern = "/private-network/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "PUT":
							r.name = "UpdatePrivateNetwork"
							r.operationID = "update-private-network"
							r.pathPattern = "/private-network/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "field"
						// Leaf parameter
						args[1] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: ResetPrivateNetworkField
								r.name = "ResetPrivateNetworkField"
								r.operationID = "reset-private-network-field"
								r.pathPattern = "/private-network/{id}/{field}"
								r.args = args
								r.count = 2
								return r, true
							default:
								return
							}
						}
					case ':': // Prefix: ":attach"
						if l := len(":attach"); len(elem) >= l && elem[0:l] == ":attach" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "PUT":
								// Leaf: AttachInstanceToPrivateNetwork
								r.name = "AttachInstanceToPrivateNetwork"
								r.operationID = "attach-instance-to-private-network"
								r.pathPattern = "/private-network/{id}:attach"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					}
				}
			case 'q': // Prefix: "quota"
				if l := len("quota"); len(elem) >= l && elem[0:l] == "quota" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "ListQuotas"
						r.operationID = "list-quotas"
						r.pathPattern = "/quota"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "entity"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "GET":
							// Leaf: GetQuota
							r.name = "GetQuota"
							r.operationID = "get-quota"
							r.pathPattern = "/quota/{entity}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
				}
			case 'r': // Prefix: "reverse-dns/"
				if l := len("reverse-dns/"); len(elem) >= l && elem[0:l] == "reverse-dns/" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "elastic-ip/"
					if l := len("elastic-ip/"); len(elem) >= l && elem[0:l] == "elastic-ip/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							// Leaf: DeleteReverseDNSElasticIP
							r.name = "DeleteReverseDNSElasticIP"
							r.operationID = "delete-reverse-dns-elastic-ip"
							r.pathPattern = "/reverse-dns/elastic-ip/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							// Leaf: GetReverseDNSElasticIP
							r.name = "GetReverseDNSElasticIP"
							r.operationID = "get-reverse-dns-elastic-ip"
							r.pathPattern = "/reverse-dns/elastic-ip/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "POST":
							// Leaf: UpdateReverseDNSElasticIP
							r.name = "UpdateReverseDNSElasticIP"
							r.operationID = "update-reverse-dns-elastic-ip"
							r.pathPattern = "/reverse-dns/elastic-ip/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
				case 'i': // Prefix: "instance/"
					if l := len("instance/"); len(elem) >= l && elem[0:l] == "instance/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							// Leaf: DeleteReverseDNSInstance
							r.name = "DeleteReverseDNSInstance"
							r.operationID = "delete-reverse-dns-instance"
							r.pathPattern = "/reverse-dns/instance/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							// Leaf: GetReverseDNSInstance
							r.name = "GetReverseDNSInstance"
							r.operationID = "get-reverse-dns-instance"
							r.pathPattern = "/reverse-dns/instance/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "POST":
							// Leaf: UpdateReverseDNSInstance
							r.name = "UpdateReverseDNSInstance"
							r.operationID = "update-reverse-dns-instance"
							r.pathPattern = "/reverse-dns/instance/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
				}
			case 's': // Prefix: "s"
				if l := len("s"); len(elem) >= l && elem[0:l] == "s" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					break
				}
				switch elem[0] {
				case 'e': // Prefix: "ecurity-group"
					if l := len("ecurity-group"); len(elem) >= l && elem[0:l] == "ecurity-group" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "POST":
							r.name = "CreateSecurityGroup"
							r.operationID = "create-security-group"
							r.pathPattern = "/security-group"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until one of "/:"
						idx := strings.IndexAny(elem, "/:")
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteSecurityGroup"
								r.operationID = "delete-security-group"
								r.pathPattern = "/security-group/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/rules"
							if l := len("/rules"); len(elem) >= l && elem[0:l] == "/rules" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									r.name = "AddRuleToSecurityGroup"
									r.operationID = "add-rule-to-security-group"
									r.pathPattern = "/security-group/{id}/rules"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
							switch elem[0] {
							case '/': // Prefix: "/"
								if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "rule-id"
								// Leaf parameter
								args[1] = elem
								elem = ""

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										// Leaf: DeleteRuleFromSecurityGroup
										r.name = "DeleteRuleFromSecurityGroup"
										r.operationID = "delete-rule-from-security-group"
										r.pathPattern = "/security-group/{id}/rules/{rule-id}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
							}
						case ':': // Prefix: ":"
							if l := len(":"); len(elem) >= l && elem[0:l] == ":" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "add-source"
								if l := len("add-source"); len(elem) >= l && elem[0:l] == "add-source" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "PUT":
										// Leaf: AddExternalSourceToSecurityGroup
										r.name = "AddExternalSourceToSecurityGroup"
										r.operationID = "add-external-source-to-security-group"
										r.pathPattern = "/security-group/{id}:add-source"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							case 'r': // Prefix: "remove-source"
								if l := len("remove-source"); len(elem) >= l && elem[0:l] == "remove-source" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "PUT":
										// Leaf: RemoveExternalSourceFromSecurityGroup
										r.name = "RemoveExternalSourceFromSecurityGroup"
										r.operationID = "remove-external-source-from-security-group"
										r.pathPattern = "/security-group/{id}:remove-source"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
							}
						}
					}
				case 'k': // Prefix: "ks-cluster"
					if l := len("ks-cluster"); len(elem) >= l && elem[0:l] == "ks-cluster" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "POST":
							r.name = "CreateSksCluster"
							r.operationID = "create-sks-cluster"
							r.pathPattern = "/sks-cluster"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '-': // Prefix: "-"
						if l := len("-"); len(elem) >= l && elem[0:l] == "-" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'd': // Prefix: "deprecated-resources/"
							if l := len("deprecated-resources/"); len(elem) >= l && elem[0:l] == "deprecated-resources/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ListSksClusterDeprecatedResources
									r.name = "ListSksClusterDeprecatedResources"
									r.operationID = "list-sks-cluster-deprecated-resources"
									r.pathPattern = "/sks-cluster-deprecated-resources/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'k': // Prefix: "kubeconfig/"
							if l := len("kubeconfig/"); len(elem) >= l && elem[0:l] == "kubeconfig/" {
								elem = elem[l:]
							} else {
								break
							}

							// Param: "id"
							// Leaf parameter
							args[0] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: GenerateSksClusterKubeconfig
									r.name = "GenerateSksClusterKubeconfig"
									r.operationID = "generate-sks-cluster-kubeconfig"
									r.pathPattern = "/sks-cluster-kubeconfig/{id}"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'v': // Prefix: "version"
							if l := len("version"); len(elem) >= l && elem[0:l] == "version" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: ListSksClusterVersions
									r.name = "ListSksClusterVersions"
									r.operationID = "list-sks-cluster-versions"
									r.pathPattern = "/sks-cluster-version"
									r.args = args
									r.count = 0
									return r, true
								default:
									return
								}
							}
						}
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "id"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								r.name = "DeleteSksCluster"
								r.operationID = "delete-sks-cluster"
								r.pathPattern = "/sks-cluster/{id}"
								r.args = args
								r.count = 1
								return r, true
							case "PUT":
								r.name = "UpdateSksCluster"
								r.operationID = "update-sks-cluster"
								r.pathPattern = "/sks-cluster/{id}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
						switch elem[0] {
						case '/': // Prefix: "/"
							if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								break
							}
							switch elem[0] {
							case 'a': // Prefix: "authority/"
								if l := len("authority/"); len(elem) >= l && elem[0:l] == "authority/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "authority"
								// Match until "/"
								idx := strings.IndexByte(elem, '/')
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case '/': // Prefix: "/cert"
									if l := len("/cert"); len(elem) >= l && elem[0:l] == "/cert" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "GET":
											// Leaf: GetSksClusterAuthorityCert
											r.name = "GetSksClusterAuthorityCert"
											r.operationID = "get-sks-cluster-authority-cert"
											r.pathPattern = "/sks-cluster/{id}/authority/{authority}/cert"
											r.args = args
											r.count = 2
											return r, true
										default:
											return
										}
									}
								}
							case 'n': // Prefix: "nodepool/"
								if l := len("nodepool/"); len(elem) >= l && elem[0:l] == "nodepool/" {
									elem = elem[l:]
								} else {
									break
								}

								// Param: "sks-nodepool-id"
								// Match until one of "/:"
								idx := strings.IndexAny(elem, "/:")
								if idx < 0 {
									idx = len(elem)
								}
								args[1] = elem[:idx]
								elem = elem[idx:]

								if len(elem) == 0 {
									switch method {
									case "DELETE":
										r.name = "DeleteSksNodepool"
										r.operationID = "delete-sks-nodepool"
										r.pathPattern = "/sks-cluster/{id}/nodepool/{sks-nodepool-id}"
										r.args = args
										r.count = 2
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '/': // Prefix: "/"
									if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
										elem = elem[l:]
									} else {
										break
									}

									// Param: "field"
									// Leaf parameter
									args[2] = elem
									elem = ""

									if len(elem) == 0 {
										switch method {
										case "DELETE":
											// Leaf: ResetSksNodepoolField
											r.name = "ResetSksNodepoolField"
											r.operationID = "reset-sks-nodepool-field"
											r.pathPattern = "/sks-cluster/{id}/nodepool/{sks-nodepool-id}/{field}"
											r.args = args
											r.count = 3
											return r, true
										default:
											return
										}
									}
								case ':': // Prefix: ":"
									if l := len(":"); len(elem) >= l && elem[0:l] == ":" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										break
									}
									switch elem[0] {
									case 'e': // Prefix: "evict"
										if l := len("evict"); len(elem) >= l && elem[0:l] == "evict" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "PUT":
												// Leaf: EvictSksNodepoolMembers
												r.name = "EvictSksNodepoolMembers"
												r.operationID = "evict-sks-nodepool-members"
												r.pathPattern = "/sks-cluster/{id}/nodepool/{sks-nodepool-id}:evict"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									case 's': // Prefix: "scale"
										if l := len("scale"); len(elem) >= l && elem[0:l] == "scale" {
											elem = elem[l:]
										} else {
											break
										}

										if len(elem) == 0 {
											switch method {
											case "PUT":
												// Leaf: ScaleSksNodepool
												r.name = "ScaleSksNodepool"
												r.operationID = "scale-sks-nodepool"
												r.pathPattern = "/sks-cluster/{id}/nodepool/{sks-nodepool-id}:scale"
												r.args = args
												r.count = 2
												return r, true
											default:
												return
											}
										}
									}
								}
							case 'r': // Prefix: "rotate-"
								if l := len("rotate-"); len(elem) >= l && elem[0:l] == "rotate-" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									break
								}
								switch elem[0] {
								case 'c': // Prefix: "ccm-credentials"
									if l := len("ccm-credentials"); len(elem) >= l && elem[0:l] == "ccm-credentials" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											// Leaf: RotateSksCcmCredentials
											r.name = "RotateSksCcmCredentials"
											r.operationID = "rotate-sks-ccm-credentials"
											r.pathPattern = "/sks-cluster/{id}/rotate-ccm-credentials"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								case 'o': // Prefix: "operators-ca"
									if l := len("operators-ca"); len(elem) >= l && elem[0:l] == "operators-ca" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											// Leaf: RotateSksOperatorsCa
											r.name = "RotateSksOperatorsCa"
											r.operationID = "rotate-sks-operators-ca"
											r.pathPattern = "/sks-cluster/{id}/rotate-operators-ca"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							case 'u': // Prefix: "upgrade"
								if l := len("upgrade"); len(elem) >= l && elem[0:l] == "upgrade" {
									elem = elem[l:]
								} else {
									break
								}

								if len(elem) == 0 {
									switch method {
									case "PUT":
										r.name = "UpgradeSksCluster"
										r.operationID = "upgrade-sks-cluster"
										r.pathPattern = "/sks-cluster/{id}/upgrade"
										r.args = args
										r.count = 1
										return r, true
									default:
										return
									}
								}
								switch elem[0] {
								case '-': // Prefix: "-service-level"
									if l := len("-service-level"); len(elem) >= l && elem[0:l] == "-service-level" {
										elem = elem[l:]
									} else {
										break
									}

									if len(elem) == 0 {
										switch method {
										case "PUT":
											// Leaf: UpgradeSksClusterServiceLevel
											r.name = "UpgradeSksClusterServiceLevel"
											r.operationID = "upgrade-sks-cluster-service-level"
											r.pathPattern = "/sks-cluster/{id}/upgrade-service-level"
											r.args = args
											r.count = 1
											return r, true
										default:
											return
										}
									}
								}
							}
							// Param: "field"
							// Leaf parameter
							args[1] = elem
							elem = ""

							if len(elem) == 0 {
								switch method {
								case "DELETE":
									// Leaf: ResetSksClusterField
									r.name = "ResetSksClusterField"
									r.operationID = "reset-sks-cluster-field"
									r.pathPattern = "/sks-cluster/{id}/{field}"
									r.args = args
									r.count = 2
									return r, true
								default:
									return
								}
							}
						}
					}
				case 'n': // Prefix: "napshot/"
					if l := len("napshot/"); len(elem) >= l && elem[0:l] == "napshot/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Match until ":"
					idx := strings.IndexByte(elem, ':')
					if idx < 0 {
						idx = len(elem)
					}
					args[0] = elem[:idx]
					elem = elem[idx:]

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							r.name = "DeleteSnapshot"
							r.operationID = "delete-snapshot"
							r.pathPattern = "/snapshot/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case ':': // Prefix: ":"
						if l := len(":"); len(elem) >= l && elem[0:l] == ":" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case 'e': // Prefix: "export"
							if l := len("export"); len(elem) >= l && elem[0:l] == "export" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: ExportSnapshot
									r.name = "ExportSnapshot"
									r.operationID = "export-snapshot"
									r.pathPattern = "/snapshot/{id}:export"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						case 'p': // Prefix: "promote"
							if l := len("promote"); len(elem) >= l && elem[0:l] == "promote" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "POST":
									// Leaf: PromoteSnapshotToTemplate
									r.name = "PromoteSnapshotToTemplate"
									r.operationID = "promote-snapshot-to-template"
									r.pathPattern = "/snapshot/{id}:promote"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				case 'o': // Prefix: "os"
					if l := len("os"); len(elem) >= l && elem[0:l] == "os" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						break
					}
					switch elem[0] {
					case '-': // Prefix: "-buckets-usage"
						if l := len("-buckets-usage"); len(elem) >= l && elem[0:l] == "-buckets-usage" {
							elem = elem[l:]
						} else {
							break
						}

						if len(elem) == 0 {
							switch method {
							case "GET":
								// Leaf: ListSosBucketsUsage
								r.name = "ListSosBucketsUsage"
								r.operationID = "list-sos-buckets-usage"
								r.pathPattern = "/sos-buckets-usage"
								r.args = args
								r.count = 0
								return r, true
							default:
								return
							}
						}
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "bucket"
						// Match until "/"
						idx := strings.IndexByte(elem, '/')
						if idx < 0 {
							idx = len(elem)
						}
						args[0] = elem[:idx]
						elem = elem[idx:]

						if len(elem) == 0 {
							break
						}
						switch elem[0] {
						case '/': // Prefix: "/presigned-url"
							if l := len("/presigned-url"); len(elem) >= l && elem[0:l] == "/presigned-url" {
								elem = elem[l:]
							} else {
								break
							}

							if len(elem) == 0 {
								switch method {
								case "GET":
									// Leaf: GetSosPresignedURL
									r.name = "GetSosPresignedURL"
									r.operationID = "get-sos-presigned-url"
									r.pathPattern = "/sos/{bucket}/presigned-url"
									r.args = args
									r.count = 1
									return r, true
								default:
									return
								}
							}
						}
					}
				case 's': // Prefix: "sh-key"
					if l := len("sh-key"); len(elem) >= l && elem[0:l] == "sh-key" {
						elem = elem[l:]
					} else {
						break
					}

					if len(elem) == 0 {
						switch method {
						case "GET":
							r.name = "ListSSHKeys"
							r.operationID = "list-ssh-keys"
							r.pathPattern = "/ssh-key"
							r.args = args
							r.count = 0
							return r, true
						case "POST":
							r.name = "RegisterSSHKey"
							r.operationID = "register-ssh-key"
							r.pathPattern = "/ssh-key"
							r.args = args
							r.count = 0
							return r, true
						default:
							return
						}
					}
					switch elem[0] {
					case '/': // Prefix: "/"
						if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
							elem = elem[l:]
						} else {
							break
						}

						// Param: "name"
						// Leaf parameter
						args[0] = elem
						elem = ""

						if len(elem) == 0 {
							switch method {
							case "DELETE":
								// Leaf: DeleteSSHKey
								r.name = "DeleteSSHKey"
								r.operationID = "delete-ssh-key"
								r.pathPattern = "/ssh-key/{name}"
								r.args = args
								r.count = 1
								return r, true
							case "GET":
								// Leaf: GetSSHKey
								r.name = "GetSSHKey"
								r.operationID = "get-ssh-key"
								r.pathPattern = "/ssh-key/{name}"
								r.args = args
								r.count = 1
								return r, true
							default:
								return
							}
						}
					}
				}
			case 't': // Prefix: "template"
				if l := len("template"); len(elem) >= l && elem[0:l] == "template" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						r.name = "ListTemplates"
						r.operationID = "list-templates"
						r.pathPattern = "/template"
						r.args = args
						r.count = 0
						return r, true
					case "POST":
						r.name = "RegisterTemplate"
						r.operationID = "register-template"
						r.pathPattern = "/template"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
				switch elem[0] {
				case '/': // Prefix: "/"
					if l := len("/"); len(elem) >= l && elem[0:l] == "/" {
						elem = elem[l:]
					} else {
						break
					}

					// Param: "id"
					// Leaf parameter
					args[0] = elem
					elem = ""

					if len(elem) == 0 {
						switch method {
						case "DELETE":
							// Leaf: DeleteTemplate
							r.name = "DeleteTemplate"
							r.operationID = "delete-template"
							r.pathPattern = "/template/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "GET":
							// Leaf: GetTemplate
							r.name = "GetTemplate"
							r.operationID = "get-template"
							r.pathPattern = "/template/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "POST":
							// Leaf: CopyTemplate
							r.name = "CopyTemplate"
							r.operationID = "copy-template"
							r.pathPattern = "/template/{id}"
							r.args = args
							r.count = 1
							return r, true
						case "PUT":
							// Leaf: UpdateTemplate
							r.name = "UpdateTemplate"
							r.operationID = "update-template"
							r.pathPattern = "/template/{id}"
							r.args = args
							r.count = 1
							return r, true
						default:
							return
						}
					}
				}
			case 'z': // Prefix: "zone"
				if l := len("zone"); len(elem) >= l && elem[0:l] == "zone" {
					elem = elem[l:]
				} else {
					break
				}

				if len(elem) == 0 {
					switch method {
					case "GET":
						// Leaf: ListZones
						r.name = "ListZones"
						r.operationID = "list-zones"
						r.pathPattern = "/zone"
						r.args = args
						r.count = 0
						return r, true
					default:
						return
					}
				}
			}
		}
	}
	return r, false
}
