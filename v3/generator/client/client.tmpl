// URL represents a zoned url endpoint.
type URL string

const (
  {{ .Enum }}
)

// Zones represents a list of all Exoscale Zone.
var Zones map[string]URL = map[string]URL{
	{{ .Zones }}
}

// Client represents an Exoscale API client.
type Client struct {
	apiKey          string
	apiSecret       string
	serverURL       string
	httpClient      *http.Client
	timeout         time.Duration
	pollingInterval time.Duration
	trace           bool
	middlewares     []RequestMiddlewareFn
}

type RequestMiddlewareFn func(ctx context.Context, req *http.Request) error

// UserAgent is the "User-Agent" HTTP request header added to outgoing HTTP requests.
var UserAgent = fmt.Sprintf("egoscale/%s (%s; %s/%s)",
	version.Version,
	runtime.Version(),
	runtime.GOOS,
	runtime.GOARCH)

const pollingInterval = 3 * time.Second

// ClientOpt represents a function setting Exoscale API client option.
type ClientOpt func(*Client) error

// ClientOptWithTimeout returns a ClientOpt overriding the default client timeout.
func ClientOptWithTimeout(v time.Duration) ClientOpt {
	return func(c *Client) error {
		if v <= 0 {
			return errors.New("timeout value must be greater than 0")
		}
		c.timeout = v

		return nil
	}
}

// ClientOptWithTrace returns a ClientOpt enabling HTTP request/response tracing.
func ClientOptWithTrace() ClientOpt {
	return func(c *Client) error {
		c.trace = true
		return nil
	}
}

// ClientOptWithURL returns a ClientOpt With a given zone URL.
func ClientOptWithURL(url URL) ClientOpt {
	return func(c *Client) error {
		c.serverURL = string(url)
		return nil
	}
}

// ClientOptWithHTTPClient returns a ClientOpt overriding the default http.Client.
// Note: the Exoscale API client will chain additional middleware
// (http.RoundTripper) on the HTTP client internally, which can alter the HTTP
// requests and responses. If you don't want any other middleware than the ones
// currently set to your HTTP client, you should duplicate it and pass a copy
// instead.
func ClientOptWithHTTPClient(v *http.Client) ClientOpt {
	return func(c *Client) error {
		c.httpClient = v

		return nil
	}
}

// NewClient returns a new Exoscale API client.
func NewClient(apiKey, apiSecret string, opts ...ClientOpt) (*Client, error) {
	if apiKey == "" || apiSecret == "" {
		return nil, fmt.Errorf("missing or incomplete API credentials")
	}

  client := &Client{
	apiKey:				apiKey,
	apiSecret:			apiSecret,
	serverURL:			"{{.ServerURL}}",
	httpClient:			http.DefaultClient,
	pollingInterval:	pollingInterval,
  }

	for _, opt := range opts {
		if err := opt(client); err != nil {
			return nil, fmt.Errorf("client configuration error: %s", err)
		}
	}

	security, err := api.NewSecurityProvider(apiKey, apiSecret)
	if err != nil {
		return nil, fmt.Errorf("unable to initialize API security provider: %w", err)
	}

	// Tracing must be performed before API error handling in the middleware chain,
	// otherwise the response won't be dumped in case of an API error.
	if client.trace {
		client.httpClient.Transport = api.NewTraceMiddleware(client.httpClient.Transport)
	}

	client.httpClient.Transport = api.NewAPIErrorHandlerMiddleware(client.httpClient.Transport)

	return client.WithRequestMiddleware(security.Intercept), nil
}

// WithURL returns a copy of Client with new URL.
func (c *Client) WithURL(url URL) *Client {
	return &Client{
		serverURL:       string(url),
		httpClient:      c.httpClient,
		middlewares:     c.middlewares,
		pollingInterval: c.pollingInterval,
	}
}

// WithHttpClient returns a copy of Client with new http.Client.
func (c *Client) WithHttpClient(client *http.Client) *Client {
	return &Client{
		serverURL:       c.serverURL,
		httpClient:      client,
		middlewares:     c.middlewares,
		pollingInterval: c.pollingInterval,
	}
}

// WithRequestMiddleware returns a copy of Client with new RequestMiddlewareFn.
func (c *Client) WithRequestMiddleware(f RequestMiddlewareFn) *Client {
	return &Client{
		serverURL:       c.serverURL,
		httpClient:      c.httpClient,
		middlewares:     append(c.middlewares, f),
		pollingInterval: c.pollingInterval,
	}
}

func registerRequestMiddlewares(c *Client, ctx context.Context, req *http.Request) error {
	for _, fn := range c.middlewares {
		if err := fn(ctx, req); err != nil {
			return err
		}
	}

	return nil
}
