type ClientZone string

const (
  {{ .Enum }}
)

type Client struct {
  apiKey			string
  apiSecret			string
  serverURL     	string
  rawServerURL 		string
  httpClient    	*http.Client
  timeout			time.Duration
  pollingInterval	time.Duration
  trace				bool
  middlewares		[]RequestMiddlewareFn
}

type RequestMiddlewareFn func(ctx context.Context, req *http.Request) error

// UserAgent is the "User-Agent" HTTP request header added to outgoing HTTP requests.
var UserAgent = fmt.Sprintf("egoscale/%s (%s; %s/%s)",
	version.Version,
	runtime.Version(),
	runtime.GOOS,
	runtime.GOARCH)

const pollingInterval = 3 * time.Second

// ClientOpt represents a function setting Exoscale API client option.
type ClientOpt func(*Client) error


// ClientOptWithTimeout returns a ClientOpt overriding the default client timeout.
func ClientOptWithTimeout(v time.Duration) ClientOpt {
	return func(c *Client) error {
		if v <= 0 {
			return errors.New("timeout value must be greater than 0")
		}
		c.timeout = v

		return nil
	}
}

// ClientOptWithTrace returns a ClientOpt enabling HTTP request/response tracing.
func ClientOptWithTrace() ClientOpt {
	return func(c *Client) error {
		c.trace = true
		return nil
	}
}

func ClientOptWithEnvironment(env string) ClientOpt {
	return func(c *Client) error {
		c.rawServerURL = strings.Replace(c.rawServerURL, "api", env, 1)
		c.serverURL = strings.Replace(c.serverURL, "api", env, 1)
		return nil
	}
}

// ClientOptWithZone returns a ClientOpt With a given zone.
func ClientOptWithZone(zone ClientZone) ClientOpt {
	return func(c *Client) error {
		c.serverURL = strings.Replace(c.rawServerURL, "{zone}", string(zone), 1)
		return nil
	}
}

// ClientOptWithHTTPClient returns a ClientOpt overriding the default http.Client.
// Note: the Exoscale API client will chain additional middleware
// (http.RoundTripper) on the HTTP client internally, which can alter the HTTP
// requests and responses. If you don't want any other middleware than the ones
// currently set to your HTTP client, you should duplicate it and pass a copy
// instead.
func ClientOptWithHTTPClient(v *http.Client) ClientOpt {
	return func(c *Client) error {
		c.httpClient = v

		return nil
	}
}

func NewClient(apiKey, apiSecret string, opts ...ClientOpt) (*Client, error) {
  if apiKey == "" || apiSecret == "" {
	return nil, fmt.Errorf("missing or incomplete API credentials")
  }

  client := &Client{
	apiKey:				apiKey,
	apiSecret:			apiSecret,
	serverURL:			"{{.ServerURL}}",
    rawServerURL:		"{{.RawServerURL}}",
	httpClient:			http.DefaultClient,
	pollingInterval:	pollingInterval,
  }

  for _, opt := range opts {
	if err := opt(client); err != nil {
		return nil, fmt.Errorf("client configuration error: %s", err)
	}
  }

  security, err := api.NewSecurityProvider(apiKey, apiSecret)
  if err != nil {
	  return nil, fmt.Errorf("unable to initialize API security provider: %w", err)
  }

  // Tracing must be performed before API error handling in the middleware chain,
  // otherwise the response won't be dumped in case of an API error.
  if client.trace {
    client.httpClient.Transport = api.NewTraceMiddleware(client.httpClient.Transport)
  }

  client.httpClient.Transport = api.NewAPIErrorHandlerMiddleware(client.httpClient.Transport)

  return client.WithRequestMiddleware(security.Intercept), nil
}

func (c *Client) WithZone(z ClientZone) *Client {
  return &Client{
	serverURL:			strings.Replace(c.rawServerURL, "{zone}", string(z), 1),
    rawServerURL:  		c.rawServerURL,
	httpClient:			c.httpClient,
	middlewares:  		c.middlewares,
	pollingInterval:	c.pollingInterval,
  }
}

func (c *Client) WithContext(ctx context.Context) *Client {
	return &Client{
	  serverURL:		c.serverURL,
	  rawServerURL:		c.rawServerURL,
	  httpClient:		c.httpClient,
	  middlewares:  	c.middlewares,
	  pollingInterval:	c.pollingInterval,
	}
  }

  func (c *Client) WithHttpClient(client *http.Client) *Client {
	return &Client{
	  serverURL:		c.serverURL,
	  rawServerURL:		c.rawServerURL,
	  httpClient:		client,
	  middlewares:  	c.middlewares,
	  pollingInterval:	c.pollingInterval,
	}
  }

  func (c *Client) WithRequestMiddleware(f RequestMiddlewareFn) *Client {
	return &Client{
		serverURL:    		c.serverURL,
		rawServerURL: 		c.rawServerURL,
		httpClient:   		c.httpClient,
		middlewares:  		append(c.middlewares, f),
		pollingInterval:	c.pollingInterval,
	}
  }

func registerRequestMiddlewares(c *Client, ctx context.Context, req *http.Request) error {
	for _, fn := range c.middlewares {
		if err := fn(ctx, req); err != nil {
			return err
		}
	}

	return nil
}
