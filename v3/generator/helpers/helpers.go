package helpers

import (
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"sync"

	abbr "github.com/BluntSporks/abbreviation"
)

var uppercaseAcronym = sync.Map{}

// ConfigureAcronym allows you to add additional words which will be considered acronyms
func ConfigureAcronym(key, val string) {
	uppercaseAcronym.Store(key, val)
}

func ForEachMapSorted[V any](m map[string]V, f func(k string, v any) error) error {
	keys := []string{}
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	for _, k := range keys {
		if err := f(k, m[k]); err != nil {
			return err
		}
	}

	return nil
}

func RenderReference(ref string) string {
	return ToCamel(filepath.Base(ref))
}

func Header(packageName, version string) []byte {
	return []byte(fmt.Sprintf(`// Package %s provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/egoscale/v3/generator version %s DO NOT EDIT.
`,
		packageName, version,
	))
}

func ToLowerCamel(s string) string {
	return toInitialCamel(s, true)
}

func ToCamel(s string) string {
	return toInitialCamel(s, false)
}

func toInitialCamel(s string, lower bool) string {
	if s == "" {
		return ""
	}

	sep, ok := containSep(s)
	if !ok {
		sep = "-"
	}

	s = strings.Trim(s, sep)
	words := strings.Split(s, sep)
	for i, w := range words {
		if w == "" {
			continue
		}

		_, ok := abbr.Acronyms[strings.ToUpper(w)]
		if ok {
			words[i] = strings.ToUpper(w)
		}

		a, hasAcronym := uppercaseAcronym.Load(w)
		if hasAcronym {
			words[i] = a.(string)
		}

		if i == 0 && lower {
			words[i] = strings.ToLower(words[i])
			continue
		}

		bytes := []byte(words[i])
		v := bytes[0]
		vIsLow := v >= 'a' && v <= 'z'
		if vIsLow {
			bytes[0] += 'A'
			bytes[0] -= 'a'
		}

		words[i] = string(bytes)
	}

	return strings.Join(words, "")
}

func containSep(s string) (string, bool) {
	if strings.Contains(s, "-") {
		return "-", true
	}
	if strings.Contains(s, "_") {
		return "_", true
	}
	if strings.Contains(s, ".") {
		return ".", true
	}
	if strings.Contains(s, "/") {
		return "/", true
	}
	if strings.Contains(s, " ") {
		return " ", true
	}

	return "", false
}
