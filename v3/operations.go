// Package v3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/egoscale/v3/generator version v0.0.1 DO NOT EDIT.
package v3

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/url"
	"time"

	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
)

type ListAccessKeysResponse struct {
	AccessKeys []AccessKey `json:"access-keys,omitempty"`
}

// List IAM Access Keys
func (c ClientAPI) ListAccessKeys(ctx context.Context) (*ListAccessKeysResponse, error) {
	path := "/access-key"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListAccessKeys: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListAccessKeys: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListAccessKeys: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListAccessKeys returned %d code", resp.StatusCode)
	}

	bodyresp := &ListAccessKeysResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListAccessKeys: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// IAM Access Key
type CreateAccessKeyRequest struct {
	// IAM Access Key name
	Name string `json:"name,omitempty"`
	// IAM Access Key operations
	Operations []string `json:"operations,omitempty"`
	// IAM Access Key Resources
	Resources []AccessKeyResource `json:"resources,omitempty"`
	// IAM Access Key tags
	Tags []string `json:"tags,omitempty"`
}

// This operation creates a legacy IAM Access Key, to create a key for use with IAM roles use the api-key endpoint.The corresponding secret is only available in the response returned by this operation, the caller must take care of storing it safely as there is no other way to retrieve it.
func (c ClientAPI) CreateAccessKey(ctx context.Context, req CreateAccessKeyRequest) (*AccessKey, error) {
	path := "/access-key"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateAccessKey: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateAccessKey: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateAccessKey: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateAccessKey: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateAccessKey returned %d code", resp.StatusCode)
	}

	bodyresp := &AccessKey{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateAccessKey: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListAccessKeyKnownOperationsResponse struct {
	AccessKeyOperations []AccessKeyOperation `json:"access-key-operations,omitempty"`
}

// Retrieve all known available IAM Access Key operations and associated tags
func (c ClientAPI) ListAccessKeyKnownOperations(ctx context.Context) (*ListAccessKeyKnownOperationsResponse, error) {
	path := "/access-key-known-operations"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListAccessKeyKnownOperations: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListAccessKeyKnownOperations: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListAccessKeyKnownOperations: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListAccessKeyKnownOperations returned %d code", resp.StatusCode)
	}

	bodyresp := &ListAccessKeyKnownOperationsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListAccessKeyKnownOperations: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListAccessKeyOperationsResponse struct {
	AccessKeyOperations []AccessKeyOperation `json:"access-key-operations,omitempty"`
}

// Retrieve IAM Access Key operations and associated tags for the signing key
func (c ClientAPI) ListAccessKeyOperations(ctx context.Context) (*ListAccessKeyOperationsResponse, error) {
	path := "/access-key-operations"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListAccessKeyOperations: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListAccessKeyOperations: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListAccessKeyOperations: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListAccessKeyOperations returned %d code", resp.StatusCode)
	}

	bodyresp := &ListAccessKeyOperationsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListAccessKeyOperations: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// This operation revokes the specified IAM Access Key. Access Keys created by the revoked Access Key will not be revoked.
func (c ClientAPI) RevokeAccessKey(ctx context.Context, key string) (*Operation, error) {
	path := fmt.Sprintf("/access-key/%v", key)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("RevokeAccessKey: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("RevokeAccessKey: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("RevokeAccessKey: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request RevokeAccessKey returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("RevokeAccessKey: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve IAM Access Key details
func (c ClientAPI) GetAccessKey(ctx context.Context, key string) (*AccessKey, error) {
	path := fmt.Sprintf("/access-key/%v", key)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetAccessKey: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetAccessKey: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetAccessKey: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetAccessKey returned %d code", resp.StatusCode)
	}

	bodyresp := &AccessKey{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetAccessKey: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListAntiAffinityGroupsResponse struct {
	AntiAffinityGroups []AntiAffinityGroup `json:"anti-affinity-groups,omitempty"`
}

// List Anti-affinity Groups
func (c ClientAPI) ListAntiAffinityGroups(ctx context.Context) (*ListAntiAffinityGroupsResponse, error) {
	path := "/anti-affinity-group"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListAntiAffinityGroups: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListAntiAffinityGroups: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListAntiAffinityGroups: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListAntiAffinityGroups returned %d code", resp.StatusCode)
	}

	bodyresp := &ListAntiAffinityGroupsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListAntiAffinityGroups: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateAntiAffinityGroupRequest struct {
	// Anti-affinity Group description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Anti-affinity Group name
	Name string `json:"name" validate:"required,gte=1,lte=255"`
}

// Create an Anti-affinity Group
func (c ClientAPI) CreateAntiAffinityGroup(ctx context.Context, req CreateAntiAffinityGroupRequest) (*Operation, error) {
	path := "/anti-affinity-group"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateAntiAffinityGroup: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateAntiAffinityGroup: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateAntiAffinityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateAntiAffinityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateAntiAffinityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateAntiAffinityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete an Anti-affinity Group
func (c ClientAPI) DeleteAntiAffinityGroup(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/anti-affinity-group/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteAntiAffinityGroup: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteAntiAffinityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteAntiAffinityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteAntiAffinityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteAntiAffinityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Anti-affinity Group details
func (c ClientAPI) GetAntiAffinityGroup(ctx context.Context, id UUID) (*AntiAffinityGroup, error) {
	path := fmt.Sprintf("/anti-affinity-group/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetAntiAffinityGroup: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetAntiAffinityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetAntiAffinityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetAntiAffinityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &AntiAffinityGroup{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetAntiAffinityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListAPIKeysResponse struct {
	APIKeys []IAMAPIKey `json:"api-keys,omitempty"`
}

// List API keys
func (c ClientAPI) ListAPIKeys(ctx context.Context) (*ListAPIKeysResponse, error) {
	path := "/api-key"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListAPIKeys: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListAPIKeys: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListAPIKeys: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListAPIKeys returned %d code", resp.StatusCode)
	}

	bodyresp := &ListAPIKeysResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListAPIKeys: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateAPIKeyRequest struct {
	// IAM API Key Name
	Name string `json:"name" validate:"required,gte=1,lte=255"`
	// IAM API Key Role ID
	RoleID UUID `json:"role-id" validate:"required"`
}

// Create a new API key
func (c ClientAPI) CreateAPIKey(ctx context.Context, req CreateAPIKeyRequest) (*IAMAPIKeyCreated, error) {
	path := "/api-key"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateAPIKey: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateAPIKey: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateAPIKey: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateAPIKey: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateAPIKey returned %d code", resp.StatusCode)
	}

	bodyresp := &IAMAPIKeyCreated{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateAPIKey: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete an API key
func (c ClientAPI) DeleteAPIKey(ctx context.Context, id string) (*Operation, error) {
	path := fmt.Sprintf("/api-key/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteAPIKey: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteAPIKey: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteAPIKey: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteAPIKey returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteAPIKey: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get API key
func (c ClientAPI) GetAPIKey(ctx context.Context, id string) (*IAMAPIKey, error) {
	path := fmt.Sprintf("/api-key/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetAPIKey: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetAPIKey: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetAPIKey: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetAPIKey returned %d code", resp.StatusCode)
	}

	bodyresp := &IAMAPIKey{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetAPIKey: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type GetDBAASCACertificateResponse struct {
	Certificate string `json:"certificate,omitempty"`
}

// Returns a CA Certificate required to reach a DBaaS service through a TLS-protected connection.
func (c ClientAPI) GetDBAASCACertificate(ctx context.Context) (*GetDBAASCACertificateResponse, error) {
	path := "/dbaas-ca-certificate"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASCACertificate: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASCACertificate: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASCACertificate: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASCACertificate returned %d code", resp.StatusCode)
	}

	bodyresp := &GetDBAASCACertificateResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASCACertificate: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Grafana service
func (c ClientAPI) DeleteDBAASServiceGrafana(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-grafana/%v", name)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceGrafana: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceGrafana: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceGrafana: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASServiceGrafana returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceGrafana: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get a DBaaS Grafana service
func (c ClientAPI) GetDBAASServiceGrafana(ctx context.Context, name string) (*DBAASServiceGrafana, error) {
	path := fmt.Sprintf("/dbaas-grafana/%v", name)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceGrafana: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceGrafana: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceGrafana: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASServiceGrafana returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASServiceGrafana{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceGrafana: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASServiceGrafanaRequestMaintenanceDow string

const (
	CreateDBAASServiceGrafanaRequestMaintenanceDowSaturday  CreateDBAASServiceGrafanaRequestMaintenanceDow = "saturday"
	CreateDBAASServiceGrafanaRequestMaintenanceDowTuesday   CreateDBAASServiceGrafanaRequestMaintenanceDow = "tuesday"
	CreateDBAASServiceGrafanaRequestMaintenanceDowNever     CreateDBAASServiceGrafanaRequestMaintenanceDow = "never"
	CreateDBAASServiceGrafanaRequestMaintenanceDowWednesday CreateDBAASServiceGrafanaRequestMaintenanceDow = "wednesday"
	CreateDBAASServiceGrafanaRequestMaintenanceDowSunday    CreateDBAASServiceGrafanaRequestMaintenanceDow = "sunday"
	CreateDBAASServiceGrafanaRequestMaintenanceDowFriday    CreateDBAASServiceGrafanaRequestMaintenanceDow = "friday"
	CreateDBAASServiceGrafanaRequestMaintenanceDowMonday    CreateDBAASServiceGrafanaRequestMaintenanceDow = "monday"
	CreateDBAASServiceGrafanaRequestMaintenanceDowThursday  CreateDBAASServiceGrafanaRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type CreateDBAASServiceGrafanaRequestMaintenance struct {
	// Day of week for installing updates
	Dow CreateDBAASServiceGrafanaRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

type CreateDBAASServiceGrafanaRequest struct {
	ForkFromService *DBAASServiceName `json:"fork-from-service,omitempty" validate:"omitempty,gte=0,lte=63"`
	// Grafana settings
	GrafanaSettings *JSONSchemaGrafana `json:"grafana-settings,omitempty"`
	// Allowed CIDR address blocks for incoming connections
	IPFilter []string `json:"ip-filter,omitempty"`
	// Automatic maintenance settings
	Maintenance *CreateDBAASServiceGrafanaRequestMaintenance `json:"maintenance,omitempty"`
	// Subscription plan
	Plan string `json:"plan" validate:"required,gte=1,lte=128"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
}

// Create a DBaaS Grafana service
func (c ClientAPI) CreateDBAASServiceGrafana(ctx context.Context, name string, req CreateDBAASServiceGrafanaRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-grafana/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceGrafana: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceGrafana: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceGrafana: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceGrafana: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASServiceGrafana returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceGrafana: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateDBAASServiceGrafanaRequestMaintenanceDow string

const (
	UpdateDBAASServiceGrafanaRequestMaintenanceDowSaturday  UpdateDBAASServiceGrafanaRequestMaintenanceDow = "saturday"
	UpdateDBAASServiceGrafanaRequestMaintenanceDowTuesday   UpdateDBAASServiceGrafanaRequestMaintenanceDow = "tuesday"
	UpdateDBAASServiceGrafanaRequestMaintenanceDowNever     UpdateDBAASServiceGrafanaRequestMaintenanceDow = "never"
	UpdateDBAASServiceGrafanaRequestMaintenanceDowWednesday UpdateDBAASServiceGrafanaRequestMaintenanceDow = "wednesday"
	UpdateDBAASServiceGrafanaRequestMaintenanceDowSunday    UpdateDBAASServiceGrafanaRequestMaintenanceDow = "sunday"
	UpdateDBAASServiceGrafanaRequestMaintenanceDowFriday    UpdateDBAASServiceGrafanaRequestMaintenanceDow = "friday"
	UpdateDBAASServiceGrafanaRequestMaintenanceDowMonday    UpdateDBAASServiceGrafanaRequestMaintenanceDow = "monday"
	UpdateDBAASServiceGrafanaRequestMaintenanceDowThursday  UpdateDBAASServiceGrafanaRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type UpdateDBAASServiceGrafanaRequestMaintenance struct {
	// Day of week for installing updates
	Dow UpdateDBAASServiceGrafanaRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

type UpdateDBAASServiceGrafanaRequest struct {
	// Grafana settings
	GrafanaSettings *JSONSchemaGrafana `json:"grafana-settings,omitempty"`
	// Allowed CIDR address blocks for incoming connections
	IPFilter []string `json:"ip-filter,omitempty"`
	// Automatic maintenance settings
	Maintenance *UpdateDBAASServiceGrafanaRequestMaintenance `json:"maintenance,omitempty"`
	// Subscription plan
	Plan string `json:"plan,omitempty" validate:"omitempty,gte=1,lte=128"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
}

// Update a DBaaS Grafana service
func (c ClientAPI) UpdateDBAASServiceGrafana(ctx context.Context, name string, req UpdateDBAASServiceGrafanaRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-grafana/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceGrafana: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceGrafana: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceGrafana: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceGrafana: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateDBAASServiceGrafana returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceGrafana: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Initiate Grafana maintenance update
func (c ClientAPI) StartDBAASGrafanaMaintenance(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-grafana/%v/maintenance/start", name)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASGrafanaMaintenance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("StartDBAASGrafanaMaintenance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASGrafanaMaintenance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request StartDBAASGrafanaMaintenance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("StartDBAASGrafanaMaintenance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASIntegrationRequest struct {
	DestService     *DBAASServiceName     `json:"dest-service" validate:"required,gte=0,lte=63"`
	IntegrationType *EnumIntegrationTypes `json:"integration-type" validate:"required"`
	// Integration settings
	Settings      map[string]any    `json:"settings,omitempty"`
	SourceService *DBAASServiceName `json:"source-service" validate:"required,gte=0,lte=63"`
}

// Create a new DBaaS integration between two services
func (c ClientAPI) CreateDBAASIntegration(ctx context.Context, req CreateDBAASIntegrationRequest) (*Operation, error) {
	path := "/dbaas-integration"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASIntegration: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASIntegration: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASIntegration: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASIntegration: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASIntegration returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASIntegration: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// The JSON schema representing the settings for the given integration type, source, and destination service types.
type ListDBAASIntegrationSettingsResponseSettings struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

type ListDBAASIntegrationSettingsResponse struct {
	// The JSON schema representing the settings for the given integration type, source, and destination service types.
	Settings *ListDBAASIntegrationSettingsResponseSettings `json:"settings,omitempty"`
}

// Get DBaaS integration settings
func (c ClientAPI) ListDBAASIntegrationSettings(ctx context.Context, integrationType string, sourceType string, destType string) (*ListDBAASIntegrationSettingsResponse, error) {
	path := fmt.Sprintf("/dbaas-integration-settings/%v/%v/%v", integrationType, sourceType, destType)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListDBAASIntegrationSettings: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListDBAASIntegrationSettings: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListDBAASIntegrationSettings: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListDBAASIntegrationSettings returned %d code", resp.StatusCode)
	}

	bodyresp := &ListDBAASIntegrationSettingsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListDBAASIntegrationSettings: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListDBAASIntegrationTypesResponse struct {
	DBAASIntegrationTypes []DBAASIntegrationType `json:"dbaas-integration-types,omitempty"`
}

// Get DBaaS integration types
func (c ClientAPI) ListDBAASIntegrationTypes(ctx context.Context) (*ListDBAASIntegrationTypesResponse, error) {
	path := "/dbaas-integration-types"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListDBAASIntegrationTypes: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListDBAASIntegrationTypes: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListDBAASIntegrationTypes: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListDBAASIntegrationTypes returned %d code", resp.StatusCode)
	}

	bodyresp := &ListDBAASIntegrationTypesResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListDBAASIntegrationTypes: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a DBaaS Integration
func (c ClientAPI) DeleteDBAASIntegration(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-integration/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASIntegration: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASIntegration: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASIntegration: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASIntegration returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASIntegration: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get a DBaaS Integration
func (c ClientAPI) GetDBAASIntegration(ctx context.Context, id UUID) (*DBAASIntegration, error) {
	path := fmt.Sprintf("/dbaas-integration/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASIntegration: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASIntegration: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASIntegration: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASIntegration returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASIntegration{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASIntegration: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateDBAASIntegrationRequest struct {
	// Integration settings
	Settings map[string]any `json:"settings" validate:"required"`
}

// Update a existing DBaaS integration
func (c ClientAPI) UpdateDBAASIntegration(ctx context.Context, id UUID, req UpdateDBAASIntegrationRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-integration/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASIntegration: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASIntegration: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateDBAASIntegration: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASIntegration: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateDBAASIntegration returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateDBAASIntegration: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Kafka service
func (c ClientAPI) DeleteDBAASServiceKafka(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v", name)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceKafka: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceKafka: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceKafka: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASServiceKafka returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceKafka: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get a DBaaS Kafka service
func (c ClientAPI) GetDBAASServiceKafka(ctx context.Context, name string) (*DBAASServiceKafka, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v", name)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceKafka: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceKafka: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceKafka: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASServiceKafka returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASServiceKafka{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceKafka: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Kafka authentication methods
type CreateDBAASServiceKafkaRequestAuthenticationMethods struct {
	// Enable certificate/SSL authentication
	Certificate *bool `json:"certificate,omitempty"`
	// Enable SASL authentication
	Sasl *bool `json:"sasl,omitempty"`
}

type CreateDBAASServiceKafkaRequestMaintenanceDow string

const (
	CreateDBAASServiceKafkaRequestMaintenanceDowSaturday  CreateDBAASServiceKafkaRequestMaintenanceDow = "saturday"
	CreateDBAASServiceKafkaRequestMaintenanceDowTuesday   CreateDBAASServiceKafkaRequestMaintenanceDow = "tuesday"
	CreateDBAASServiceKafkaRequestMaintenanceDowNever     CreateDBAASServiceKafkaRequestMaintenanceDow = "never"
	CreateDBAASServiceKafkaRequestMaintenanceDowWednesday CreateDBAASServiceKafkaRequestMaintenanceDow = "wednesday"
	CreateDBAASServiceKafkaRequestMaintenanceDowSunday    CreateDBAASServiceKafkaRequestMaintenanceDow = "sunday"
	CreateDBAASServiceKafkaRequestMaintenanceDowFriday    CreateDBAASServiceKafkaRequestMaintenanceDow = "friday"
	CreateDBAASServiceKafkaRequestMaintenanceDowMonday    CreateDBAASServiceKafkaRequestMaintenanceDow = "monday"
	CreateDBAASServiceKafkaRequestMaintenanceDowThursday  CreateDBAASServiceKafkaRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type CreateDBAASServiceKafkaRequestMaintenance struct {
	// Day of week for installing updates
	Dow CreateDBAASServiceKafkaRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

type CreateDBAASServiceKafkaRequest struct {
	// Kafka authentication methods
	AuthenticationMethods *CreateDBAASServiceKafkaRequestAuthenticationMethods `json:"authentication-methods,omitempty"`
	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
	IPFilter []string `json:"ip-filter,omitempty"`
	// Allow clients to connect to kafka_connect from the public internet for service nodes that are in a project VPC or another type of private network
	KafkaConnectEnabled *bool `json:"kafka-connect-enabled,omitempty"`
	// Kafka Connect configuration values
	KafkaConnectSettings JSONSchemaKafkaConnect `json:"kafka-connect-settings,omitempty"`
	// Enable Kafka-REST service
	KafkaRestEnabled *bool `json:"kafka-rest-enabled,omitempty"`
	// Kafka REST configuration
	KafkaRestSettings JSONSchemaKafkaRest `json:"kafka-rest-settings,omitempty"`
	// Kafka broker configuration values
	KafkaSettings JSONSchemaKafka `json:"kafka-settings,omitempty"`
	// Automatic maintenance settings
	Maintenance *CreateDBAASServiceKafkaRequestMaintenance `json:"maintenance,omitempty"`
	// Subscription plan
	Plan string `json:"plan" validate:"required,gte=1,lte=128"`
	// Enable Schema-Registry service
	SchemaRegistryEnabled *bool `json:"schema-registry-enabled,omitempty"`
	// Schema Registry configuration
	SchemaRegistrySettings JSONSchemaSchemaRegistry `json:"schema-registry-settings,omitempty"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
	// Kafka major version
	Version string `json:"version,omitempty" validate:"omitempty,gte=1"`
}

// Create a DBaaS Kafka service
func (c ClientAPI) CreateDBAASServiceKafka(ctx context.Context, name string, req CreateDBAASServiceKafkaRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceKafka: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceKafka: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceKafka: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceKafka: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASServiceKafka returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceKafka: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Kafka authentication methods
type UpdateDBAASServiceKafkaRequestAuthenticationMethods struct {
	// Enable certificate/SSL authentication
	Certificate *bool `json:"certificate,omitempty"`
	// Enable SASL authentication
	Sasl *bool `json:"sasl,omitempty"`
}

type UpdateDBAASServiceKafkaRequestMaintenanceDow string

const (
	UpdateDBAASServiceKafkaRequestMaintenanceDowSaturday  UpdateDBAASServiceKafkaRequestMaintenanceDow = "saturday"
	UpdateDBAASServiceKafkaRequestMaintenanceDowTuesday   UpdateDBAASServiceKafkaRequestMaintenanceDow = "tuesday"
	UpdateDBAASServiceKafkaRequestMaintenanceDowNever     UpdateDBAASServiceKafkaRequestMaintenanceDow = "never"
	UpdateDBAASServiceKafkaRequestMaintenanceDowWednesday UpdateDBAASServiceKafkaRequestMaintenanceDow = "wednesday"
	UpdateDBAASServiceKafkaRequestMaintenanceDowSunday    UpdateDBAASServiceKafkaRequestMaintenanceDow = "sunday"
	UpdateDBAASServiceKafkaRequestMaintenanceDowFriday    UpdateDBAASServiceKafkaRequestMaintenanceDow = "friday"
	UpdateDBAASServiceKafkaRequestMaintenanceDowMonday    UpdateDBAASServiceKafkaRequestMaintenanceDow = "monday"
	UpdateDBAASServiceKafkaRequestMaintenanceDowThursday  UpdateDBAASServiceKafkaRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type UpdateDBAASServiceKafkaRequestMaintenance struct {
	// Day of week for installing updates
	Dow UpdateDBAASServiceKafkaRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

type UpdateDBAASServiceKafkaRequest struct {
	// Kafka authentication methods
	AuthenticationMethods *UpdateDBAASServiceKafkaRequestAuthenticationMethods `json:"authentication-methods,omitempty"`
	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
	IPFilter []string `json:"ip-filter,omitempty"`
	// Allow clients to connect to kafka_connect from the public internet for service nodes that are in a project VPC or another type of private network
	KafkaConnectEnabled *bool `json:"kafka-connect-enabled,omitempty"`
	// Kafka Connect configuration values
	KafkaConnectSettings JSONSchemaKafkaConnect `json:"kafka-connect-settings,omitempty"`
	// Enable Kafka-REST service
	KafkaRestEnabled *bool `json:"kafka-rest-enabled,omitempty"`
	// Kafka REST configuration
	KafkaRestSettings JSONSchemaKafkaRest `json:"kafka-rest-settings,omitempty"`
	// Kafka broker configuration values
	KafkaSettings JSONSchemaKafka `json:"kafka-settings,omitempty"`
	// Automatic maintenance settings
	Maintenance *UpdateDBAASServiceKafkaRequestMaintenance `json:"maintenance,omitempty"`
	// Subscription plan
	Plan string `json:"plan,omitempty" validate:"omitempty,gte=1,lte=128"`
	// Enable Schema-Registry service
	SchemaRegistryEnabled *bool `json:"schema-registry-enabled,omitempty"`
	// Schema Registry configuration
	SchemaRegistrySettings JSONSchemaSchemaRegistry `json:"schema-registry-settings,omitempty"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
	// Kafka major version
	Version string `json:"version,omitempty" validate:"omitempty,gte=1"`
}

// Update a DBaaS Kafka service
func (c ClientAPI) UpdateDBAASServiceKafka(ctx context.Context, name string, req UpdateDBAASServiceKafkaRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceKafka: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceKafka: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceKafka: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceKafka: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateDBAASServiceKafka returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceKafka: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get DBaaS kafka ACL configuration
func (c ClientAPI) GetDBAASKafkaAclConfig(ctx context.Context, name string) (*DBAASKafkaAcls, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v/acl-config", name)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASKafkaAclConfig: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASKafkaAclConfig: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASKafkaAclConfig: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASKafkaAclConfig returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASKafkaAcls{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASKafkaAclConfig: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Initiate Kafka maintenance update
func (c ClientAPI) StartDBAASKafkaMaintenance(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v/maintenance/start", name)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASKafkaMaintenance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("StartDBAASKafkaMaintenance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASKafkaMaintenance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request StartDBAASKafkaMaintenance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("StartDBAASKafkaMaintenance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Add a Kafka Schema Registry ACL entry
func (c ClientAPI) CreateDBAASKafkaSchemaRegistryAclConfig(ctx context.Context, name string, req DBAASKafkaSchemaRegistryAclEntry) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v/schema-registry/acl-config", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaSchemaRegistryAclConfig: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaSchemaRegistryAclConfig: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaSchemaRegistryAclConfig: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaSchemaRegistryAclConfig: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASKafkaSchemaRegistryAclConfig returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaSchemaRegistryAclConfig: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Kafka ACL entry
func (c ClientAPI) DeleteDBAASKafkaSchemaRegistryAclConfig(ctx context.Context, name string, aclID string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v/schema-registry/acl-config/%v", name, aclID)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaSchemaRegistryAclConfig: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaSchemaRegistryAclConfig: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaSchemaRegistryAclConfig: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASKafkaSchemaRegistryAclConfig returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaSchemaRegistryAclConfig: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Add a Kafka topic ACL entry
func (c ClientAPI) CreateDBAASKafkaTopicAclConfig(ctx context.Context, name string, req DBAASKafkaTopicAclEntry) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v/topic/acl-config", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaTopicAclConfig: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaTopicAclConfig: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaTopicAclConfig: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaTopicAclConfig: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASKafkaTopicAclConfig returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaTopicAclConfig: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Kafka ACL entry
func (c ClientAPI) DeleteDBAASKafkaTopicAclConfig(ctx context.Context, name string, aclID string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v/topic/acl-config/%v", name, aclID)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaTopicAclConfig: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaTopicAclConfig: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaTopicAclConfig: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASKafkaTopicAclConfig returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaTopicAclConfig: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASKafkaUserRequest struct {
	Username *DBAASUserUsername `json:"username" validate:"required,gte=1,lte=64"`
}

// Create a DBaaS Kafka user
func (c ClientAPI) CreateDBAASKafkaUser(ctx context.Context, serviceName string, req CreateDBAASKafkaUserRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v/user", serviceName)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaUser: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaUser: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaUser: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaUser: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASKafkaUser returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASKafkaUser: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a DBaaS kafka user
func (c ClientAPI) DeleteDBAASKafkaUser(ctx context.Context, serviceName string, username string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v/user/%v", serviceName, username)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaUser: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaUser: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaUser: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASKafkaUser returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASKafkaUser: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetDBAASKafkaUserPasswordRequest struct {
	Password *DBAASUserPassword `json:"password,omitempty" validate:"omitempty,gte=8,lte=256"`
}

// If no password is provided one will be generated automatically.
func (c ClientAPI) ResetDBAASKafkaUserPassword(ctx context.Context, serviceName string, username string, req ResetDBAASKafkaUserPasswordRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-kafka/%v/user/%v/password/reset", serviceName, username)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASKafkaUserPassword: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASKafkaUserPassword: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetDBAASKafkaUserPassword: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASKafkaUserPassword: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetDBAASKafkaUserPassword returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetDBAASKafkaUserPassword: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get a DBaaS migration status
func (c ClientAPI) GetDBAASMigrationStatus(ctx context.Context, name string) (*DBAASMigrationStatus, error) {
	path := fmt.Sprintf("/dbaas-migration-status/%v", name)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASMigrationStatus: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASMigrationStatus: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASMigrationStatus: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASMigrationStatus returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASMigrationStatus{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASMigrationStatus: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a MySQL service
func (c ClientAPI) DeleteDBAASServiceMysql(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-mysql/%v", name)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceMysql: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceMysql: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceMysql: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASServiceMysql returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceMysql: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get a DBaaS MySQL service
func (c ClientAPI) GetDBAASServiceMysql(ctx context.Context, name string) (*DBAASServiceMysql, error) {
	path := fmt.Sprintf("/dbaas-mysql/%v", name)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceMysql: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceMysql: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceMysql: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASServiceMysql returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASServiceMysql{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceMysql: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASServiceMysqlRequestBackupSchedule struct {
	// The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
	BackupHour int64 `json:"backup-hour,omitempty" validate:"omitempty,gte=0,lte=23"`
	// The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
	BackupMinute int64 `json:"backup-minute,omitempty" validate:"omitempty,gte=0,lte=59"`
}

type CreateDBAASServiceMysqlRequestIntegrationsType string

const (
	CreateDBAASServiceMysqlRequestIntegrationsTypeReadReplica CreateDBAASServiceMysqlRequestIntegrationsType = "read_replica"
)

type CreateDBAASServiceMysqlRequestIntegrations struct {
	DestService *DBAASServiceName `json:"dest-service,omitempty" validate:"omitempty,gte=0,lte=63"`
	// Integration settings
	Settings      map[string]any    `json:"settings,omitempty"`
	SourceService *DBAASServiceName `json:"source-service,omitempty" validate:"omitempty,gte=0,lte=63"`
	// Integration type
	Type CreateDBAASServiceMysqlRequestIntegrationsType `json:"type" validate:"required"`
}

type CreateDBAASServiceMysqlRequestMaintenanceDow string

const (
	CreateDBAASServiceMysqlRequestMaintenanceDowSaturday  CreateDBAASServiceMysqlRequestMaintenanceDow = "saturday"
	CreateDBAASServiceMysqlRequestMaintenanceDowTuesday   CreateDBAASServiceMysqlRequestMaintenanceDow = "tuesday"
	CreateDBAASServiceMysqlRequestMaintenanceDowNever     CreateDBAASServiceMysqlRequestMaintenanceDow = "never"
	CreateDBAASServiceMysqlRequestMaintenanceDowWednesday CreateDBAASServiceMysqlRequestMaintenanceDow = "wednesday"
	CreateDBAASServiceMysqlRequestMaintenanceDowSunday    CreateDBAASServiceMysqlRequestMaintenanceDow = "sunday"
	CreateDBAASServiceMysqlRequestMaintenanceDowFriday    CreateDBAASServiceMysqlRequestMaintenanceDow = "friday"
	CreateDBAASServiceMysqlRequestMaintenanceDowMonday    CreateDBAASServiceMysqlRequestMaintenanceDow = "monday"
	CreateDBAASServiceMysqlRequestMaintenanceDowThursday  CreateDBAASServiceMysqlRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type CreateDBAASServiceMysqlRequestMaintenance struct {
	// Day of week for installing updates
	Dow CreateDBAASServiceMysqlRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

// Migrate data from existing server
type CreateDBAASServiceMysqlRequestMigration struct {
	// Database name for bootstrapping the initial connection
	Dbname string `json:"dbname,omitempty" validate:"omitempty,gte=1,lte=63"`
	// Hostname or IP address of the server where to migrate data from
	Host string `json:"host" validate:"required,gte=1,lte=255"`
	// Comma-separated list of databases, which should be ignored during migration (supported by MySQL only at the moment)
	IgnoreDbs string               `json:"ignore-dbs,omitempty" validate:"omitempty,gte=1,lte=2048"`
	Method    *EnumMigrationMethod `json:"method,omitempty"`
	// Password for authentication with the server where to migrate data from
	Password string `json:"password,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Port number of the server where to migrate data from
	Port int64 `json:"port" validate:"required,gte=1,lte=65535"`
	// The server where to migrate data from is secured with SSL
	SSL *bool `json:"ssl,omitempty"`
	// User name for authentication with the server where to migrate data from
	Username string `json:"username,omitempty" validate:"omitempty,gte=1,lte=255"`
}

type CreateDBAASServiceMysqlRequest struct {
	// Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
	AdminPassword string `json:"admin-password,omitempty" validate:"omitempty,gte=8,lte=256"`
	// Custom username for admin user. This must be set only when a new service is being created.
	AdminUsername  string                                        `json:"admin-username,omitempty" validate:"omitempty,gte=1,lte=64"`
	BackupSchedule *CreateDBAASServiceMysqlRequestBackupSchedule `json:"backup-schedule,omitempty"`
	// The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
	BinlogRetentionPeriod int64             `json:"binlog-retention-period,omitempty" validate:"omitempty,gte=600,lte=86400"`
	ForkFromService       *DBAASServiceName `json:"fork-from-service,omitempty" validate:"omitempty,gte=0,lte=63"`
	// Service integrations to be enabled when creating the service.
	Integrations []CreateDBAASServiceMysqlRequestIntegrations `json:"integrations,omitempty"`
	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
	IPFilter []string `json:"ip-filter,omitempty"`
	// Automatic maintenance settings
	Maintenance *CreateDBAASServiceMysqlRequestMaintenance `json:"maintenance,omitempty"`
	// Migrate data from existing server
	Migration *CreateDBAASServiceMysqlRequestMigration `json:"migration,omitempty"`
	// mysql.conf configuration values
	MysqlSettings JSONSchemaMysql `json:"mysql-settings,omitempty"`
	// Subscription plan
	Plan string `json:"plan" validate:"required,gte=1,lte=128"`
	// ISO time of a backup to recover from for services that support arbitrary times
	RecoveryBackupTime string `json:"recovery-backup-time,omitempty" validate:"omitempty,gte=1"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
	// MySQL major version
	Version string `json:"version,omitempty" validate:"omitempty,gte=1"`
}

// Create a DBaaS MySQL service
func (c ClientAPI) CreateDBAASServiceMysql(ctx context.Context, name string, req CreateDBAASServiceMysqlRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-mysql/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceMysql: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceMysql: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceMysql: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceMysql: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASServiceMysql returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceMysql: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateDBAASServiceMysqlRequestBackupSchedule struct {
	// The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
	BackupHour int64 `json:"backup-hour,omitempty" validate:"omitempty,gte=0,lte=23"`
	// The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
	BackupMinute int64 `json:"backup-minute,omitempty" validate:"omitempty,gte=0,lte=59"`
}

type UpdateDBAASServiceMysqlRequestMaintenanceDow string

const (
	UpdateDBAASServiceMysqlRequestMaintenanceDowSaturday  UpdateDBAASServiceMysqlRequestMaintenanceDow = "saturday"
	UpdateDBAASServiceMysqlRequestMaintenanceDowTuesday   UpdateDBAASServiceMysqlRequestMaintenanceDow = "tuesday"
	UpdateDBAASServiceMysqlRequestMaintenanceDowNever     UpdateDBAASServiceMysqlRequestMaintenanceDow = "never"
	UpdateDBAASServiceMysqlRequestMaintenanceDowWednesday UpdateDBAASServiceMysqlRequestMaintenanceDow = "wednesday"
	UpdateDBAASServiceMysqlRequestMaintenanceDowSunday    UpdateDBAASServiceMysqlRequestMaintenanceDow = "sunday"
	UpdateDBAASServiceMysqlRequestMaintenanceDowFriday    UpdateDBAASServiceMysqlRequestMaintenanceDow = "friday"
	UpdateDBAASServiceMysqlRequestMaintenanceDowMonday    UpdateDBAASServiceMysqlRequestMaintenanceDow = "monday"
	UpdateDBAASServiceMysqlRequestMaintenanceDowThursday  UpdateDBAASServiceMysqlRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type UpdateDBAASServiceMysqlRequestMaintenance struct {
	// Day of week for installing updates
	Dow UpdateDBAASServiceMysqlRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

// Migrate data from existing server
type UpdateDBAASServiceMysqlRequestMigration struct {
	// Database name for bootstrapping the initial connection
	Dbname string `json:"dbname,omitempty" validate:"omitempty,gte=1,lte=63"`
	// Hostname or IP address of the server where to migrate data from
	Host string `json:"host" validate:"required,gte=1,lte=255"`
	// Comma-separated list of databases, which should be ignored during migration (supported by MySQL only at the moment)
	IgnoreDbs string               `json:"ignore-dbs,omitempty" validate:"omitempty,gte=1,lte=2048"`
	Method    *EnumMigrationMethod `json:"method,omitempty"`
	// Password for authentication with the server where to migrate data from
	Password string `json:"password,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Port number of the server where to migrate data from
	Port int64 `json:"port" validate:"required,gte=1,lte=65535"`
	// The server where to migrate data from is secured with SSL
	SSL *bool `json:"ssl,omitempty"`
	// User name for authentication with the server where to migrate data from
	Username string `json:"username,omitempty" validate:"omitempty,gte=1,lte=255"`
}

type UpdateDBAASServiceMysqlRequest struct {
	BackupSchedule *UpdateDBAASServiceMysqlRequestBackupSchedule `json:"backup-schedule,omitempty"`
	// The minimum amount of time in seconds to keep binlog entries before deletion. This may be extended for services that require binlog entries for longer than the default for example if using the MySQL Debezium Kafka connector.
	BinlogRetentionPeriod int64 `json:"binlog-retention-period,omitempty" validate:"omitempty,gte=600,lte=86400"`
	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
	IPFilter []string `json:"ip-filter,omitempty"`
	// Automatic maintenance settings
	Maintenance *UpdateDBAASServiceMysqlRequestMaintenance `json:"maintenance,omitempty"`
	// Migrate data from existing server
	Migration *UpdateDBAASServiceMysqlRequestMigration `json:"migration,omitempty"`
	// mysql.conf configuration values
	MysqlSettings JSONSchemaMysql `json:"mysql-settings,omitempty"`
	// Subscription plan
	Plan string `json:"plan,omitempty" validate:"omitempty,gte=1,lte=128"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
}

// Update a DBaaS MySQL service
func (c ClientAPI) UpdateDBAASServiceMysql(ctx context.Context, name string, req UpdateDBAASServiceMysqlRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-mysql/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceMysql: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceMysql: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceMysql: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceMysql: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateDBAASServiceMysql returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceMysql: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Initiate MySQL maintenance update
func (c ClientAPI) StartDBAASMysqlMaintenance(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-mysql/%v/maintenance/start", name)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASMysqlMaintenance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("StartDBAASMysqlMaintenance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASMysqlMaintenance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request StartDBAASMysqlMaintenance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("StartDBAASMysqlMaintenance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Stop a DBaaS MySQL migration
func (c ClientAPI) StopDBAASMysqlMigration(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-mysql/%v/migration/stop", name)

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("StopDBAASMysqlMigration: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("StopDBAASMysqlMigration: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("StopDBAASMysqlMigration: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request StopDBAASMysqlMigration returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("StopDBAASMysqlMigration: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASMysqlDatabaseRequest struct {
	DatabaseName *DBAASDatabaseName `json:"database-name" validate:"required,gte=1,lte=40"`
}

// Create a DBaaS MySQL database
func (c ClientAPI) CreateDBAASMysqlDatabase(ctx context.Context, serviceName string, req CreateDBAASMysqlDatabaseRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-mysql/%v/database", serviceName)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASMysqlDatabase: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASMysqlDatabase: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASMysqlDatabase: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASMysqlDatabase: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASMysqlDatabase returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASMysqlDatabase: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a DBaaS MySQL database
func (c ClientAPI) DeleteDBAASMysqlDatabase(ctx context.Context, serviceName string, databaseName string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-mysql/%v/database/%v", serviceName, databaseName)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASMysqlDatabase: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASMysqlDatabase: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASMysqlDatabase: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASMysqlDatabase returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASMysqlDatabase: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASMysqlUserRequest struct {
	Authentication *EnumMysqlAuthenticationPlugin `json:"authentication,omitempty"`
	Username       *DBAASUserUsername             `json:"username" validate:"required,gte=1,lte=64"`
}

// Create a DBaaS MySQL user
func (c ClientAPI) CreateDBAASMysqlUser(ctx context.Context, serviceName string, req CreateDBAASMysqlUserRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-mysql/%v/user", serviceName)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASMysqlUser: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASMysqlUser: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASMysqlUser: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASMysqlUser: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASMysqlUser returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASMysqlUser: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a DBaaS MySQL user
func (c ClientAPI) DeleteDBAASMysqlUser(ctx context.Context, serviceName string, username string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-mysql/%v/user/%v", serviceName, username)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASMysqlUser: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASMysqlUser: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASMysqlUser: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASMysqlUser returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASMysqlUser: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetDBAASMysqlUserPasswordRequest struct {
	Authentication *EnumMysqlAuthenticationPlugin `json:"authentication,omitempty"`
	Password       *DBAASUserPassword             `json:"password,omitempty" validate:"omitempty,gte=8,lte=256"`
}

// If no password is provided one will be generated automatically.
func (c ClientAPI) ResetDBAASMysqlUserPassword(ctx context.Context, serviceName string, username string, req ResetDBAASMysqlUserPasswordRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-mysql/%v/user/%v/password/reset", serviceName, username)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASMysqlUserPassword: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASMysqlUserPassword: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetDBAASMysqlUserPassword: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASMysqlUserPassword: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetDBAASMysqlUserPassword returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetDBAASMysqlUserPassword: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a OpenSearch service
func (c ClientAPI) DeleteDBAASServiceOpensearch(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-opensearch/%v", name)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceOpensearch: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceOpensearch: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceOpensearch: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASServiceOpensearch returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceOpensearch: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get a DBaaS OpenSearch service
func (c ClientAPI) GetDBAASServiceOpensearch(ctx context.Context, name string) (*DBAASServiceOpensearch, error) {
	path := fmt.Sprintf("/dbaas-opensearch/%v", name)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceOpensearch: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceOpensearch: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceOpensearch: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASServiceOpensearch returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASServiceOpensearch{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceOpensearch: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithm string

const (
	CreateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithmAlphabetical CreateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithm = "alphabetical"
	CreateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithmCreationDate CreateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithm = "creation_date"
)

type CreateDBAASServiceOpensearchRequestIndexPatterns struct {
	// Maximum number of indexes to keep
	MaxIndexCount int64 `json:"max-index-count,omitempty" validate:"omitempty,gte=0"`
	// fnmatch pattern
	Pattern string `json:"pattern,omitempty" validate:"omitempty,lte=1024"`
	// Deletion sorting algorithm
	SortingAlgorithm CreateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithm `json:"sorting-algorithm,omitempty"`
}

// Template settings for all new indexes
type CreateDBAASServiceOpensearchRequestIndexTemplate struct {
	// The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is 10000.
	MappingNestedObjectsLimit int64 `json:"mapping-nested-objects-limit,omitempty" validate:"omitempty,gte=0,lte=100000"`
	// The number of replicas each primary shard has.
	NumberOfReplicas int64 `json:"number-of-replicas,omitempty" validate:"omitempty,gte=0,lte=29"`
	// The number of primary shards that an index should have.
	NumberOfShards int64 `json:"number-of-shards,omitempty" validate:"omitempty,gte=1,lte=1024"`
}

type CreateDBAASServiceOpensearchRequestMaintenanceDow string

const (
	CreateDBAASServiceOpensearchRequestMaintenanceDowSaturday  CreateDBAASServiceOpensearchRequestMaintenanceDow = "saturday"
	CreateDBAASServiceOpensearchRequestMaintenanceDowTuesday   CreateDBAASServiceOpensearchRequestMaintenanceDow = "tuesday"
	CreateDBAASServiceOpensearchRequestMaintenanceDowNever     CreateDBAASServiceOpensearchRequestMaintenanceDow = "never"
	CreateDBAASServiceOpensearchRequestMaintenanceDowWednesday CreateDBAASServiceOpensearchRequestMaintenanceDow = "wednesday"
	CreateDBAASServiceOpensearchRequestMaintenanceDowSunday    CreateDBAASServiceOpensearchRequestMaintenanceDow = "sunday"
	CreateDBAASServiceOpensearchRequestMaintenanceDowFriday    CreateDBAASServiceOpensearchRequestMaintenanceDow = "friday"
	CreateDBAASServiceOpensearchRequestMaintenanceDowMonday    CreateDBAASServiceOpensearchRequestMaintenanceDow = "monday"
	CreateDBAASServiceOpensearchRequestMaintenanceDowThursday  CreateDBAASServiceOpensearchRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type CreateDBAASServiceOpensearchRequestMaintenance struct {
	// Day of week for installing updates
	Dow CreateDBAASServiceOpensearchRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

// OpenSearch Dashboards settings
type CreateDBAASServiceOpensearchRequestOpensearchDashboards struct {
	// Enable or disable OpenSearch Dashboards (default: true)
	Enabled *bool `json:"enabled,omitempty"`
	// Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max_old_space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128)
	MaxOldSpaceSize int64 `json:"max-old-space-size,omitempty" validate:"omitempty,gte=64,lte=1024"`
	// Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
	OpensearchRequestTimeout int64 `json:"opensearch-request-timeout,omitempty" validate:"omitempty,gte=5000,lte=120000"`
}

type CreateDBAASServiceOpensearchRequest struct {
	ForkFromService *DBAASServiceName `json:"fork-from-service,omitempty" validate:"omitempty,gte=0,lte=63"`
	// Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
	IndexPatterns []CreateDBAASServiceOpensearchRequestIndexPatterns `json:"index-patterns,omitempty"`
	// Template settings for all new indexes
	IndexTemplate *CreateDBAASServiceOpensearchRequestIndexTemplate `json:"index-template,omitempty"`
	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
	IPFilter []string `json:"ip-filter,omitempty"`
	// Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
	KeepIndexRefreshInterval *bool `json:"keep-index-refresh-interval,omitempty"`
	// Automatic maintenance settings
	Maintenance *CreateDBAASServiceOpensearchRequestMaintenance `json:"maintenance,omitempty"`
	// Maximum number of indexes to keep before deleting the oldest one
	MaxIndexCount int64 `json:"max-index-count,omitempty" validate:"omitempty,gte=0"`
	// OpenSearch Dashboards settings
	OpensearchDashboards *CreateDBAASServiceOpensearchRequestOpensearchDashboards `json:"opensearch-dashboards,omitempty"`
	// OpenSearch settings
	OpensearchSettings JSONSchemaOpensearch `json:"opensearch-settings,omitempty"`
	// Subscription plan
	Plan string `json:"plan" validate:"required,gte=1,lte=128"`
	// Name of a backup to recover from for services that support backup names
	RecoveryBackupName string `json:"recovery-backup-name,omitempty" validate:"omitempty,gte=1"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
	// OpenSearch major version
	Version string `json:"version,omitempty" validate:"omitempty,gte=1"`
}

// Create a DBaaS OpenSearch service
func (c ClientAPI) CreateDBAASServiceOpensearch(ctx context.Context, name string, req CreateDBAASServiceOpensearchRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-opensearch/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceOpensearch: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceOpensearch: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceOpensearch: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceOpensearch: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASServiceOpensearch returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceOpensearch: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithm string

const (
	UpdateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithmAlphabetical UpdateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithm = "alphabetical"
	UpdateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithmCreationDate UpdateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithm = "creation_date"
)

type UpdateDBAASServiceOpensearchRequestIndexPatterns struct {
	// Maximum number of indexes to keep
	MaxIndexCount int64 `json:"max-index-count,omitempty" validate:"omitempty,gte=0"`
	// fnmatch pattern
	Pattern string `json:"pattern,omitempty" validate:"omitempty,lte=1024"`
	// Deletion sorting algorithm
	SortingAlgorithm UpdateDBAASServiceOpensearchRequestIndexPatternsSortingAlgorithm `json:"sorting-algorithm,omitempty"`
}

// Template settings for all new indexes
type UpdateDBAASServiceOpensearchRequestIndexTemplate struct {
	// The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps to prevent out of memory errors when a document contains too many nested objects. Default is 10000.
	MappingNestedObjectsLimit int64 `json:"mapping-nested-objects-limit,omitempty" validate:"omitempty,gte=0,lte=100000"`
	// The number of replicas each primary shard has.
	NumberOfReplicas int64 `json:"number-of-replicas,omitempty" validate:"omitempty,gte=0,lte=29"`
	// The number of primary shards that an index should have.
	NumberOfShards int64 `json:"number-of-shards,omitempty" validate:"omitempty,gte=1,lte=1024"`
}

type UpdateDBAASServiceOpensearchRequestMaintenanceDow string

const (
	UpdateDBAASServiceOpensearchRequestMaintenanceDowSaturday  UpdateDBAASServiceOpensearchRequestMaintenanceDow = "saturday"
	UpdateDBAASServiceOpensearchRequestMaintenanceDowTuesday   UpdateDBAASServiceOpensearchRequestMaintenanceDow = "tuesday"
	UpdateDBAASServiceOpensearchRequestMaintenanceDowNever     UpdateDBAASServiceOpensearchRequestMaintenanceDow = "never"
	UpdateDBAASServiceOpensearchRequestMaintenanceDowWednesday UpdateDBAASServiceOpensearchRequestMaintenanceDow = "wednesday"
	UpdateDBAASServiceOpensearchRequestMaintenanceDowSunday    UpdateDBAASServiceOpensearchRequestMaintenanceDow = "sunday"
	UpdateDBAASServiceOpensearchRequestMaintenanceDowFriday    UpdateDBAASServiceOpensearchRequestMaintenanceDow = "friday"
	UpdateDBAASServiceOpensearchRequestMaintenanceDowMonday    UpdateDBAASServiceOpensearchRequestMaintenanceDow = "monday"
	UpdateDBAASServiceOpensearchRequestMaintenanceDowThursday  UpdateDBAASServiceOpensearchRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type UpdateDBAASServiceOpensearchRequestMaintenance struct {
	// Day of week for installing updates
	Dow UpdateDBAASServiceOpensearchRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

// OpenSearch Dashboards settings
type UpdateDBAASServiceOpensearchRequestOpensearchDashboards struct {
	// Enable or disable OpenSearch Dashboards (default: true)
	Enabled *bool `json:"enabled,omitempty"`
	// Limits the maximum amount of memory (in MiB) the OpenSearch Dashboards process can use. This sets the max_old_space_size option of the nodejs running the OpenSearch Dashboards. Note: the memory reserved by OpenSearch Dashboards is not available for OpenSearch. (default: 128)
	MaxOldSpaceSize int64 `json:"max-old-space-size,omitempty" validate:"omitempty,gte=64,lte=1024"`
	// Timeout in milliseconds for requests made by OpenSearch Dashboards towards OpenSearch (default: 30000)
	OpensearchRequestTimeout int64 `json:"opensearch-request-timeout,omitempty" validate:"omitempty,gte=5000,lte=120000"`
}

type UpdateDBAASServiceOpensearchRequest struct {
	// Allows you to create glob style patterns and set a max number of indexes matching this pattern you want to keep. Creating indexes exceeding this value will cause the oldest one to get deleted. You could for example create a pattern looking like 'logs.?' and then create index logs.1, logs.2 etc, it will delete logs.1 once you create logs.6. Do note 'logs.?' does not apply to logs.10. Note: Setting max_index_count to 0 will do nothing and the pattern gets ignored.
	IndexPatterns []UpdateDBAASServiceOpensearchRequestIndexPatterns `json:"index-patterns,omitempty"`
	// Template settings for all new indexes
	IndexTemplate *UpdateDBAASServiceOpensearchRequestIndexTemplate `json:"index-template,omitempty"`
	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
	IPFilter []string `json:"ip-filter,omitempty"`
	// Aiven automation resets index.refresh_interval to default value for every index to be sure that indices are always visible to search. If it doesn't fit your case, you can disable this by setting up this flag to true.
	KeepIndexRefreshInterval *bool `json:"keep-index-refresh-interval,omitempty"`
	// Automatic maintenance settings
	Maintenance *UpdateDBAASServiceOpensearchRequestMaintenance `json:"maintenance,omitempty"`
	// Maximum number of indexes to keep before deleting the oldest one
	MaxIndexCount int64 `json:"max-index-count,omitempty" validate:"omitempty,gte=0"`
	// OpenSearch Dashboards settings
	OpensearchDashboards *UpdateDBAASServiceOpensearchRequestOpensearchDashboards `json:"opensearch-dashboards,omitempty"`
	// OpenSearch settings
	OpensearchSettings JSONSchemaOpensearch `json:"opensearch-settings,omitempty"`
	// Subscription plan
	Plan string `json:"plan,omitempty" validate:"omitempty,gte=1,lte=128"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
	// Version
	Version string `json:"version,omitempty"`
}

// Update a DBaaS OpenSearch service
func (c ClientAPI) UpdateDBAASServiceOpensearch(ctx context.Context, name string, req UpdateDBAASServiceOpensearchRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-opensearch/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceOpensearch: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceOpensearch: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceOpensearch: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceOpensearch: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateDBAASServiceOpensearch returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceOpensearch: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get DBaaS OpenSearch ACL configuration
func (c ClientAPI) GetDBAASOpensearchAclConfig(ctx context.Context, name string) (*DBAASOpensearchAclConfig, error) {
	path := fmt.Sprintf("/dbaas-opensearch/%v/acl-config", name)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASOpensearchAclConfig: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASOpensearchAclConfig: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASOpensearchAclConfig: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASOpensearchAclConfig returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASOpensearchAclConfig{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASOpensearchAclConfig: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Create a DBaaS OpenSearch ACL configuration
func (c ClientAPI) UpdateDBAASOpensearchAclConfig(ctx context.Context, name string, req DBAASOpensearchAclConfig) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-opensearch/%v/acl-config", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASOpensearchAclConfig: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASOpensearchAclConfig: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateDBAASOpensearchAclConfig: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASOpensearchAclConfig: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateDBAASOpensearchAclConfig returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateDBAASOpensearchAclConfig: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Initiate OpenSearch maintenance update
func (c ClientAPI) StartDBAASOpensearchMaintenance(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-opensearch/%v/maintenance/start", name)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASOpensearchMaintenance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("StartDBAASOpensearchMaintenance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASOpensearchMaintenance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request StartDBAASOpensearchMaintenance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("StartDBAASOpensearchMaintenance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASOpensearchUserRequest struct {
	Username *DBAASUserUsername `json:"username" validate:"required,gte=1,lte=64"`
}

// Create a DBaaS OpenSearch user
func (c ClientAPI) CreateDBAASOpensearchUser(ctx context.Context, serviceName string, req CreateDBAASOpensearchUserRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-opensearch/%v/user", serviceName)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASOpensearchUser: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASOpensearchUser: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASOpensearchUser: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASOpensearchUser: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASOpensearchUser returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASOpensearchUser: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a DBaaS OpenSearch user
func (c ClientAPI) DeleteDBAASOpensearchUser(ctx context.Context, serviceName string, username string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-opensearch/%v/user/%v", serviceName, username)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASOpensearchUser: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASOpensearchUser: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASOpensearchUser: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASOpensearchUser returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASOpensearchUser: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetDBAASOpensearchUserPasswordRequest struct {
	Password *DBAASUserPassword `json:"password,omitempty" validate:"omitempty,gte=8,lte=256"`
}

// If no password is provided one will be generated automatically.
func (c ClientAPI) ResetDBAASOpensearchUserPassword(ctx context.Context, serviceName string, username string, req ResetDBAASOpensearchUserPasswordRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-opensearch/%v/user/%v/password/reset", serviceName, username)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASOpensearchUserPassword: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASOpensearchUserPassword: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetDBAASOpensearchUserPassword: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASOpensearchUserPassword: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetDBAASOpensearchUserPassword returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetDBAASOpensearchUserPassword: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Postgres service
func (c ClientAPI) DeleteDBAASServicePG(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v", name)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServicePG: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServicePG: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServicePG: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASServicePG returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServicePG: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get a DBaaS PostgreSQL service
func (c ClientAPI) GetDBAASServicePG(ctx context.Context, name string) (*DBAASServicePG, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v", name)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServicePG: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASServicePG: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServicePG: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASServicePG returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASServicePG{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASServicePG: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASServicePGRequestBackupSchedule struct {
	// The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
	BackupHour int64 `json:"backup-hour,omitempty" validate:"omitempty,gte=0,lte=23"`
	// The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
	BackupMinute int64 `json:"backup-minute,omitempty" validate:"omitempty,gte=0,lte=59"`
}

type CreateDBAASServicePGRequestIntegrationsType string

const (
	CreateDBAASServicePGRequestIntegrationsTypeReadReplica CreateDBAASServicePGRequestIntegrationsType = "read_replica"
)

type CreateDBAASServicePGRequestIntegrations struct {
	DestService *DBAASServiceName `json:"dest-service,omitempty" validate:"omitempty,gte=0,lte=63"`
	// Integration settings
	Settings      map[string]any    `json:"settings,omitempty"`
	SourceService *DBAASServiceName `json:"source-service,omitempty" validate:"omitempty,gte=0,lte=63"`
	// Integration type
	Type CreateDBAASServicePGRequestIntegrationsType `json:"type" validate:"required"`
}

type CreateDBAASServicePGRequestMaintenanceDow string

const (
	CreateDBAASServicePGRequestMaintenanceDowSaturday  CreateDBAASServicePGRequestMaintenanceDow = "saturday"
	CreateDBAASServicePGRequestMaintenanceDowTuesday   CreateDBAASServicePGRequestMaintenanceDow = "tuesday"
	CreateDBAASServicePGRequestMaintenanceDowNever     CreateDBAASServicePGRequestMaintenanceDow = "never"
	CreateDBAASServicePGRequestMaintenanceDowWednesday CreateDBAASServicePGRequestMaintenanceDow = "wednesday"
	CreateDBAASServicePGRequestMaintenanceDowSunday    CreateDBAASServicePGRequestMaintenanceDow = "sunday"
	CreateDBAASServicePGRequestMaintenanceDowFriday    CreateDBAASServicePGRequestMaintenanceDow = "friday"
	CreateDBAASServicePGRequestMaintenanceDowMonday    CreateDBAASServicePGRequestMaintenanceDow = "monday"
	CreateDBAASServicePGRequestMaintenanceDowThursday  CreateDBAASServicePGRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type CreateDBAASServicePGRequestMaintenance struct {
	// Day of week for installing updates
	Dow CreateDBAASServicePGRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

// Migrate data from existing server
type CreateDBAASServicePGRequestMigration struct {
	// Database name for bootstrapping the initial connection
	Dbname string `json:"dbname,omitempty" validate:"omitempty,gte=1,lte=63"`
	// Hostname or IP address of the server where to migrate data from
	Host string `json:"host" validate:"required,gte=1,lte=255"`
	// Comma-separated list of databases, which should be ignored during migration (supported by MySQL only at the moment)
	IgnoreDbs string               `json:"ignore-dbs,omitempty" validate:"omitempty,gte=1,lte=2048"`
	Method    *EnumMigrationMethod `json:"method,omitempty"`
	// Password for authentication with the server where to migrate data from
	Password string `json:"password,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Port number of the server where to migrate data from
	Port int64 `json:"port" validate:"required,gte=1,lte=65535"`
	// The server where to migrate data from is secured with SSL
	SSL *bool `json:"ssl,omitempty"`
	// User name for authentication with the server where to migrate data from
	Username string `json:"username,omitempty" validate:"omitempty,gte=1,lte=255"`
}

type CreateDBAASServicePGRequest struct {
	// Custom password for admin user. Defaults to random string. This must be set only when a new service is being created.
	AdminPassword string `json:"admin-password,omitempty" validate:"omitempty,gte=8,lte=256"`
	// Custom username for admin user. This must be set only when a new service is being created.
	AdminUsername   string                                     `json:"admin-username,omitempty" validate:"omitempty,gte=1,lte=64"`
	BackupSchedule  *CreateDBAASServicePGRequestBackupSchedule `json:"backup-schedule,omitempty"`
	ForkFromService *DBAASServiceName                          `json:"fork-from-service,omitempty" validate:"omitempty,gte=0,lte=63"`
	// Service integrations to be enabled when creating the service.
	Integrations []CreateDBAASServicePGRequestIntegrations `json:"integrations,omitempty"`
	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
	IPFilter []string `json:"ip-filter,omitempty"`
	// Automatic maintenance settings
	Maintenance *CreateDBAASServicePGRequestMaintenance `json:"maintenance,omitempty"`
	// Migrate data from existing server
	Migration *CreateDBAASServicePGRequestMigration `json:"migration,omitempty"`
	// postgresql.conf configuration values
	PGSettings JSONSchemaPG `json:"pg-settings,omitempty"`
	// PGBouncer connection pooling settings
	PgbouncerSettings JSONSchemaPgbouncer `json:"pgbouncer-settings,omitempty"`
	// PGLookout settings
	PglookoutSettings JSONSchemaPglookout `json:"pglookout-settings,omitempty"`
	// Subscription plan
	Plan string `json:"plan" validate:"required,gte=1,lte=128"`
	// ISO time of a backup to recover from for services that support arbitrary times
	RecoveryBackupTime string `json:"recovery-backup-time,omitempty" validate:"omitempty,gte=1"`
	// Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the shared_buffers configuration value.
	SharedBuffersPercentage int64                         `json:"shared-buffers-percentage,omitempty" validate:"omitempty,gte=20,lte=60"`
	SynchronousReplication  *EnumPGSynchronousReplication `json:"synchronous-replication,omitempty"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
	// TimescaleDB extension configuration values
	TimescaledbSettings JSONSchemaTimescaledb `json:"timescaledb-settings,omitempty"`
	Variant             *EnumPGVariant        `json:"variant,omitempty"`
	// PostgreSQL major version
	Version string `json:"version,omitempty" validate:"omitempty,gte=1"`
	// Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
	WorkMem int64 `json:"work-mem,omitempty" validate:"omitempty,gte=1,lte=1024"`
}

// Create a DBaaS PostgreSQL service
func (c ClientAPI) CreateDBAASServicePG(ctx context.Context, name string, req CreateDBAASServicePGRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServicePG: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServicePG: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASServicePG: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServicePG: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASServicePG returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASServicePG: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateDBAASServicePGRequestBackupSchedule struct {
	// The hour of day (in UTC) when backup for the service is started. New backup is only started if previous backup has already completed.
	BackupHour int64 `json:"backup-hour,omitempty" validate:"omitempty,gte=0,lte=23"`
	// The minute of an hour when backup for the service is started. New backup is only started if previous backup has already completed.
	BackupMinute int64 `json:"backup-minute,omitempty" validate:"omitempty,gte=0,lte=59"`
}

type UpdateDBAASServicePGRequestMaintenanceDow string

const (
	UpdateDBAASServicePGRequestMaintenanceDowSaturday  UpdateDBAASServicePGRequestMaintenanceDow = "saturday"
	UpdateDBAASServicePGRequestMaintenanceDowTuesday   UpdateDBAASServicePGRequestMaintenanceDow = "tuesday"
	UpdateDBAASServicePGRequestMaintenanceDowNever     UpdateDBAASServicePGRequestMaintenanceDow = "never"
	UpdateDBAASServicePGRequestMaintenanceDowWednesday UpdateDBAASServicePGRequestMaintenanceDow = "wednesday"
	UpdateDBAASServicePGRequestMaintenanceDowSunday    UpdateDBAASServicePGRequestMaintenanceDow = "sunday"
	UpdateDBAASServicePGRequestMaintenanceDowFriday    UpdateDBAASServicePGRequestMaintenanceDow = "friday"
	UpdateDBAASServicePGRequestMaintenanceDowMonday    UpdateDBAASServicePGRequestMaintenanceDow = "monday"
	UpdateDBAASServicePGRequestMaintenanceDowThursday  UpdateDBAASServicePGRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type UpdateDBAASServicePGRequestMaintenance struct {
	// Day of week for installing updates
	Dow UpdateDBAASServicePGRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

// Migrate data from existing server
type UpdateDBAASServicePGRequestMigration struct {
	// Database name for bootstrapping the initial connection
	Dbname string `json:"dbname,omitempty" validate:"omitempty,gte=1,lte=63"`
	// Hostname or IP address of the server where to migrate data from
	Host string `json:"host" validate:"required,gte=1,lte=255"`
	// Comma-separated list of databases, which should be ignored during migration (supported by MySQL only at the moment)
	IgnoreDbs string               `json:"ignore-dbs,omitempty" validate:"omitempty,gte=1,lte=2048"`
	Method    *EnumMigrationMethod `json:"method,omitempty"`
	// Password for authentication with the server where to migrate data from
	Password string `json:"password,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Port number of the server where to migrate data from
	Port int64 `json:"port" validate:"required,gte=1,lte=65535"`
	// The server where to migrate data from is secured with SSL
	SSL *bool `json:"ssl,omitempty"`
	// User name for authentication with the server where to migrate data from
	Username string `json:"username,omitempty" validate:"omitempty,gte=1,lte=255"`
}

type UpdateDBAASServicePGRequest struct {
	BackupSchedule *UpdateDBAASServicePGRequestBackupSchedule `json:"backup-schedule,omitempty"`
	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
	IPFilter []string `json:"ip-filter,omitempty"`
	// Automatic maintenance settings
	Maintenance *UpdateDBAASServicePGRequestMaintenance `json:"maintenance,omitempty"`
	// Migrate data from existing server
	Migration *UpdateDBAASServicePGRequestMigration `json:"migration,omitempty"`
	// postgresql.conf configuration values
	PGSettings JSONSchemaPG `json:"pg-settings,omitempty"`
	// PGBouncer connection pooling settings
	PgbouncerSettings JSONSchemaPgbouncer `json:"pgbouncer-settings,omitempty"`
	// PGLookout settings
	PglookoutSettings JSONSchemaPglookout `json:"pglookout-settings,omitempty"`
	// Subscription plan
	Plan string `json:"plan,omitempty" validate:"omitempty,gte=1,lte=128"`
	// Percentage of total RAM that the database server uses for shared memory buffers. Valid range is 20-60 (float), which corresponds to 20% - 60%. This setting adjusts the shared_buffers configuration value.
	SharedBuffersPercentage int64                         `json:"shared-buffers-percentage,omitempty" validate:"omitempty,gte=20,lte=60"`
	SynchronousReplication  *EnumPGSynchronousReplication `json:"synchronous-replication,omitempty"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
	// TimescaleDB extension configuration values
	TimescaledbSettings JSONSchemaTimescaledb `json:"timescaledb-settings,omitempty"`
	Variant             *EnumPGVariant        `json:"variant,omitempty"`
	// Version
	Version string `json:"version,omitempty"`
	// Sets the maximum amount of memory to be used by a query operation (such as a sort or hash table) before writing to temporary disk files, in MB. Default is 1MB + 0.075% of total RAM (up to 32MB).
	WorkMem int64 `json:"work-mem,omitempty" validate:"omitempty,gte=1,lte=1024"`
}

// Update a DBaaS PostgreSQL service
func (c ClientAPI) UpdateDBAASServicePG(ctx context.Context, name string, req UpdateDBAASServicePGRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServicePG: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServicePG: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServicePG: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServicePG: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateDBAASServicePG returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServicePG: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Initiate PostgreSQL maintenance update
func (c ClientAPI) StartDBAASPGMaintenance(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/maintenance/start", name)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASPGMaintenance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("StartDBAASPGMaintenance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASPGMaintenance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request StartDBAASPGMaintenance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("StartDBAASPGMaintenance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Stop a DBaaS PostgreSQL migration
func (c ClientAPI) StopDBAASPGMigration(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/migration/stop", name)

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("StopDBAASPGMigration: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("StopDBAASPGMigration: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("StopDBAASPGMigration: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request StopDBAASPGMigration returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("StopDBAASPGMigration: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASPGConnectionPoolRequest struct {
	DatabaseName *DBAASDatabaseName   `json:"database-name" validate:"required,gte=1,lte=40"`
	Mode         *EnumPGPoolMode      `json:"mode,omitempty"`
	Name         *DBAASPGPoolName     `json:"name" validate:"required,gte=1,lte=63"`
	Size         *DBAASPGPoolSize     `json:"size,omitempty" validate:"omitempty,gte=1,lte=10000"`
	Username     *DBAASPGPoolUsername `json:"username,omitempty" validate:"omitempty,gte=1,lte=64"`
}

// Create a DBaaS PostgreSQL connection pool
func (c ClientAPI) CreateDBAASPGConnectionPool(ctx context.Context, serviceName string, req CreateDBAASPGConnectionPoolRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/connection-pool", serviceName)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPGConnectionPool: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPGConnectionPool: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASPGConnectionPool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPGConnectionPool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASPGConnectionPool returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASPGConnectionPool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a DBaaS PostgreSQL connection pool
func (c ClientAPI) DeleteDBAASPGConnectionPool(ctx context.Context, serviceName string, connectionPoolName string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/connection-pool/%v", serviceName, connectionPoolName)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASPGConnectionPool: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASPGConnectionPool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASPGConnectionPool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASPGConnectionPool returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASPGConnectionPool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateDBAASPGConnectionPoolRequest struct {
	DatabaseName *DBAASDatabaseName   `json:"database-name,omitempty" validate:"omitempty,gte=1,lte=40"`
	Mode         *EnumPGPoolMode      `json:"mode,omitempty"`
	Size         *DBAASPGPoolSize     `json:"size,omitempty" validate:"omitempty,gte=1,lte=10000"`
	Username     *DBAASPGPoolUsername `json:"username,omitempty" validate:"omitempty,gte=1,lte=64"`
}

// Update a DBaaS PostgreSQL connection pool
func (c ClientAPI) UpdateDBAASPGConnectionPool(ctx context.Context, serviceName string, connectionPoolName string, req UpdateDBAASPGConnectionPoolRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/connection-pool/%v", serviceName, connectionPoolName)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASPGConnectionPool: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASPGConnectionPool: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateDBAASPGConnectionPool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASPGConnectionPool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateDBAASPGConnectionPool returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateDBAASPGConnectionPool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASPGDatabaseRequest struct {
	DatabaseName *DBAASDatabaseName `json:"database-name" validate:"required,gte=1,lte=40"`
	// Default string sort order (LC_COLLATE) for PostgreSQL database
	LCCollate string `json:"lc-collate,omitempty" validate:"omitempty,lte=128"`
	// Default character classification (LC_CTYPE) for PostgreSQL database
	LCCtype string `json:"lc-ctype,omitempty" validate:"omitempty,lte=128"`
}

// Create a DBaaS Postgres database
func (c ClientAPI) CreateDBAASPGDatabase(ctx context.Context, serviceName string, req CreateDBAASPGDatabaseRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/database", serviceName)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPGDatabase: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPGDatabase: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASPGDatabase: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPGDatabase: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASPGDatabase returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASPGDatabase: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a DBaaS Postgres database
func (c ClientAPI) DeleteDBAASPGDatabase(ctx context.Context, serviceName string, databaseName string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/database/%v", serviceName, databaseName)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASPGDatabase: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASPGDatabase: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASPGDatabase: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASPGDatabase returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASPGDatabase: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASPostgresUserRequest struct {
	AllowReplication *bool              `json:"allow-replication,omitempty"`
	Username         *DBAASUserUsername `json:"username" validate:"required,gte=1,lte=64"`
}

// Create a DBaaS Postgres user
func (c ClientAPI) CreateDBAASPostgresUser(ctx context.Context, serviceName string, req CreateDBAASPostgresUserRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/user", serviceName)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPostgresUser: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPostgresUser: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASPostgresUser: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPostgresUser: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASPostgresUser returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASPostgresUser: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a DBaaS Postgres user
func (c ClientAPI) DeleteDBAASPostgresUser(ctx context.Context, serviceName string, username string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/user/%v", serviceName, username)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASPostgresUser: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASPostgresUser: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASPostgresUser: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASPostgresUser returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASPostgresUser: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateDBAASPostgresAllowReplicationRequest struct {
	AllowReplication *bool `json:"allow-replication,omitempty"`
}

// Update access control for one service user
func (c ClientAPI) UpdateDBAASPostgresAllowReplication(ctx context.Context, serviceName string, username string, req UpdateDBAASPostgresAllowReplicationRequest) (*DBAASPostgresUsers, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/user/%v/allow-replication", serviceName, username)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASPostgresAllowReplication: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASPostgresAllowReplication: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateDBAASPostgresAllowReplication: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASPostgresAllowReplication: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateDBAASPostgresAllowReplication returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASPostgresUsers{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateDBAASPostgresAllowReplication: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetDBAASPostgresUserPasswordRequest struct {
	Password *DBAASUserPassword `json:"password,omitempty" validate:"omitempty,gte=8,lte=256"`
}

// If no password is provided one will be generated automatically.
func (c ClientAPI) ResetDBAASPostgresUserPassword(ctx context.Context, serviceName string, username string, req ResetDBAASPostgresUserPasswordRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/user/%v/password/reset", serviceName, username)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASPostgresUserPassword: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASPostgresUserPassword: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetDBAASPostgresUserPassword: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetDBAASPostgresUserPassword: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetDBAASPostgresUserPassword returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetDBAASPostgresUserPassword: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASPGUpgradeCheckRequestTargetVersion string

const (
	CreateDBAASPGUpgradeCheckRequestTargetVersion14 CreateDBAASPGUpgradeCheckRequestTargetVersion = "14"
	CreateDBAASPGUpgradeCheckRequestTargetVersion15 CreateDBAASPGUpgradeCheckRequestTargetVersion = "15"
	CreateDBAASPGUpgradeCheckRequestTargetVersion12 CreateDBAASPGUpgradeCheckRequestTargetVersion = "12"
	CreateDBAASPGUpgradeCheckRequestTargetVersion13 CreateDBAASPGUpgradeCheckRequestTargetVersion = "13"
	CreateDBAASPGUpgradeCheckRequestTargetVersion11 CreateDBAASPGUpgradeCheckRequestTargetVersion = "11"
)

type CreateDBAASPGUpgradeCheckRequest struct {
	// Target version for upgrade
	TargetVersion CreateDBAASPGUpgradeCheckRequestTargetVersion `json:"target-version" validate:"required"`
}

// Check whether you can upgrade Postgres service to a newer version
func (c ClientAPI) CreateDBAASPGUpgradeCheck(ctx context.Context, service string, req CreateDBAASPGUpgradeCheckRequest) (*DBAASTask, error) {
	path := fmt.Sprintf("/dbaas-postgres/%v/upgrade-check", service)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPGUpgradeCheck: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPGUpgradeCheck: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASPGUpgradeCheck: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASPGUpgradeCheck: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASPGUpgradeCheck returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASTask{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASPGUpgradeCheck: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Redis service
func (c ClientAPI) DeleteDBAASServiceRedis(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-redis/%v", name)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceRedis: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceRedis: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceRedis: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASServiceRedis returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASServiceRedis: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get a DBaaS Redis service
func (c ClientAPI) GetDBAASServiceRedis(ctx context.Context, name string) (*DBAASServiceRedis, error) {
	path := fmt.Sprintf("/dbaas-redis/%v", name)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceRedis: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceRedis: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceRedis: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASServiceRedis returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASServiceRedis{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceRedis: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASServiceRedisRequestMaintenanceDow string

const (
	CreateDBAASServiceRedisRequestMaintenanceDowSaturday  CreateDBAASServiceRedisRequestMaintenanceDow = "saturday"
	CreateDBAASServiceRedisRequestMaintenanceDowTuesday   CreateDBAASServiceRedisRequestMaintenanceDow = "tuesday"
	CreateDBAASServiceRedisRequestMaintenanceDowNever     CreateDBAASServiceRedisRequestMaintenanceDow = "never"
	CreateDBAASServiceRedisRequestMaintenanceDowWednesday CreateDBAASServiceRedisRequestMaintenanceDow = "wednesday"
	CreateDBAASServiceRedisRequestMaintenanceDowSunday    CreateDBAASServiceRedisRequestMaintenanceDow = "sunday"
	CreateDBAASServiceRedisRequestMaintenanceDowFriday    CreateDBAASServiceRedisRequestMaintenanceDow = "friday"
	CreateDBAASServiceRedisRequestMaintenanceDowMonday    CreateDBAASServiceRedisRequestMaintenanceDow = "monday"
	CreateDBAASServiceRedisRequestMaintenanceDowThursday  CreateDBAASServiceRedisRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type CreateDBAASServiceRedisRequestMaintenance struct {
	// Day of week for installing updates
	Dow CreateDBAASServiceRedisRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

// Migrate data from existing server
type CreateDBAASServiceRedisRequestMigration struct {
	// Database name for bootstrapping the initial connection
	Dbname string `json:"dbname,omitempty" validate:"omitempty,gte=1,lte=63"`
	// Hostname or IP address of the server where to migrate data from
	Host string `json:"host" validate:"required,gte=1,lte=255"`
	// Comma-separated list of databases, which should be ignored during migration (supported by MySQL only at the moment)
	IgnoreDbs string               `json:"ignore-dbs,omitempty" validate:"omitempty,gte=1,lte=2048"`
	Method    *EnumMigrationMethod `json:"method,omitempty"`
	// Password for authentication with the server where to migrate data from
	Password string `json:"password,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Port number of the server where to migrate data from
	Port int64 `json:"port" validate:"required,gte=1,lte=65535"`
	// The server where to migrate data from is secured with SSL
	SSL *bool `json:"ssl,omitempty"`
	// User name for authentication with the server where to migrate data from
	Username string `json:"username,omitempty" validate:"omitempty,gte=1,lte=255"`
}

type CreateDBAASServiceRedisRequest struct {
	ForkFromService *DBAASServiceName `json:"fork-from-service,omitempty" validate:"omitempty,gte=0,lte=63"`
	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
	IPFilter []string `json:"ip-filter,omitempty"`
	// Automatic maintenance settings
	Maintenance *CreateDBAASServiceRedisRequestMaintenance `json:"maintenance,omitempty"`
	// Migrate data from existing server
	Migration *CreateDBAASServiceRedisRequestMigration `json:"migration,omitempty"`
	// Subscription plan
	Plan string `json:"plan" validate:"required,gte=1,lte=128"`
	// Name of a backup to recover from for services that support backup names
	RecoveryBackupName string `json:"recovery-backup-name,omitempty" validate:"omitempty,gte=1"`
	// Redis settings
	RedisSettings *JSONSchemaRedis `json:"redis-settings,omitempty"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
}

// Create a DBaaS Redis service
func (c ClientAPI) CreateDBAASServiceRedis(ctx context.Context, name string, req CreateDBAASServiceRedisRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-redis/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceRedis: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceRedis: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceRedis: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceRedis: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASServiceRedis returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASServiceRedis: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateDBAASServiceRedisRequestMaintenanceDow string

const (
	UpdateDBAASServiceRedisRequestMaintenanceDowSaturday  UpdateDBAASServiceRedisRequestMaintenanceDow = "saturday"
	UpdateDBAASServiceRedisRequestMaintenanceDowTuesday   UpdateDBAASServiceRedisRequestMaintenanceDow = "tuesday"
	UpdateDBAASServiceRedisRequestMaintenanceDowNever     UpdateDBAASServiceRedisRequestMaintenanceDow = "never"
	UpdateDBAASServiceRedisRequestMaintenanceDowWednesday UpdateDBAASServiceRedisRequestMaintenanceDow = "wednesday"
	UpdateDBAASServiceRedisRequestMaintenanceDowSunday    UpdateDBAASServiceRedisRequestMaintenanceDow = "sunday"
	UpdateDBAASServiceRedisRequestMaintenanceDowFriday    UpdateDBAASServiceRedisRequestMaintenanceDow = "friday"
	UpdateDBAASServiceRedisRequestMaintenanceDowMonday    UpdateDBAASServiceRedisRequestMaintenanceDow = "monday"
	UpdateDBAASServiceRedisRequestMaintenanceDowThursday  UpdateDBAASServiceRedisRequestMaintenanceDow = "thursday"
)

// Automatic maintenance settings
type UpdateDBAASServiceRedisRequestMaintenance struct {
	// Day of week for installing updates
	Dow UpdateDBAASServiceRedisRequestMaintenanceDow `json:"dow" validate:"required"`
	// Time for installing updates, UTC
	Time string `json:"time" validate:"required,gte=8,lte=8"`
}

// Migrate data from existing server
type UpdateDBAASServiceRedisRequestMigration struct {
	// Database name for bootstrapping the initial connection
	Dbname string `json:"dbname,omitempty" validate:"omitempty,gte=1,lte=63"`
	// Hostname or IP address of the server where to migrate data from
	Host string `json:"host" validate:"required,gte=1,lte=255"`
	// Comma-separated list of databases, which should be ignored during migration (supported by MySQL only at the moment)
	IgnoreDbs string               `json:"ignore-dbs,omitempty" validate:"omitempty,gte=1,lte=2048"`
	Method    *EnumMigrationMethod `json:"method,omitempty"`
	// Password for authentication with the server where to migrate data from
	Password string `json:"password,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Port number of the server where to migrate data from
	Port int64 `json:"port" validate:"required,gte=1,lte=65535"`
	// The server where to migrate data from is secured with SSL
	SSL *bool `json:"ssl,omitempty"`
	// User name for authentication with the server where to migrate data from
	Username string `json:"username,omitempty" validate:"omitempty,gte=1,lte=255"`
}

type UpdateDBAASServiceRedisRequest struct {
	// Allow incoming connections from CIDR address block, e.g. '10.20.0.0/16'
	IPFilter []string `json:"ip-filter,omitempty"`
	// Automatic maintenance settings
	Maintenance *UpdateDBAASServiceRedisRequestMaintenance `json:"maintenance,omitempty"`
	// Migrate data from existing server
	Migration *UpdateDBAASServiceRedisRequestMigration `json:"migration,omitempty"`
	// Subscription plan
	Plan string `json:"plan,omitempty" validate:"omitempty,gte=1,lte=128"`
	// Redis settings
	RedisSettings *JSONSchemaRedis `json:"redis-settings,omitempty"`
	// Service is protected against termination and powering off
	TerminationProtection *bool `json:"termination-protection,omitempty"`
}

// Update a DBaaS Redis service
func (c ClientAPI) UpdateDBAASServiceRedis(ctx context.Context, name string, req UpdateDBAASServiceRedisRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-redis/%v", name)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceRedis: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceRedis: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceRedis: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceRedis: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateDBAASServiceRedis returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateDBAASServiceRedis: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Initiate Redis maintenance update
func (c ClientAPI) StartDBAASRedisMaintenance(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-redis/%v/maintenance/start", name)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASRedisMaintenance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("StartDBAASRedisMaintenance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("StartDBAASRedisMaintenance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request StartDBAASRedisMaintenance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("StartDBAASRedisMaintenance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Stop a DBaaS Redis migration
func (c ClientAPI) StopDBAASRedisMigration(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-redis/%v/migration/stop", name)

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("StopDBAASRedisMigration: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("StopDBAASRedisMigration: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("StopDBAASRedisMigration: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request StopDBAASRedisMigration returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("StopDBAASRedisMigration: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListDBAASServicesResponse struct {
	DBAASServices []DBAASServiceCommon `json:"dbaas-services,omitempty"`
}

// List DBaaS services
func (c ClientAPI) ListDBAASServices(ctx context.Context) (*ListDBAASServicesResponse, error) {
	path := "/dbaas-service"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListDBAASServices: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListDBAASServices: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListDBAASServices: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListDBAASServices returned %d code", resp.StatusCode)
	}

	bodyresp := &ListDBAASServicesResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListDBAASServices: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type GetDBAASServiceLogsRequest struct {
	// How many log entries to receive at most, up to 500 (default: 100)
	Limit int64 `json:"limit,omitempty" validate:"omitempty,gte=1,lte=500"`
	// Opaque offset identifier
	Offset    string         `json:"offset,omitempty"`
	SortOrder *EnumSortOrder `json:"sort-order,omitempty"`
}

// Get logs of DBaaS service
func (c ClientAPI) GetDBAASServiceLogs(ctx context.Context, serviceName string, req GetDBAASServiceLogsRequest) (*DBAASServiceLogs, error) {
	path := fmt.Sprintf("/dbaas-service-logs/%v", serviceName)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceLogs: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceLogs: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceLogs: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceLogs: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASServiceLogs returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASServiceLogs{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceLogs: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type GetDBAASServiceMetricsResponse struct {
	Metrics map[string]any `json:"metrics,omitempty"`
}

type GetDBAASServiceMetricsRequestPeriod string

const (
	GetDBAASServiceMetricsRequestPeriodHour  GetDBAASServiceMetricsRequestPeriod = "hour"
	GetDBAASServiceMetricsRequestPeriodWeek  GetDBAASServiceMetricsRequestPeriod = "week"
	GetDBAASServiceMetricsRequestPeriodYear  GetDBAASServiceMetricsRequestPeriod = "year"
	GetDBAASServiceMetricsRequestPeriodMonth GetDBAASServiceMetricsRequestPeriod = "month"
	GetDBAASServiceMetricsRequestPeriodDay   GetDBAASServiceMetricsRequestPeriod = "day"
)

type GetDBAASServiceMetricsRequest struct {
	// Metrics time period (default: hour)
	Period GetDBAASServiceMetricsRequestPeriod `json:"period,omitempty"`
}

// Get metrics of DBaaS service
func (c ClientAPI) GetDBAASServiceMetrics(ctx context.Context, serviceName string, req GetDBAASServiceMetricsRequest) (*GetDBAASServiceMetricsResponse, error) {
	path := fmt.Sprintf("/dbaas-service-metrics/%v", serviceName)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceMetrics: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceMetrics: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceMetrics: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceMetrics: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASServiceMetrics returned %d code", resp.StatusCode)
	}

	bodyresp := &GetDBAASServiceMetricsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceMetrics: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListDBAASServiceTypesResponse struct {
	DBAASServiceTypes []DBAASServiceType `json:"dbaas-service-types,omitempty"`
}

// List available service types for DBaaS
func (c ClientAPI) ListDBAASServiceTypes(ctx context.Context) (*ListDBAASServiceTypesResponse, error) {
	path := "/dbaas-service-type"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListDBAASServiceTypes: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListDBAASServiceTypes: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListDBAASServiceTypes: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListDBAASServiceTypes returned %d code", resp.StatusCode)
	}

	bodyresp := &ListDBAASServiceTypesResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListDBAASServiceTypes: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get a DBaaS service type
func (c ClientAPI) GetDBAASServiceType(ctx context.Context, serviceTypeName string) (*DBAASServiceType, error) {
	path := fmt.Sprintf("/dbaas-service-type/%v", serviceTypeName)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceType: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceType: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASServiceType: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASServiceType returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASServiceType{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASServiceType: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a DBaaS service
func (c ClientAPI) DeleteDBAASService(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-service/%v", name)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASService: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDBAASService: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDBAASService: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDBAASService returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDBAASService: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Grafana configuration values
type GetDBAASSettingsGrafanaResponseSettingsGrafana struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

type GetDBAASSettingsGrafanaResponseSettings struct {
	// Grafana configuration values
	Grafana *GetDBAASSettingsGrafanaResponseSettingsGrafana `json:"grafana,omitempty"`
}

type GetDBAASSettingsGrafanaResponse struct {
	Settings *GetDBAASSettingsGrafanaResponseSettings `json:"settings,omitempty"`
}

// Get DBaaS Grafana settings
func (c ClientAPI) GetDBAASSettingsGrafana(ctx context.Context) (*GetDBAASSettingsGrafanaResponse, error) {
	path := "/dbaas-settings-grafana"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsGrafana: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsGrafana: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsGrafana: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASSettingsGrafana returned %d code", resp.StatusCode)
	}

	bodyresp := &GetDBAASSettingsGrafanaResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsGrafana: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Kafka broker configuration values
type GetDBAASSettingsKafkaResponseSettingsKafka struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

// Kafka Connect configuration values
type GetDBAASSettingsKafkaResponseSettingsKafkaConnect struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

// Kafka REST configuration
type GetDBAASSettingsKafkaResponseSettingsKafkaRest struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

// Schema Registry configuration
type GetDBAASSettingsKafkaResponseSettingsSchemaRegistry struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

type GetDBAASSettingsKafkaResponseSettings struct {
	// Kafka broker configuration values
	Kafka *GetDBAASSettingsKafkaResponseSettingsKafka `json:"kafka,omitempty"`
	// Kafka Connect configuration values
	KafkaConnect *GetDBAASSettingsKafkaResponseSettingsKafkaConnect `json:"kafka-connect,omitempty"`
	// Kafka REST configuration
	KafkaRest *GetDBAASSettingsKafkaResponseSettingsKafkaRest `json:"kafka-rest,omitempty"`
	// Schema Registry configuration
	SchemaRegistry *GetDBAASSettingsKafkaResponseSettingsSchemaRegistry `json:"schema-registry,omitempty"`
}

type GetDBAASSettingsKafkaResponse struct {
	Settings *GetDBAASSettingsKafkaResponseSettings `json:"settings,omitempty"`
}

// Get DBaaS Kafka settings
func (c ClientAPI) GetDBAASSettingsKafka(ctx context.Context) (*GetDBAASSettingsKafkaResponse, error) {
	path := "/dbaas-settings-kafka"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsKafka: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsKafka: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsKafka: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASSettingsKafka returned %d code", resp.StatusCode)
	}

	bodyresp := &GetDBAASSettingsKafkaResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsKafka: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// mysql.conf configuration values
type GetDBAASSettingsMysqlResponseSettingsMysql struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

type GetDBAASSettingsMysqlResponseSettings struct {
	// mysql.conf configuration values
	Mysql *GetDBAASSettingsMysqlResponseSettingsMysql `json:"mysql,omitempty"`
}

type GetDBAASSettingsMysqlResponse struct {
	Settings *GetDBAASSettingsMysqlResponseSettings `json:"settings,omitempty"`
}

// Get DBaaS MySQL settings
func (c ClientAPI) GetDBAASSettingsMysql(ctx context.Context) (*GetDBAASSettingsMysqlResponse, error) {
	path := "/dbaas-settings-mysql"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsMysql: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsMysql: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsMysql: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASSettingsMysql returned %d code", resp.StatusCode)
	}

	bodyresp := &GetDBAASSettingsMysqlResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsMysql: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// OpenSearch configuration values
type GetDBAASSettingsOpensearchResponseSettingsOpensearch struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

type GetDBAASSettingsOpensearchResponseSettings struct {
	// OpenSearch configuration values
	Opensearch *GetDBAASSettingsOpensearchResponseSettingsOpensearch `json:"opensearch,omitempty"`
}

type GetDBAASSettingsOpensearchResponse struct {
	Settings *GetDBAASSettingsOpensearchResponseSettings `json:"settings,omitempty"`
}

// Get DBaaS OpenSearch settings
func (c ClientAPI) GetDBAASSettingsOpensearch(ctx context.Context) (*GetDBAASSettingsOpensearchResponse, error) {
	path := "/dbaas-settings-opensearch"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsOpensearch: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsOpensearch: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsOpensearch: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASSettingsOpensearch returned %d code", resp.StatusCode)
	}

	bodyresp := &GetDBAASSettingsOpensearchResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsOpensearch: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// postgresql.conf configuration values
type GetDBAASSettingsPGResponseSettingsPG struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

// PGBouncer connection pooling settings
type GetDBAASSettingsPGResponseSettingsPgbouncer struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

// PGLookout settings
type GetDBAASSettingsPGResponseSettingsPglookout struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

// TimescaleDB extension configuration values
type GetDBAASSettingsPGResponseSettingsTimescaledb struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

type GetDBAASSettingsPGResponseSettings struct {
	// postgresql.conf configuration values
	PG *GetDBAASSettingsPGResponseSettingsPG `json:"pg,omitempty"`
	// PGBouncer connection pooling settings
	Pgbouncer *GetDBAASSettingsPGResponseSettingsPgbouncer `json:"pgbouncer,omitempty"`
	// PGLookout settings
	Pglookout *GetDBAASSettingsPGResponseSettingsPglookout `json:"pglookout,omitempty"`
	// TimescaleDB extension configuration values
	Timescaledb *GetDBAASSettingsPGResponseSettingsTimescaledb `json:"timescaledb,omitempty"`
}

type GetDBAASSettingsPGResponse struct {
	Settings *GetDBAASSettingsPGResponseSettings `json:"settings,omitempty"`
}

// Get DBaaS PostgreSQL settings
func (c ClientAPI) GetDBAASSettingsPG(ctx context.Context) (*GetDBAASSettingsPGResponse, error) {
	path := "/dbaas-settings-pg"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsPG: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsPG: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsPG: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASSettingsPG returned %d code", resp.StatusCode)
	}

	bodyresp := &GetDBAASSettingsPGResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsPG: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Redis configuration values
type GetDBAASSettingsRedisResponseSettingsRedis struct {
	AdditionalProperties *bool          `json:"additionalProperties,omitempty"`
	Properties           map[string]any `json:"properties,omitempty"`
	Title                string         `json:"title,omitempty"`
	Type                 string         `json:"type,omitempty"`
}

type GetDBAASSettingsRedisResponseSettings struct {
	// Redis configuration values
	Redis *GetDBAASSettingsRedisResponseSettingsRedis `json:"redis,omitempty"`
}

type GetDBAASSettingsRedisResponse struct {
	Settings *GetDBAASSettingsRedisResponseSettings `json:"settings,omitempty"`
}

// Returns the default settings for Redis.
func (c ClientAPI) GetDBAASSettingsRedis(ctx context.Context) (*GetDBAASSettingsRedisResponse, error) {
	path := "/dbaas-settings-redis"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsRedis: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsRedis: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsRedis: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASSettingsRedis returned %d code", resp.StatusCode)
	}

	bodyresp := &GetDBAASSettingsRedisResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASSettingsRedis: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDBAASTaskMigrationCheckRequest struct {
	// Comma-separated list of databases, which should be ignored during migration (supported by MySQL only at the moment)
	IgnoreDbs string               `json:"ignore-dbs,omitempty" validate:"omitempty,gte=1,lte=2048"`
	Method    *EnumMigrationMethod `json:"method,omitempty"`
	// Service URI of the source MySQL or PostgreSQL database with admin credentials.
	SourceServiceURI string `json:"source-service-uri" validate:"required,gte=1,lte=512"`
}

// Create a DBaaS task to check migration
func (c ClientAPI) CreateDBAASTaskMigrationCheck(ctx context.Context, service string, req CreateDBAASTaskMigrationCheckRequest) (*Operation, error) {
	path := fmt.Sprintf("/dbaas-task-migration-check/%v", service)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASTaskMigrationCheck: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASTaskMigrationCheck: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDBAASTaskMigrationCheck: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDBAASTaskMigrationCheck: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDBAASTaskMigrationCheck returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDBAASTaskMigrationCheck: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Get a DBaaS task
func (c ClientAPI) GetDBAASTask(ctx context.Context, service string, id UUID) (*DBAASTask, error) {
	path := fmt.Sprintf("/dbaas-task/%v/%v", service, id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASTask: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDBAASTask: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDBAASTask: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDBAASTask returned %d code", resp.StatusCode)
	}

	bodyresp := &DBAASTask{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDBAASTask: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListDeployTargetsResponse struct {
	DeployTargets []DeployTarget `json:"deploy-targets,omitempty"`
}

// List Deploy Targets
func (c ClientAPI) ListDeployTargets(ctx context.Context) (*ListDeployTargetsResponse, error) {
	path := "/deploy-target"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListDeployTargets: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListDeployTargets: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListDeployTargets: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListDeployTargets returned %d code", resp.StatusCode)
	}

	bodyresp := &ListDeployTargetsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListDeployTargets: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Deploy Target details
func (c ClientAPI) GetDeployTarget(ctx context.Context, id UUID) (*DeployTarget, error) {
	path := fmt.Sprintf("/deploy-target/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDeployTarget: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDeployTarget: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDeployTarget: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDeployTarget returned %d code", resp.StatusCode)
	}

	bodyresp := &DeployTarget{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDeployTarget: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListDNSDomainsResponse struct {
	DNSDomains []DNSDomain `json:"dns-domains,omitempty"`
}

// List DNS domains
func (c ClientAPI) ListDNSDomains(ctx context.Context) (*ListDNSDomainsResponse, error) {
	path := "/dns-domain"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListDNSDomains: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListDNSDomains: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListDNSDomains: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListDNSDomains returned %d code", resp.StatusCode)
	}

	bodyresp := &ListDNSDomainsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListDNSDomains: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// DNS Domain
type CreateDNSDomainRequest struct {
	// Domain name
	UnicodeName string `json:"unicode-name,omitempty"`
}

// Create DNS domain
func (c ClientAPI) CreateDNSDomain(ctx context.Context, req CreateDNSDomainRequest) (*DNSDomain, error) {
	path := "/dns-domain"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDNSDomain: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDNSDomain: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDNSDomain: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDNSDomain: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDNSDomain returned %d code", resp.StatusCode)
	}

	bodyresp := &DNSDomain{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDNSDomain: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListDNSDomainRecordsResponse struct {
	DNSDomainRecords []DNSDomainRecord `json:"dns-domain-records,omitempty"`
}

// List DNS domain records
func (c ClientAPI) ListDNSDomainRecords(ctx context.Context, domainID UUID) (*ListDNSDomainRecordsResponse, error) {
	path := fmt.Sprintf("/dns-domain/%v/record", domainID)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListDNSDomainRecords: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListDNSDomainRecords: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListDNSDomainRecords: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListDNSDomainRecords returned %d code", resp.StatusCode)
	}

	bodyresp := &ListDNSDomainRecordsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListDNSDomainRecords: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateDNSDomainRecordRequestType string

const (
	CreateDNSDomainRecordRequestTypeNS    CreateDNSDomainRecordRequestType = "NS"
	CreateDNSDomainRecordRequestTypeCAA   CreateDNSDomainRecordRequestType = "CAA"
	CreateDNSDomainRecordRequestTypeNAPTR CreateDNSDomainRecordRequestType = "NAPTR"
	CreateDNSDomainRecordRequestTypePOOL  CreateDNSDomainRecordRequestType = "POOL"
	CreateDNSDomainRecordRequestTypeA     CreateDNSDomainRecordRequestType = "A"
	CreateDNSDomainRecordRequestTypeHINFO CreateDNSDomainRecordRequestType = "HINFO"
	CreateDNSDomainRecordRequestTypeCNAME CreateDNSDomainRecordRequestType = "CNAME"
	CreateDNSDomainRecordRequestTypeSSHFP CreateDNSDomainRecordRequestType = "SSHFP"
	CreateDNSDomainRecordRequestTypeSRV   CreateDNSDomainRecordRequestType = "SRV"
	CreateDNSDomainRecordRequestTypeAAAA  CreateDNSDomainRecordRequestType = "AAAA"
	CreateDNSDomainRecordRequestTypeMX    CreateDNSDomainRecordRequestType = "MX"
	CreateDNSDomainRecordRequestTypeTXT   CreateDNSDomainRecordRequestType = "TXT"
	CreateDNSDomainRecordRequestTypeALIAS CreateDNSDomainRecordRequestType = "ALIAS"
	CreateDNSDomainRecordRequestTypeURL   CreateDNSDomainRecordRequestType = "URL"
	CreateDNSDomainRecordRequestTypeSPF   CreateDNSDomainRecordRequestType = "SPF"
)

type CreateDNSDomainRecordRequest struct {
	// DNS domain record content
	Content string `json:"content" validate:"required"`
	// DNS domain record name
	Name string `json:"name" validate:"required"`
	// DNS domain record priority
	Priority int64 `json:"priority,omitempty" validate:"omitempty,gte=0"`
	// DNS domain record TTL
	Ttl int64 `json:"ttl,omitempty" validate:"omitempty,gte=0"`
	// DNS domain record type
	Type CreateDNSDomainRecordRequestType `json:"type" validate:"required"`
}

// Create DNS domain record
func (c ClientAPI) CreateDNSDomainRecord(ctx context.Context, domainID UUID, req CreateDNSDomainRecordRequest) (*Operation, error) {
	path := fmt.Sprintf("/dns-domain/%v/record", domainID)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateDNSDomainRecord: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateDNSDomainRecord: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateDNSDomainRecord: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateDNSDomainRecord: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateDNSDomainRecord returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateDNSDomainRecord: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete DNS domain record
func (c ClientAPI) DeleteDNSDomainRecord(ctx context.Context, domainID UUID, recordID UUID) (*Operation, error) {
	path := fmt.Sprintf("/dns-domain/%v/record/%v", domainID, recordID)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDNSDomainRecord: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDNSDomainRecord: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDNSDomainRecord: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDNSDomainRecord returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDNSDomainRecord: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve DNS domain record details
func (c ClientAPI) GetDNSDomainRecord(ctx context.Context, domainID UUID, recordID UUID) (*DNSDomainRecord, error) {
	path := fmt.Sprintf("/dns-domain/%v/record/%v", domainID, recordID)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDNSDomainRecord: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDNSDomainRecord: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDNSDomainRecord: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDNSDomainRecord returned %d code", resp.StatusCode)
	}

	bodyresp := &DNSDomainRecord{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDNSDomainRecord: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateDNSDomainRecordRequest struct {
	// DNS domain record content
	Content string `json:"content,omitempty"`
	// DNS domain record name
	Name string `json:"name,omitempty"`
	// DNS domain record priority
	Priority int64 `json:"priority,omitempty" validate:"omitempty,gt=0"`
	// DNS domain record TTL
	Ttl int64 `json:"ttl,omitempty" validate:"omitempty,gt=0"`
}

// Update DNS domain record
func (c ClientAPI) UpdateDNSDomainRecord(ctx context.Context, domainID UUID, recordID UUID, req UpdateDNSDomainRecordRequest) (*Operation, error) {
	path := fmt.Sprintf("/dns-domain/%v/record/%v", domainID, recordID)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateDNSDomainRecord: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateDNSDomainRecord: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateDNSDomainRecord: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateDNSDomainRecord: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateDNSDomainRecord returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateDNSDomainRecord: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete DNS Domain
func (c ClientAPI) DeleteDNSDomain(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/dns-domain/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteDNSDomain: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteDNSDomain: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteDNSDomain: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteDNSDomain returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteDNSDomain: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve DNS domain details
func (c ClientAPI) GetDNSDomain(ctx context.Context, id UUID) (*DNSDomain, error) {
	path := fmt.Sprintf("/dns-domain/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDNSDomain: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDNSDomain: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDNSDomain: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDNSDomain returned %d code", resp.StatusCode)
	}

	bodyresp := &DNSDomain{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDNSDomain: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type GetDNSDomainZoneFileResponse struct {
	ZoneFile string `json:"zone-file,omitempty"`
}

// Retrieve DNS domain zone file
func (c ClientAPI) GetDNSDomainZoneFile(ctx context.Context, id UUID) (*GetDNSDomainZoneFileResponse, error) {
	path := fmt.Sprintf("/dns-domain/%v/zone", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetDNSDomainZoneFile: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetDNSDomainZoneFile: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetDNSDomainZoneFile: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetDNSDomainZoneFile returned %d code", resp.StatusCode)
	}

	bodyresp := &GetDNSDomainZoneFileResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetDNSDomainZoneFile: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListElasticIPSResponse struct {
	ElasticIPS []ElasticIP `json:"elastic-ips,omitempty"`
}

// List Elastic IPs
func (c ClientAPI) ListElasticIPS(ctx context.Context) (*ListElasticIPSResponse, error) {
	path := "/elastic-ip"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListElasticIPS: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListElasticIPS: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListElasticIPS: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListElasticIPS returned %d code", resp.StatusCode)
	}

	bodyresp := &ListElasticIPSResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListElasticIPS: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateElasticIPRequestAddressfamily string

const (
	CreateElasticIPRequestAddressfamilyInet4 CreateElasticIPRequestAddressfamily = "inet4"
	CreateElasticIPRequestAddressfamilyInet6 CreateElasticIPRequestAddressfamily = "inet6"
)

type CreateElasticIPRequest struct {
	// Elastic IP address family (default: :inet4)
	Addressfamily CreateElasticIPRequestAddressfamily `json:"addressfamily,omitempty"`
	// Elastic IP description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Elastic IP address healthcheck
	Healthcheck *ElasticIPHealthcheck `json:"healthcheck,omitempty"`
	Labels      Labels                `json:"labels,omitempty"`
}

// Create an Elastic IP
func (c ClientAPI) CreateElasticIP(ctx context.Context, req CreateElasticIPRequest) (*Operation, error) {
	path := "/elastic-ip"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateElasticIP: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateElasticIP: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateElasticIP: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateElasticIP: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateElasticIP returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateElasticIP: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete an Elastic IP
func (c ClientAPI) DeleteElasticIP(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/elastic-ip/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteElasticIP: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteElasticIP: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteElasticIP: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteElasticIP returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteElasticIP: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Elastic IP details
func (c ClientAPI) GetElasticIP(ctx context.Context, id UUID) (*ElasticIP, error) {
	path := fmt.Sprintf("/elastic-ip/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetElasticIP: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetElasticIP: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetElasticIP: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetElasticIP returned %d code", resp.StatusCode)
	}

	bodyresp := &ElasticIP{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetElasticIP: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateElasticIPRequest struct {
	// Elastic IP description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Elastic IP address healthcheck
	Healthcheck *ElasticIPHealthcheck `json:"healthcheck,omitempty"`
	Labels      Labels                `json:"labels,omitempty"`
}

// Update an Elastic IP
func (c ClientAPI) UpdateElasticIP(ctx context.Context, id UUID, req UpdateElasticIPRequest) (*Operation, error) {
	path := fmt.Sprintf("/elastic-ip/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateElasticIP: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateElasticIP: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateElasticIP: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateElasticIP: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateElasticIP returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateElasticIP: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetElasticIPFieldField string

const (
	ResetElasticIPFieldFieldDescription ResetElasticIPFieldField = "description"
)

// Reset an Elastic IP field to its default value
func (c ClientAPI) ResetElasticIPField(ctx context.Context, id UUID, field ResetElasticIPFieldField) (*Operation, error) {
	path := fmt.Sprintf("/elastic-ip/%v/%v", id, field)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ResetElasticIPField: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetElasticIPField: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetElasticIPField: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetElasticIPField returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetElasticIPField: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type AttachInstanceToElasticIPRequest struct {
	// Target Instance
	Instance *InstanceTarget `json:"instance" validate:"required"`
}

// Attach a Compute instance to an Elastic IP
func (c ClientAPI) AttachInstanceToElasticIP(ctx context.Context, id UUID, req AttachInstanceToElasticIPRequest) (*Operation, error) {
	path := fmt.Sprintf("/elastic-ip/%v:attach", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("AttachInstanceToElasticIP: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("AttachInstanceToElasticIP: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("AttachInstanceToElasticIP: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("AttachInstanceToElasticIP: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request AttachInstanceToElasticIP returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("AttachInstanceToElasticIP: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type DetachInstanceFromElasticIPRequest struct {
	// Target Instance
	Instance *InstanceTarget `json:"instance" validate:"required"`
}

// Detach a Compute instance from an Elastic IP
func (c ClientAPI) DetachInstanceFromElasticIP(ctx context.Context, id UUID, req DetachInstanceFromElasticIPRequest) (*Operation, error) {
	path := fmt.Sprintf("/elastic-ip/%v:detach", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("DetachInstanceFromElasticIP: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("DetachInstanceFromElasticIP: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DetachInstanceFromElasticIP: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DetachInstanceFromElasticIP: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DetachInstanceFromElasticIP returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DetachInstanceFromElasticIP: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListEventsOpt func(url.Values)

func ListEventsWithFrom(from time.Time) ListEventsOpt {
	return func(q url.Values) {
		q.Add("from", fmt.Sprint(from))
	}
}

func ListEventsWithTo(to time.Time) ListEventsOpt {
	return func(q url.Values) {
		q.Add("to", fmt.Sprint(to))
	}
}

// Retrieve Mutation Events for a given date range. Defaults to retrieving Events for the past 24 hours.
// Both a `from` and `to` arguments can be specified to filter Events over a specific period.
// Events will be the the most descriptive possible but not all fields are mandatory
func (c ClientAPI) ListEvents(ctx context.Context, opts ...ListEventsOpt) ([]Event, error) {
	path := "/event"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListEvents: new request: %w", err)
	}

	if len(opts) > 0 {
		q := request.URL.Query()
		for _, opt := range opts {
			opt(q)
		}
		request.URL.RawQuery = q.Encode()
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListEvents: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListEvents: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListEvents returned %d code", resp.StatusCode)
	}

	bodyresp := []Event{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListEvents: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve IAM Organization Policy
func (c ClientAPI) GetIAMOrganizationPolicy(ctx context.Context) (*IAMPolicy, error) {
	path := "/iam-organization-policy"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetIAMOrganizationPolicy: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetIAMOrganizationPolicy: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetIAMOrganizationPolicy: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetIAMOrganizationPolicy returned %d code", resp.StatusCode)
	}

	bodyresp := &IAMPolicy{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetIAMOrganizationPolicy: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Update IAM Organization Policy
func (c ClientAPI) UpdateIAMOrganizationPolicy(ctx context.Context, req IAMPolicy) (*Operation, error) {
	path := "/iam-organization-policy"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateIAMOrganizationPolicy: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateIAMOrganizationPolicy: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateIAMOrganizationPolicy: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateIAMOrganizationPolicy: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateIAMOrganizationPolicy returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateIAMOrganizationPolicy: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListIAMRolesResponse struct {
	IAMRoles []IAMRole `json:"iam-roles,omitempty"`
}

// List IAM Roles
func (c ClientAPI) ListIAMRoles(ctx context.Context) (*ListIAMRolesResponse, error) {
	path := "/iam-role"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListIAMRoles: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListIAMRoles: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListIAMRoles: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListIAMRoles returned %d code", resp.StatusCode)
	}

	bodyresp := &ListIAMRolesResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListIAMRoles: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateIAMRoleRequest struct {
	// IAM Role description
	Description string `json:"description,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Sets if the IAM Role Policy is editable or not (default: true). This setting cannot be changed after creation
	Editable *bool  `json:"editable,omitempty"`
	Labels   Labels `json:"labels,omitempty"`
	// IAM Role name
	Name string `json:"name" validate:"required,gte=1,lte=191"`
	// IAM Role permissions
	Permissions []string `json:"permissions,omitempty"`
	// Policy
	Policy *IAMPolicy `json:"policy,omitempty"`
}

// Create IAM Role
func (c ClientAPI) CreateIAMRole(ctx context.Context, req CreateIAMRoleRequest) (*Operation, error) {
	path := "/iam-role"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateIAMRole: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateIAMRole: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateIAMRole: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateIAMRole: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateIAMRole returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateIAMRole: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete IAM Role
func (c ClientAPI) DeleteIAMRole(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/iam-role/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteIAMRole: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteIAMRole: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteIAMRole: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteIAMRole returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteIAMRole: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve IAM Role
func (c ClientAPI) GetIAMRole(ctx context.Context, id UUID) (*IAMRole, error) {
	path := fmt.Sprintf("/iam-role/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetIAMRole: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetIAMRole: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetIAMRole: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetIAMRole returned %d code", resp.StatusCode)
	}

	bodyresp := &IAMRole{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetIAMRole: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateIAMRoleRequest struct {
	// IAM Role description
	Description string `json:"description,omitempty" validate:"omitempty,gte=1,lte=255"`
	Labels      Labels `json:"labels,omitempty"`
	// IAM Role permissions
	Permissions []string `json:"permissions,omitempty"`
}

// Update IAM Role
func (c ClientAPI) UpdateIAMRole(ctx context.Context, id UUID, req UpdateIAMRoleRequest) (*Operation, error) {
	path := fmt.Sprintf("/iam-role/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateIAMRole: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateIAMRole: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateIAMRole: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateIAMRole: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateIAMRole returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateIAMRole: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Update IAM Role Policy
func (c ClientAPI) UpdateIAMRolePolicy(ctx context.Context, id UUID, req IAMPolicy) (*Operation, error) {
	path := fmt.Sprintf("/iam-role/%v:policy", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateIAMRolePolicy: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateIAMRolePolicy: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateIAMRolePolicy: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateIAMRolePolicy: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateIAMRolePolicy returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateIAMRolePolicy: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Instance
type ListInstancesResponseInstances struct {
	// Instance creation date
	CreatedAT time.Time `json:"created-at,omitempty"`
	// Instance ID
	ID UUID `json:"id,omitempty"`
	// Compute instance type
	InstanceType *InstanceType `json:"instance-type,omitempty"`
	// Instance IPv6 address
	Ipv6Address string `json:"ipv6-address,omitempty"`
	Labels      Labels `json:"labels,omitempty"`
	// Resource manager
	Manager *Manager `json:"manager,omitempty"`
	// Instance name
	Name string `json:"name,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Instance Private Networks
	PrivateNetworks []PrivateNetwork `json:"private-networks,omitempty"`
	// Instance public IPv4 address
	PublicIP           net.IP              `json:"public-ip,omitempty"`
	PublicIPAssignment *PublicIPAssignment `json:"public-ip-assignment,omitempty"`
	// Instance Security Groups
	SecurityGroups []SecurityGroup `json:"security-groups,omitempty"`
	// SSH key
	SSHKey *SSHKey `json:"ssh-key,omitempty"`
	// Instance SSH Keys
	SSHKeys []SSHKey       `json:"ssh-keys,omitempty"`
	State   *InstanceState `json:"state,omitempty"`
	// Instance template
	Template *Template `json:"template,omitempty"`
}

type ListInstancesResponse struct {
	Instances []ListInstancesResponseInstances `json:"instances,omitempty"`
}

type ListInstancesManagerType string

const (
	ListInstancesManagerTypeInstancePool ListInstancesManagerType = "instance-pool"
)

type ListInstancesOpt func(url.Values)

func ListInstancesWithManagerID(managerID UUID) ListInstancesOpt {
	return func(q url.Values) {
		q.Add("managerID", fmt.Sprint(managerID))
	}
}

func ListInstancesWithManagerType(managerType ListInstancesManagerType) ListInstancesOpt {
	return func(q url.Values) {
		q.Add("managerType", fmt.Sprint(managerType))
	}
}

func ListInstancesWithIPAddress(ipAddress string) ListInstancesOpt {
	return func(q url.Values) {
		q.Add("ipAddress", fmt.Sprint(ipAddress))
	}
}

// List Compute instances
func (c ClientAPI) ListInstances(ctx context.Context, opts ...ListInstancesOpt) (*ListInstancesResponse, error) {
	path := "/instance"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListInstances: new request: %w", err)
	}

	if len(opts) > 0 {
		q := request.URL.Query()
		for _, opt := range opts {
			opt(q)
		}
		request.URL.RawQuery = q.Encode()
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListInstances: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListInstances: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListInstances returned %d code", resp.StatusCode)
	}

	bodyresp := &ListInstancesResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListInstances: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateInstanceRequest struct {
	// Instance Anti-affinity Groups
	AntiAffinityGroups []AntiAffinityGroup `json:"anti-affinity-groups,omitempty"`
	// Start Instance on creation (default: true)
	AutoStart *bool `json:"auto-start,omitempty"`
	// Deploy target
	DeployTarget *DeployTarget `json:"deploy-target,omitempty"`
	// Instance disk size in GB
	DiskSize int64 `json:"disk-size" validate:"required,gte=10,lte=50000"`
	// Compute instance type
	InstanceType *InstanceType `json:"instance-type" validate:"required"`
	// Enable IPv6. DEPRECATED: use `public-ip-assignments`.
	Ipv6Enabled *bool  `json:"ipv6-enabled,omitempty"`
	Labels      Labels `json:"labels,omitempty"`
	// Instance name
	Name               string              `json:"name,omitempty" validate:"omitempty,gte=1,lte=255"`
	PublicIPAssignment *PublicIPAssignment `json:"public-ip-assignment,omitempty"`
	// Instance Security Groups
	SecurityGroups []SecurityGroup `json:"security-groups,omitempty"`
	// SSH key
	SSHKey *SSHKey `json:"ssh-key,omitempty"`
	// Instance SSH Keys
	SSHKeys []SSHKey `json:"ssh-keys,omitempty"`
	// Instance template
	Template *Template `json:"template" validate:"required"`
	// Instance Cloud-init user-data
	UserData string `json:"user-data,omitempty" validate:"omitempty,gte=1,lte=32768"`
}

// Create a Compute instance
func (c ClientAPI) CreateInstance(ctx context.Context, req CreateInstanceRequest) (*Operation, error) {
	path := "/instance"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateInstance: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateInstance: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListInstancePoolsResponse struct {
	InstancePools []InstancePool `json:"instance-pools,omitempty"`
}

// List Instance Pools
func (c ClientAPI) ListInstancePools(ctx context.Context) (*ListInstancePoolsResponse, error) {
	path := "/instance-pool"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListInstancePools: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListInstancePools: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListInstancePools: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListInstancePools returned %d code", resp.StatusCode)
	}

	bodyresp := &ListInstancePoolsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListInstancePools: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateInstancePoolRequest struct {
	// Instance Pool Anti-affinity Groups
	AntiAffinityGroups []AntiAffinityGroup `json:"anti-affinity-groups,omitempty"`
	// Deploy target
	DeployTarget *DeployTarget `json:"deploy-target,omitempty"`
	// Instance Pool description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Instances disk size in GB
	DiskSize int64 `json:"disk-size" validate:"required,gte=10,lte=50000"`
	// Instances Elastic IPs
	ElasticIPS []ElasticIP `json:"elastic-ips,omitempty"`
	// Prefix to apply to Instances names (default: pool)
	InstancePrefix string `json:"instance-prefix,omitempty" validate:"omitempty,gte=1,lte=30"`
	// Compute instance type
	InstanceType *InstanceType `json:"instance-type" validate:"required"`
	// Enable IPv6. DEPRECATED: use `public-ip-assignments`.
	Ipv6Enabled *bool  `json:"ipv6-enabled,omitempty"`
	Labels      Labels `json:"labels,omitempty"`
	// Minimum number of running Instances
	MinAvailable int64 `json:"min-available,omitempty" validate:"omitempty,gte=0"`
	// Instance Pool name
	Name string `json:"name" validate:"required,gte=1,lte=255"`
	// Instance Pool Private Networks
	PrivateNetworks    []PrivateNetwork    `json:"private-networks,omitempty"`
	PublicIPAssignment *PublicIPAssignment `json:"public-ip-assignment,omitempty"`
	// Instance Pool Security Groups
	SecurityGroups []SecurityGroup `json:"security-groups,omitempty"`
	// Number of Instances
	Size int64 `json:"size" validate:"required,gt=0"`
	// SSH key
	SSHKey *SSHKey `json:"ssh-key,omitempty"`
	// Instances SSH Keys
	SSHKeys []SSHKey `json:"ssh-keys,omitempty"`
	// Instance template
	Template *Template `json:"template" validate:"required"`
	// Instances Cloud-init user-data
	UserData string `json:"user-data,omitempty" validate:"omitempty,gte=1"`
}

// Create an Instance Pool
func (c ClientAPI) CreateInstancePool(ctx context.Context, req CreateInstancePoolRequest) (*Operation, error) {
	path := "/instance-pool"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateInstancePool: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateInstancePool: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateInstancePool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateInstancePool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateInstancePool returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateInstancePool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete an Instance Pool
func (c ClientAPI) DeleteInstancePool(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/instance-pool/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteInstancePool: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteInstancePool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteInstancePool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteInstancePool returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteInstancePool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Instance Pool details
func (c ClientAPI) GetInstancePool(ctx context.Context, id UUID) (*InstancePool, error) {
	path := fmt.Sprintf("/instance-pool/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetInstancePool: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetInstancePool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetInstancePool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetInstancePool returned %d code", resp.StatusCode)
	}

	bodyresp := &InstancePool{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetInstancePool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateInstancePoolRequest struct {
	// Instance Pool Anti-affinity Groups
	AntiAffinityGroups []AntiAffinityGroup `json:"anti-affinity-groups,omitempty"`
	// Deploy target
	DeployTarget *DeployTarget `json:"deploy-target,omitempty"`
	// Instance Pool description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Instances disk size in GB
	DiskSize int64 `json:"disk-size,omitempty" validate:"omitempty,gte=10,lte=50000"`
	// Instances Elastic IPs
	ElasticIPS []ElasticIP `json:"elastic-ips,omitempty"`
	// Prefix to apply to Instances names (default: pool)
	InstancePrefix string `json:"instance-prefix,omitempty"`
	// Compute instance type
	InstanceType *InstanceType `json:"instance-type,omitempty"`
	// Enable IPv6. DEPRECATED: use `public-ip-assignments`.
	Ipv6Enabled *bool  `json:"ipv6-enabled,omitempty"`
	Labels      Labels `json:"labels,omitempty"`
	// Minimum number of running Instances
	MinAvailable int64 `json:"min-available,omitempty" validate:"omitempty,gte=0"`
	// Instance Pool name
	Name string `json:"name,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Instance Pool Private Networks
	PrivateNetworks    []PrivateNetwork    `json:"private-networks,omitempty"`
	PublicIPAssignment *PublicIPAssignment `json:"public-ip-assignment,omitempty"`
	// Instance Pool Security Groups
	SecurityGroups []SecurityGroup `json:"security-groups,omitempty"`
	// SSH key
	SSHKey *SSHKey `json:"ssh-key,omitempty"`
	// Instances SSH keys
	SSHKeys []SSHKey `json:"ssh-keys,omitempty"`
	// Instance template
	Template *Template `json:"template,omitempty"`
	// Instances Cloud-init user-data
	UserData string `json:"user-data,omitempty" validate:"omitempty,gte=1"`
}

// Update an Instance Pool
func (c ClientAPI) UpdateInstancePool(ctx context.Context, id UUID, req UpdateInstancePoolRequest) (*Operation, error) {
	path := fmt.Sprintf("/instance-pool/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateInstancePool: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateInstancePool: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateInstancePool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateInstancePool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateInstancePool returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateInstancePool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetInstancePoolFieldField string

const (
	ResetInstancePoolFieldFieldAntiAffinityGroups ResetInstancePoolFieldField = "anti-affinity-groups"
	ResetInstancePoolFieldFieldDescription        ResetInstancePoolFieldField = "description"
	ResetInstancePoolFieldFieldLabels             ResetInstancePoolFieldField = "labels"
	ResetInstancePoolFieldFieldSecurityGroups     ResetInstancePoolFieldField = "security-groups"
	ResetInstancePoolFieldFieldElasticIPS         ResetInstancePoolFieldField = "elastic-ips"
	ResetInstancePoolFieldFieldPrivateNetworks    ResetInstancePoolFieldField = "private-networks"
	ResetInstancePoolFieldFieldSSHKey             ResetInstancePoolFieldField = "ssh-key"
	ResetInstancePoolFieldFieldUserData           ResetInstancePoolFieldField = "user-data"
	ResetInstancePoolFieldFieldDeployTarget       ResetInstancePoolFieldField = "deploy-target"
	ResetInstancePoolFieldFieldIpv6Enabled        ResetInstancePoolFieldField = "ipv6-enabled"
)

// Reset an Instance Pool field to its default value
func (c ClientAPI) ResetInstancePoolField(ctx context.Context, id UUID, field ResetInstancePoolFieldField) (*Operation, error) {
	path := fmt.Sprintf("/instance-pool/%v/%v", id, field)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ResetInstancePoolField: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetInstancePoolField: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetInstancePoolField: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetInstancePoolField returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetInstancePoolField: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type EvictInstancePoolMembersRequest struct {
	Instances []UUID `json:"instances,omitempty"`
}

// This operation evicts the specified Compute instances member from the Instance Pool, shrinking it to `&lt;current pool size&gt; - &lt;# evicted members&gt;`.
func (c ClientAPI) EvictInstancePoolMembers(ctx context.Context, id UUID, req EvictInstancePoolMembersRequest) (*Operation, error) {
	path := fmt.Sprintf("/instance-pool/%v:evict", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("EvictInstancePoolMembers: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("EvictInstancePoolMembers: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("EvictInstancePoolMembers: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("EvictInstancePoolMembers: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request EvictInstancePoolMembers returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("EvictInstancePoolMembers: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ScaleInstancePoolRequest struct {
	// Number of managed Instances
	Size int64 `json:"size" validate:"required,gt=0"`
}

// Scale an Instance Pool
func (c ClientAPI) ScaleInstancePool(ctx context.Context, id UUID, req ScaleInstancePoolRequest) (*Operation, error) {
	path := fmt.Sprintf("/instance-pool/%v:scale", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("ScaleInstancePool: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("ScaleInstancePool: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ScaleInstancePool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ScaleInstancePool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ScaleInstancePool returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ScaleInstancePool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListInstanceTypesResponse struct {
	InstanceTypes []InstanceType `json:"instance-types,omitempty"`
}

// List Compute instance Types
func (c ClientAPI) ListInstanceTypes(ctx context.Context) (*ListInstanceTypesResponse, error) {
	path := "/instance-type"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListInstanceTypes: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListInstanceTypes: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListInstanceTypes: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListInstanceTypes returned %d code", resp.StatusCode)
	}

	bodyresp := &ListInstanceTypesResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListInstanceTypes: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Instance Type details
func (c ClientAPI) GetInstanceType(ctx context.Context, id UUID) (*InstanceType, error) {
	path := fmt.Sprintf("/instance-type/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetInstanceType: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetInstanceType: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetInstanceType: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetInstanceType returned %d code", resp.StatusCode)
	}

	bodyresp := &InstanceType{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetInstanceType: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Compute instance
func (c ClientAPI) DeleteInstance(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteInstance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Compute instance details
func (c ClientAPI) GetInstance(ctx context.Context, id UUID) (*Instance, error) {
	path := fmt.Sprintf("/instance/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetInstance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &Instance{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateInstanceRequest struct {
	Labels Labels `json:"labels,omitempty"`
	// Instance name
	Name               string              `json:"name,omitempty" validate:"omitempty,gte=1,lte=255"`
	PublicIPAssignment *PublicIPAssignment `json:"public-ip-assignment,omitempty"`
	// Instance Cloud-init user-data
	UserData string `json:"user-data,omitempty" validate:"omitempty,gte=1,lte=32768"`
}

// Update a Compute instance
func (c ClientAPI) UpdateInstance(ctx context.Context, id UUID, req UpdateInstanceRequest) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateInstance: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateInstance: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetInstanceFieldField string

const (
	ResetInstanceFieldFieldLabels ResetInstanceFieldField = "labels"
)

// Reset Instance field
func (c ClientAPI) ResetInstanceField(ctx context.Context, id UUID, field ResetInstanceFieldField) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v/%v", id, field)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ResetInstanceField: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetInstanceField: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetInstanceField: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetInstanceField returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetInstanceField: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type AddInstanceProtectionResponse struct {
}

// Set instance destruction protection
func (c ClientAPI) AddInstanceProtection(ctx context.Context, id UUID) (*AddInstanceProtectionResponse, error) {
	path := fmt.Sprintf("/instance/%v:add-protection", id)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("AddInstanceProtection: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("AddInstanceProtection: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("AddInstanceProtection: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request AddInstanceProtection returned %d code", resp.StatusCode)
	}

	bodyresp := &AddInstanceProtectionResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("AddInstanceProtection: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Create a Snapshot of a Compute instance
func (c ClientAPI) CreateSnapshot(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v:create-snapshot", id)

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("CreateSnapshot: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateSnapshot: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateSnapshot: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateSnapshot returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateSnapshot: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Reveal the password used during instance creation or the latest password reset.
// This is only available for VMs created against templates having the `password-enabled`
// property set to `true`.
// creation or resets.
// creation or resets.
func (c ClientAPI) RevealInstancePassword(ctx context.Context, id UUID) (*InstancePassword, error) {
	path := fmt.Sprintf("/instance/%v:password", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("RevealInstancePassword: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("RevealInstancePassword: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("RevealInstancePassword: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request RevealInstancePassword returned %d code", resp.StatusCode)
	}

	bodyresp := &InstancePassword{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("RevealInstancePassword: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Reboot a Compute instance
func (c ClientAPI) RebootInstance(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v:reboot", id)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("RebootInstance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("RebootInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("RebootInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request RebootInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("RebootInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type RemoveInstanceProtectionResponse struct {
}

// Remove instance destruction protection
func (c ClientAPI) RemoveInstanceProtection(ctx context.Context, id UUID) (*RemoveInstanceProtectionResponse, error) {
	path := fmt.Sprintf("/instance/%v:remove-protection", id)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("RemoveInstanceProtection: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("RemoveInstanceProtection: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("RemoveInstanceProtection: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request RemoveInstanceProtection returned %d code", resp.StatusCode)
	}

	bodyresp := &RemoveInstanceProtectionResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("RemoveInstanceProtection: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetInstanceRequest struct {
	// Instance disk size in GB
	DiskSize int64 `json:"disk-size,omitempty" validate:"omitempty,gte=10,lte=50000"`
	// Instance template
	Template *Template `json:"template,omitempty"`
}

// This operation re-installs a Compute instance to a base template. If target template is provided it will be used to recreated instance from. Warning: the operation wipes all data stored on the disk.
func (c ClientAPI) ResetInstance(ctx context.Context, id UUID, req ResetInstanceRequest) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v:reset", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("ResetInstance: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("ResetInstance: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Reset a compute instance password
func (c ClientAPI) ResetInstancePassword(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v:reset-password", id)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ResetInstancePassword: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetInstancePassword: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetInstancePassword: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetInstancePassword returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetInstancePassword: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResizeInstanceDiskRequest struct {
	// Instance disk size in GB
	DiskSize int64 `json:"disk-size" validate:"required,gte=10,lte=50000"`
}

// This operation resizes a Compute instance's disk volume. Note: the disk can only grow, cannot be shrunk.
func (c ClientAPI) ResizeInstanceDisk(ctx context.Context, id UUID, req ResizeInstanceDiskRequest) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v:resize-disk", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("ResizeInstanceDisk: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("ResizeInstanceDisk: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResizeInstanceDisk: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResizeInstanceDisk: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResizeInstanceDisk returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResizeInstanceDisk: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ScaleInstanceRequest struct {
	// Compute instance type
	InstanceType *InstanceType `json:"instance-type" validate:"required"`
}

// This operation changes the Compute instance's type. Note: the new Instance Type must be within the same family (e.g. a standard instance cannot be scaled to gpu2 or storage).
func (c ClientAPI) ScaleInstance(ctx context.Context, id UUID, req ScaleInstanceRequest) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v:scale", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("ScaleInstance: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("ScaleInstance: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ScaleInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ScaleInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ScaleInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ScaleInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type StartInstanceRequestRescueProfile string

const (
	StartInstanceRequestRescueProfileNetbootEfi StartInstanceRequestRescueProfile = "netboot-efi"
	StartInstanceRequestRescueProfileNetboot    StartInstanceRequestRescueProfile = "netboot"
)

type StartInstanceRequest struct {
	// Boot in Rescue Mode, using named profile (supported: netboot, netboot-efi)
	RescueProfile StartInstanceRequestRescueProfile `json:"rescue-profile,omitempty"`
}

// This operation starts a virtual machine, potentially using a rescue profile if specified
func (c ClientAPI) StartInstance(ctx context.Context, id UUID, req StartInstanceRequest) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v:start", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("StartInstance: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("StartInstance: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("StartInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("StartInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request StartInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("StartInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Stop a Compute instance
func (c ClientAPI) StopInstance(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v:stop", id)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("StopInstance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("StopInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("StopInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request StopInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("StopInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type RevertInstanceToSnapshotRequest struct {
	// Snapshot ID
	ID UUID `json:"id" validate:"required"`
}

// This operation reverts the snapshot to the Compute instance volume, restoring stored data as it was at the time of the snapshot.
// The Compute instance must be previously stopped.
func (c ClientAPI) RevertInstanceToSnapshot(ctx context.Context, instanceID UUID, req RevertInstanceToSnapshotRequest) (*Operation, error) {
	path := fmt.Sprintf("/instance/%v:revert-snapshot", instanceID)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("RevertInstanceToSnapshot: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("RevertInstanceToSnapshot: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("RevertInstanceToSnapshot: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("RevertInstanceToSnapshot: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request RevertInstanceToSnapshot returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("RevertInstanceToSnapshot: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListLoadBalancersResponse struct {
	LoadBalancers []LoadBalancer `json:"load-balancers,omitempty"`
}

// List Load Balancers
func (c ClientAPI) ListLoadBalancers(ctx context.Context) (*ListLoadBalancersResponse, error) {
	path := "/load-balancer"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListLoadBalancers: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListLoadBalancers: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListLoadBalancers: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListLoadBalancers returned %d code", resp.StatusCode)
	}

	bodyresp := &ListLoadBalancersResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListLoadBalancers: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateLoadBalancerRequest struct {
	// Load Balancer description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	Labels      Labels `json:"labels,omitempty"`
	// Load Balancer name
	Name string `json:"name" validate:"required,gte=1,lte=255"`
}

// Create a Load Balancer
func (c ClientAPI) CreateLoadBalancer(ctx context.Context, req CreateLoadBalancerRequest) (*Operation, error) {
	path := "/load-balancer"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateLoadBalancer: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateLoadBalancer: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateLoadBalancer: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateLoadBalancer: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateLoadBalancer returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateLoadBalancer: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Load Balancer
func (c ClientAPI) DeleteLoadBalancer(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/load-balancer/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteLoadBalancer: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteLoadBalancer: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteLoadBalancer: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteLoadBalancer returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteLoadBalancer: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Load Balancer details
func (c ClientAPI) GetLoadBalancer(ctx context.Context, id UUID) (*LoadBalancer, error) {
	path := fmt.Sprintf("/load-balancer/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetLoadBalancer: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetLoadBalancer: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetLoadBalancer: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetLoadBalancer returned %d code", resp.StatusCode)
	}

	bodyresp := &LoadBalancer{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetLoadBalancer: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateLoadBalancerRequest struct {
	// Load Balancer description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	Labels      Labels `json:"labels,omitempty"`
	// Load Balancer name
	Name string `json:"name,omitempty" validate:"omitempty,gte=1,lte=255"`
}

// Update a Load Balancer
func (c ClientAPI) UpdateLoadBalancer(ctx context.Context, id UUID, req UpdateLoadBalancerRequest) (*Operation, error) {
	path := fmt.Sprintf("/load-balancer/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateLoadBalancer: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateLoadBalancer: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateLoadBalancer: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateLoadBalancer: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateLoadBalancer returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateLoadBalancer: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type AddServiceToLoadBalancerRequestProtocol string

const (
	AddServiceToLoadBalancerRequestProtocolTCP AddServiceToLoadBalancerRequestProtocol = "tcp"
	AddServiceToLoadBalancerRequestProtocolUDP AddServiceToLoadBalancerRequestProtocol = "udp"
)

type AddServiceToLoadBalancerRequestStrategy string

const (
	AddServiceToLoadBalancerRequestStrategyRoundRobin AddServiceToLoadBalancerRequestStrategy = "round-robin"
	AddServiceToLoadBalancerRequestStrategySourceHash AddServiceToLoadBalancerRequestStrategy = "source-hash"
)

type AddServiceToLoadBalancerRequest struct {
	// Load Balancer Service description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Load Balancer Service healthcheck
	Healthcheck *LoadBalancerServiceHealthcheck `json:"healthcheck" validate:"required"`
	// Instance Pool
	InstancePool *InstancePool `json:"instance-pool" validate:"required"`
	// Load Balancer Service name
	Name string `json:"name" validate:"required,gte=1,lte=255"`
	// Port exposed on the Load Balancer's public IP
	Port int64 `json:"port" validate:"required,gte=1,lte=65535"`
	// Network traffic protocol
	Protocol AddServiceToLoadBalancerRequestProtocol `json:"protocol" validate:"required"`
	// Load balancing strategy
	Strategy AddServiceToLoadBalancerRequestStrategy `json:"strategy" validate:"required"`
	// Port on which the network traffic will be forwarded to on the receiving instance
	TargetPort int64 `json:"target-port" validate:"required,gte=1,lte=65535"`
}

// Add a Load Balancer Service
func (c ClientAPI) AddServiceToLoadBalancer(ctx context.Context, id UUID, req AddServiceToLoadBalancerRequest) (*Operation, error) {
	path := fmt.Sprintf("/load-balancer/%v/service", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("AddServiceToLoadBalancer: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("AddServiceToLoadBalancer: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("AddServiceToLoadBalancer: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("AddServiceToLoadBalancer: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request AddServiceToLoadBalancer returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("AddServiceToLoadBalancer: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Load Balancer Service
func (c ClientAPI) DeleteLoadBalancerService(ctx context.Context, id UUID, serviceID UUID) (*Operation, error) {
	path := fmt.Sprintf("/load-balancer/%v/service/%v", id, serviceID)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteLoadBalancerService: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteLoadBalancerService: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteLoadBalancerService: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteLoadBalancerService returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteLoadBalancerService: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Load Balancer Service details
func (c ClientAPI) GetLoadBalancerService(ctx context.Context, id UUID, serviceID UUID) (*LoadBalancerService, error) {
	path := fmt.Sprintf("/load-balancer/%v/service/%v", id, serviceID)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetLoadBalancerService: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetLoadBalancerService: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetLoadBalancerService: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetLoadBalancerService returned %d code", resp.StatusCode)
	}

	bodyresp := &LoadBalancerService{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetLoadBalancerService: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateLoadBalancerServiceRequestProtocol string

const (
	UpdateLoadBalancerServiceRequestProtocolTCP UpdateLoadBalancerServiceRequestProtocol = "tcp"
	UpdateLoadBalancerServiceRequestProtocolUDP UpdateLoadBalancerServiceRequestProtocol = "udp"
)

type UpdateLoadBalancerServiceRequestStrategy string

const (
	UpdateLoadBalancerServiceRequestStrategyRoundRobin UpdateLoadBalancerServiceRequestStrategy = "round-robin"
	UpdateLoadBalancerServiceRequestStrategySourceHash UpdateLoadBalancerServiceRequestStrategy = "source-hash"
)

type UpdateLoadBalancerServiceRequest struct {
	// Load Balancer Service description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Load Balancer Service healthcheck
	Healthcheck *LoadBalancerServiceHealthcheck `json:"healthcheck,omitempty"`
	// Load Balancer Service name
	Name string `json:"name,omitempty" validate:"omitempty,lte=255"`
	// Port exposed on the Load Balancer's public IP
	Port int64 `json:"port,omitempty" validate:"omitempty,gte=1,lte=65535"`
	// Network traffic protocol
	Protocol UpdateLoadBalancerServiceRequestProtocol `json:"protocol,omitempty"`
	// Load balancing strategy
	Strategy UpdateLoadBalancerServiceRequestStrategy `json:"strategy,omitempty"`
	// Port on which the network traffic will be forwarded to on the receiving instance
	TargetPort int64 `json:"target-port,omitempty" validate:"omitempty,gte=1,lte=65535"`
}

// Update a Load Balancer Service
func (c ClientAPI) UpdateLoadBalancerService(ctx context.Context, id UUID, serviceID UUID, req UpdateLoadBalancerServiceRequest) (*Operation, error) {
	path := fmt.Sprintf("/load-balancer/%v/service/%v", id, serviceID)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateLoadBalancerService: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateLoadBalancerService: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateLoadBalancerService: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateLoadBalancerService: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateLoadBalancerService returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateLoadBalancerService: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetLoadBalancerServiceFieldField string

const (
	ResetLoadBalancerServiceFieldFieldDescription ResetLoadBalancerServiceFieldField = "description"
)

// Reset a Load Balancer Service field to its default value
func (c ClientAPI) ResetLoadBalancerServiceField(ctx context.Context, id UUID, serviceID UUID, field ResetLoadBalancerServiceFieldField) (*Operation, error) {
	path := fmt.Sprintf("/load-balancer/%v/service/%v/%v", id, serviceID, field)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ResetLoadBalancerServiceField: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetLoadBalancerServiceField: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetLoadBalancerServiceField: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetLoadBalancerServiceField returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetLoadBalancerServiceField: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetLoadBalancerFieldField string

const (
	ResetLoadBalancerFieldFieldDescription ResetLoadBalancerFieldField = "description"
	ResetLoadBalancerFieldFieldLabels      ResetLoadBalancerFieldField = "labels"
)

// Reset a Load Balancer field to its default value
func (c ClientAPI) ResetLoadBalancerField(ctx context.Context, id UUID, field ResetLoadBalancerFieldField) (*Operation, error) {
	path := fmt.Sprintf("/load-balancer/%v/%v", id, field)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ResetLoadBalancerField: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetLoadBalancerField: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetLoadBalancerField: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetLoadBalancerField returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetLoadBalancerField: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Operation details
func (c ClientAPI) GetOperation(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/operation/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetOperation: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetOperation: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetOperation: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetOperation returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetOperation: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListPrivateNetworksResponse struct {
	PrivateNetworks []PrivateNetwork `json:"private-networks,omitempty"`
}

// List Private Networks
func (c ClientAPI) ListPrivateNetworks(ctx context.Context) (*ListPrivateNetworksResponse, error) {
	path := "/private-network"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListPrivateNetworks: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListPrivateNetworks: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListPrivateNetworks: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListPrivateNetworks returned %d code", resp.StatusCode)
	}

	bodyresp := &ListPrivateNetworksResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListPrivateNetworks: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreatePrivateNetworkRequest struct {
	// Private Network description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Private Network end IP address
	EndIP  net.IP `json:"end-ip,omitempty"`
	Labels Labels `json:"labels,omitempty"`
	// Private Network name
	Name string `json:"name" validate:"required,gte=1,lte=255"`
	// Private Network netmask
	Netmask net.IP `json:"netmask,omitempty"`
	// Private Network start IP address
	StartIP net.IP `json:"start-ip,omitempty"`
}

// Create a Private Network
func (c ClientAPI) CreatePrivateNetwork(ctx context.Context, req CreatePrivateNetworkRequest) (*Operation, error) {
	path := "/private-network"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreatePrivateNetwork: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreatePrivateNetwork: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreatePrivateNetwork: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreatePrivateNetwork: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreatePrivateNetwork returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreatePrivateNetwork: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Private Network
func (c ClientAPI) DeletePrivateNetwork(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/private-network/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeletePrivateNetwork: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeletePrivateNetwork: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeletePrivateNetwork: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeletePrivateNetwork returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeletePrivateNetwork: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Private Network details
func (c ClientAPI) GetPrivateNetwork(ctx context.Context, id UUID) (*PrivateNetwork, error) {
	path := fmt.Sprintf("/private-network/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetPrivateNetwork: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetPrivateNetwork: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetPrivateNetwork: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetPrivateNetwork returned %d code", resp.StatusCode)
	}

	bodyresp := &PrivateNetwork{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetPrivateNetwork: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdatePrivateNetworkRequest struct {
	// Private Network description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Private Network end IP address
	EndIP  net.IP `json:"end-ip,omitempty"`
	Labels Labels `json:"labels,omitempty"`
	// Private Network name
	Name string `json:"name,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Private Network netmask
	Netmask net.IP `json:"netmask,omitempty"`
	// Private Network start IP address
	StartIP net.IP `json:"start-ip,omitempty"`
}

// Update a Private Network
func (c ClientAPI) UpdatePrivateNetwork(ctx context.Context, id UUID, req UpdatePrivateNetworkRequest) (*Operation, error) {
	path := fmt.Sprintf("/private-network/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdatePrivateNetwork: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdatePrivateNetwork: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdatePrivateNetwork: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdatePrivateNetwork: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdatePrivateNetwork returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdatePrivateNetwork: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetPrivateNetworkFieldField string

const (
	ResetPrivateNetworkFieldFieldLabels ResetPrivateNetworkFieldField = "labels"
)

// Reset Private Network field
func (c ClientAPI) ResetPrivateNetworkField(ctx context.Context, id UUID, field ResetPrivateNetworkFieldField) (*Operation, error) {
	path := fmt.Sprintf("/private-network/%v/%v", id, field)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ResetPrivateNetworkField: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetPrivateNetworkField: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetPrivateNetworkField: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetPrivateNetworkField returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetPrivateNetworkField: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Compute instance
type AttachInstanceToPrivateNetworkRequestInstance struct {
	// Instance ID
	ID UUID `json:"id,omitempty"`
}

type AttachInstanceToPrivateNetworkRequest struct {
	// Compute instance
	Instance *AttachInstanceToPrivateNetworkRequestInstance `json:"instance" validate:"required"`
	// Static IP address lease for the corresponding network interface
	IP net.IP `json:"ip,omitempty"`
}

// Attach a Compute instance to a Private Network
func (c ClientAPI) AttachInstanceToPrivateNetwork(ctx context.Context, id UUID, req AttachInstanceToPrivateNetworkRequest) (*Operation, error) {
	path := fmt.Sprintf("/private-network/%v:attach", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("AttachInstanceToPrivateNetwork: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("AttachInstanceToPrivateNetwork: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("AttachInstanceToPrivateNetwork: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("AttachInstanceToPrivateNetwork: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request AttachInstanceToPrivateNetwork returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("AttachInstanceToPrivateNetwork: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type DetachInstanceFromPrivateNetworkRequest struct {
	// Instance
	Instance *Instance `json:"instance" validate:"required"`
}

// Detach a Compute instance from a Private Network
func (c ClientAPI) DetachInstanceFromPrivateNetwork(ctx context.Context, id UUID, req DetachInstanceFromPrivateNetworkRequest) (*Operation, error) {
	path := fmt.Sprintf("/private-network/%v:detach", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("DetachInstanceFromPrivateNetwork: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("DetachInstanceFromPrivateNetwork: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DetachInstanceFromPrivateNetwork: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DetachInstanceFromPrivateNetwork: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DetachInstanceFromPrivateNetwork returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DetachInstanceFromPrivateNetwork: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdatePrivateNetworkInstanceIPRequestInstance struct {
	// Instance ID
	ID UUID `json:"id" validate:"required"`
}

type UpdatePrivateNetworkInstanceIPRequest struct {
	Instance *UpdatePrivateNetworkInstanceIPRequestInstance `json:"instance,omitempty"`
	// Static IP address lease for the corresponding network interface
	IP net.IP `json:"ip,omitempty"`
}

// Update the IP address of an instance attached to a managed private network
func (c ClientAPI) UpdatePrivateNetworkInstanceIP(ctx context.Context, id UUID, req UpdatePrivateNetworkInstanceIPRequest) (*Operation, error) {
	path := fmt.Sprintf("/private-network/%v:update-ip", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdatePrivateNetworkInstanceIP: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdatePrivateNetworkInstanceIP: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdatePrivateNetworkInstanceIP: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdatePrivateNetworkInstanceIP: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdatePrivateNetworkInstanceIP returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdatePrivateNetworkInstanceIP: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListQuotasResponse struct {
	Quotas []Quota `json:"quotas,omitempty"`
}

// List Organization Quotas
func (c ClientAPI) ListQuotas(ctx context.Context) (*ListQuotasResponse, error) {
	path := "/quota"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListQuotas: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListQuotas: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListQuotas: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListQuotas returned %d code", resp.StatusCode)
	}

	bodyresp := &ListQuotasResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListQuotas: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Resource Quota
func (c ClientAPI) GetQuota(ctx context.Context, entity string) (*Quota, error) {
	path := fmt.Sprintf("/quota/%v", entity)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetQuota: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetQuota: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetQuota: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetQuota returned %d code", resp.StatusCode)
	}

	bodyresp := &Quota{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetQuota: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete the PTR DNS record for an elastic IP
func (c ClientAPI) DeleteReverseDNSElasticIP(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/reverse-dns/elastic-ip/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteReverseDNSElasticIP: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteReverseDNSElasticIP: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteReverseDNSElasticIP: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteReverseDNSElasticIP returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteReverseDNSElasticIP: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Query the PTR DNS records for an elastic IP
func (c ClientAPI) GetReverseDNSElasticIP(ctx context.Context, id UUID) (*ReverseDNSRecord, error) {
	path := fmt.Sprintf("/reverse-dns/elastic-ip/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetReverseDNSElasticIP: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetReverseDNSElasticIP: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetReverseDNSElasticIP: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetReverseDNSElasticIP returned %d code", resp.StatusCode)
	}

	bodyresp := &ReverseDNSRecord{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetReverseDNSElasticIP: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateReverseDNSElasticIPRequest struct {
	DomainName string `json:"domain-name,omitempty" validate:"omitempty,gte=1,lte=253"`
}

// Update/Create the PTR DNS record for an elastic IP
func (c ClientAPI) UpdateReverseDNSElasticIP(ctx context.Context, id UUID, req UpdateReverseDNSElasticIPRequest) (*Operation, error) {
	path := fmt.Sprintf("/reverse-dns/elastic-ip/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateReverseDNSElasticIP: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateReverseDNSElasticIP: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateReverseDNSElasticIP: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateReverseDNSElasticIP: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateReverseDNSElasticIP returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateReverseDNSElasticIP: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete the PTR DNS record for an instance
func (c ClientAPI) DeleteReverseDNSInstance(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/reverse-dns/instance/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteReverseDNSInstance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteReverseDNSInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteReverseDNSInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteReverseDNSInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteReverseDNSInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Query the PTR DNS records for an instance
func (c ClientAPI) GetReverseDNSInstance(ctx context.Context, id UUID) (*ReverseDNSRecord, error) {
	path := fmt.Sprintf("/reverse-dns/instance/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetReverseDNSInstance: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetReverseDNSInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetReverseDNSInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetReverseDNSInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &ReverseDNSRecord{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetReverseDNSInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateReverseDNSInstanceRequest struct {
	DomainName string `json:"domain-name,omitempty" validate:"omitempty,gte=1,lte=253"`
}

// Update/Create the PTR DNS record for an instance
func (c ClientAPI) UpdateReverseDNSInstance(ctx context.Context, id UUID, req UpdateReverseDNSInstanceRequest) (*Operation, error) {
	path := fmt.Sprintf("/reverse-dns/instance/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateReverseDNSInstance: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateReverseDNSInstance: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateReverseDNSInstance: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateReverseDNSInstance: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateReverseDNSInstance returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateReverseDNSInstance: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListSecurityGroupsResponse struct {
	SecurityGroups []SecurityGroup `json:"security-groups,omitempty"`
}

type ListSecurityGroupsVisibility string

const (
	ListSecurityGroupsVisibilityPrivate ListSecurityGroupsVisibility = "private"
	ListSecurityGroupsVisibilityPublic  ListSecurityGroupsVisibility = "public"
)

type ListSecurityGroupsOpt func(url.Values)

func ListSecurityGroupsWithVisibility(visibility ListSecurityGroupsVisibility) ListSecurityGroupsOpt {
	return func(q url.Values) {
		q.Add("visibility", fmt.Sprint(visibility))
	}
}

// Lists security groups. When visibility is set to public, lists public security groups.
// Public security groups are objects maintained by Exoscale which contain source addresses for
// relevant services hosted by Exoscale. They can be used a source in ingress rules and as a destination
// in egress rules.
func (c ClientAPI) ListSecurityGroups(ctx context.Context, opts ...ListSecurityGroupsOpt) (*ListSecurityGroupsResponse, error) {
	path := "/security-group"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListSecurityGroups: new request: %w", err)
	}

	if len(opts) > 0 {
		q := request.URL.Query()
		for _, opt := range opts {
			opt(q)
		}
		request.URL.RawQuery = q.Encode()
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListSecurityGroups: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListSecurityGroups: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListSecurityGroups returned %d code", resp.StatusCode)
	}

	bodyresp := &ListSecurityGroupsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListSecurityGroups: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateSecurityGroupRequest struct {
	// Security Group description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Security Group name
	Name string `json:"name" validate:"required,gte=1,lte=255"`
}

// Create a Security Group
func (c ClientAPI) CreateSecurityGroup(ctx context.Context, req CreateSecurityGroupRequest) (*Operation, error) {
	path := "/security-group"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateSecurityGroup: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateSecurityGroup: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateSecurityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateSecurityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateSecurityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateSecurityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Security Group
func (c ClientAPI) DeleteSecurityGroup(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/security-group/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteSecurityGroup: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteSecurityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteSecurityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteSecurityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteSecurityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Security Group details
func (c ClientAPI) GetSecurityGroup(ctx context.Context, id UUID) (*SecurityGroup, error) {
	path := fmt.Sprintf("/security-group/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetSecurityGroup: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetSecurityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetSecurityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetSecurityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &SecurityGroup{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetSecurityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type AddRuleToSecurityGroupRequestFlowDirection string

const (
	AddRuleToSecurityGroupRequestFlowDirectionIngress AddRuleToSecurityGroupRequestFlowDirection = "ingress"
	AddRuleToSecurityGroupRequestFlowDirectionEgress  AddRuleToSecurityGroupRequestFlowDirection = "egress"
)

// ICMP details (default: -1 (ANY))
type AddRuleToSecurityGroupRequestICMP struct {
	Code int64 `json:"code,omitempty" validate:"omitempty,gte=-1,lte=254"`
	Type int64 `json:"type,omitempty" validate:"omitempty,gte=-1,lte=254"`
}

type AddRuleToSecurityGroupRequestProtocol string

const (
	AddRuleToSecurityGroupRequestProtocolTCP    AddRuleToSecurityGroupRequestProtocol = "tcp"
	AddRuleToSecurityGroupRequestProtocolEsp    AddRuleToSecurityGroupRequestProtocol = "esp"
	AddRuleToSecurityGroupRequestProtocolICMP   AddRuleToSecurityGroupRequestProtocol = "icmp"
	AddRuleToSecurityGroupRequestProtocolUDP    AddRuleToSecurityGroupRequestProtocol = "udp"
	AddRuleToSecurityGroupRequestProtocolGre    AddRuleToSecurityGroupRequestProtocol = "gre"
	AddRuleToSecurityGroupRequestProtocolAh     AddRuleToSecurityGroupRequestProtocol = "ah"
	AddRuleToSecurityGroupRequestProtocolIpip   AddRuleToSecurityGroupRequestProtocol = "ipip"
	AddRuleToSecurityGroupRequestProtocolIcmpv6 AddRuleToSecurityGroupRequestProtocol = "icmpv6"
)

type AddRuleToSecurityGroupRequest struct {
	// Security Group rule description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// End port of the range
	EndPort int64 `json:"end-port,omitempty" validate:"omitempty,gte=1,lte=65535"`
	// Network flow direction to match
	FlowDirection AddRuleToSecurityGroupRequestFlowDirection `json:"flow-direction" validate:"required"`
	// ICMP details (default: -1 (ANY))
	ICMP *AddRuleToSecurityGroupRequestICMP `json:"icmp,omitempty"`
	// CIDR-formatted network allowed
	Network string `json:"network,omitempty"`
	// Network protocol
	Protocol AddRuleToSecurityGroupRequestProtocol `json:"protocol" validate:"required"`
	// Security Group
	SecurityGroup *SecurityGroupResource `json:"security-group,omitempty"`
	// Start port of the range
	StartPort int64 `json:"start-port,omitempty" validate:"omitempty,gte=1,lte=65535"`
}

// Create a Security Group rule
func (c ClientAPI) AddRuleToSecurityGroup(ctx context.Context, id UUID, req AddRuleToSecurityGroupRequest) (*Operation, error) {
	path := fmt.Sprintf("/security-group/%v/rules", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("AddRuleToSecurityGroup: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("AddRuleToSecurityGroup: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("AddRuleToSecurityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("AddRuleToSecurityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request AddRuleToSecurityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("AddRuleToSecurityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Security Group rule
func (c ClientAPI) DeleteRuleFromSecurityGroup(ctx context.Context, id UUID, ruleID UUID) (*Operation, error) {
	path := fmt.Sprintf("/security-group/%v/rules/%v", id, ruleID)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteRuleFromSecurityGroup: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteRuleFromSecurityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteRuleFromSecurityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteRuleFromSecurityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteRuleFromSecurityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type AddExternalSourceToSecurityGroupRequest struct {
	// CIDR-formatted network to add
	Cidr string `json:"cidr" validate:"required"`
}

// Add an external source as a member of a Security Group
func (c ClientAPI) AddExternalSourceToSecurityGroup(ctx context.Context, id UUID, req AddExternalSourceToSecurityGroupRequest) (*Operation, error) {
	path := fmt.Sprintf("/security-group/%v:add-source", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("AddExternalSourceToSecurityGroup: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("AddExternalSourceToSecurityGroup: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("AddExternalSourceToSecurityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("AddExternalSourceToSecurityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request AddExternalSourceToSecurityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("AddExternalSourceToSecurityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type AttachInstanceToSecurityGroupRequest struct {
	// Instance
	Instance *Instance `json:"instance" validate:"required"`
}

// Attach a Compute instance to a Security Group
func (c ClientAPI) AttachInstanceToSecurityGroup(ctx context.Context, id UUID, req AttachInstanceToSecurityGroupRequest) (*Operation, error) {
	path := fmt.Sprintf("/security-group/%v:attach", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("AttachInstanceToSecurityGroup: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("AttachInstanceToSecurityGroup: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("AttachInstanceToSecurityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("AttachInstanceToSecurityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request AttachInstanceToSecurityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("AttachInstanceToSecurityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type DetachInstanceFromSecurityGroupRequest struct {
	// Instance
	Instance *Instance `json:"instance" validate:"required"`
}

// Detach a Compute instance from a Security Group
func (c ClientAPI) DetachInstanceFromSecurityGroup(ctx context.Context, id UUID, req DetachInstanceFromSecurityGroupRequest) (*Operation, error) {
	path := fmt.Sprintf("/security-group/%v:detach", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("DetachInstanceFromSecurityGroup: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("DetachInstanceFromSecurityGroup: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DetachInstanceFromSecurityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DetachInstanceFromSecurityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DetachInstanceFromSecurityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DetachInstanceFromSecurityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type RemoveExternalSourceFromSecurityGroupRequest struct {
	// CIDR-formatted network to remove
	Cidr string `json:"cidr" validate:"required"`
}

// Remove an external source from a Security Group
func (c ClientAPI) RemoveExternalSourceFromSecurityGroup(ctx context.Context, id UUID, req RemoveExternalSourceFromSecurityGroupRequest) (*Operation, error) {
	path := fmt.Sprintf("/security-group/%v:remove-source", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("RemoveExternalSourceFromSecurityGroup: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("RemoveExternalSourceFromSecurityGroup: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("RemoveExternalSourceFromSecurityGroup: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("RemoveExternalSourceFromSecurityGroup: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request RemoveExternalSourceFromSecurityGroup returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("RemoveExternalSourceFromSecurityGroup: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListSKSClustersResponse struct {
	SKSClusters []SKSCluster `json:"sks-clusters,omitempty"`
}

// List SKS clusters
func (c ClientAPI) ListSKSClusters(ctx context.Context) (*ListSKSClustersResponse, error) {
	path := "/sks-cluster"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListSKSClusters: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListSKSClusters: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListSKSClusters: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListSKSClusters returned %d code", resp.StatusCode)
	}

	bodyresp := &ListSKSClustersResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListSKSClusters: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateSKSClusterRequestCni string

const (
	CreateSKSClusterRequestCniCalico CreateSKSClusterRequestCni = "calico"
	CreateSKSClusterRequestCniCilium CreateSKSClusterRequestCni = "cilium"
)

type CreateSKSClusterRequestLevel string

const (
	CreateSKSClusterRequestLevelStarter CreateSKSClusterRequestLevel = "starter"
	CreateSKSClusterRequestLevelPro     CreateSKSClusterRequestLevel = "pro"
)

type CreateSKSClusterRequest struct {
	// Cluster addons
	Addons []string `json:"addons,omitempty"`
	// Enable auto upgrade of the control plane to the latest patch version available
	AutoUpgrade *bool `json:"auto-upgrade,omitempty"`
	// Cluster CNI
	Cni CreateSKSClusterRequestCni `json:"cni,omitempty"`
	// Cluster description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	Labels      Labels `json:"labels,omitempty"`
	// Cluster service level
	Level CreateSKSClusterRequestLevel `json:"level" validate:"required"`
	// Cluster name
	Name string `json:"name" validate:"required,gte=1,lte=255"`
	// SKS Cluster OpenID config map
	Oidc *SKSOidc `json:"oidc,omitempty"`
	// Control plane Kubernetes version
	Version string `json:"version" validate:"required"`
}

// Create an SKS cluster
func (c ClientAPI) CreateSKSCluster(ctx context.Context, req CreateSKSClusterRequest) (*Operation, error) {
	path := "/sks-cluster"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateSKSCluster: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateSKSCluster: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateSKSCluster: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateSKSCluster: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateSKSCluster returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateSKSCluster: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// This operation returns the deprecated resources for a given cluster
func (c ClientAPI) ListSKSClusterDeprecatedResources(ctx context.Context, id UUID) ([]SKSClusterDeprecatedResource, error) {
	path := fmt.Sprintf("/sks-cluster-deprecated-resources/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListSKSClusterDeprecatedResources: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListSKSClusterDeprecatedResources: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListSKSClusterDeprecatedResources: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListSKSClusterDeprecatedResources returned %d code", resp.StatusCode)
	}

	bodyresp := []SKSClusterDeprecatedResource{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListSKSClusterDeprecatedResources: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type GenerateSKSClusterKubeconfigResponse struct {
	Kubeconfig string `json:"kubeconfig,omitempty"`
}

// This operation returns a Kubeconfig file encoded in base64.
func (c ClientAPI) GenerateSKSClusterKubeconfig(ctx context.Context, id UUID, req SKSKubeconfigRequest) (*GenerateSKSClusterKubeconfigResponse, error) {
	path := fmt.Sprintf("/sks-cluster-kubeconfig/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("GenerateSKSClusterKubeconfig: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("GenerateSKSClusterKubeconfig: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GenerateSKSClusterKubeconfig: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GenerateSKSClusterKubeconfig: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GenerateSKSClusterKubeconfig returned %d code", resp.StatusCode)
	}

	bodyresp := &GenerateSKSClusterKubeconfigResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GenerateSKSClusterKubeconfig: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListSKSClusterVersionsResponse struct {
	SKSClusterVersions []string `json:"sks-cluster-versions,omitempty"`
}

type ListSKSClusterVersionsOpt func(url.Values)

func ListSKSClusterVersionsWithIncludeDeprecated(includeDeprecated string) ListSKSClusterVersionsOpt {
	return func(q url.Values) {
		q.Add("includeDeprecated", fmt.Sprint(includeDeprecated))
	}
}

// List available versions for SKS clusters
func (c ClientAPI) ListSKSClusterVersions(ctx context.Context, opts ...ListSKSClusterVersionsOpt) (*ListSKSClusterVersionsResponse, error) {
	path := "/sks-cluster-version"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListSKSClusterVersions: new request: %w", err)
	}

	if len(opts) > 0 {
		q := request.URL.Query()
		for _, opt := range opts {
			opt(q)
		}
		request.URL.RawQuery = q.Encode()
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListSKSClusterVersions: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListSKSClusterVersions: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListSKSClusterVersions returned %d code", resp.StatusCode)
	}

	bodyresp := &ListSKSClusterVersionsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListSKSClusterVersions: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete an SKS cluster
func (c ClientAPI) DeleteSKSCluster(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteSKSCluster: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteSKSCluster: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteSKSCluster: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteSKSCluster returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteSKSCluster: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve SKS cluster details
func (c ClientAPI) GetSKSCluster(ctx context.Context, id UUID) (*SKSCluster, error) {
	path := fmt.Sprintf("/sks-cluster/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetSKSCluster: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetSKSCluster: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetSKSCluster: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetSKSCluster returned %d code", resp.StatusCode)
	}

	bodyresp := &SKSCluster{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetSKSCluster: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateSKSClusterRequest struct {
	// Cluster addons
	Addons []string `json:"addons,omitempty"`
	// Enable auto upgrade of the control plane to the latest patch version available
	AutoUpgrade *bool `json:"auto-upgrade,omitempty"`
	// Cluster description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	Labels      Labels `json:"labels,omitempty"`
	// Cluster name
	Name string `json:"name,omitempty" validate:"omitempty,gte=1,lte=255"`
	// SKS Cluster OpenID config map
	Oidc *SKSOidc `json:"oidc,omitempty"`
}

// Update an SKS cluster
func (c ClientAPI) UpdateSKSCluster(ctx context.Context, id UUID, req UpdateSKSClusterRequest) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateSKSCluster: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateSKSCluster: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateSKSCluster: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateSKSCluster: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateSKSCluster returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateSKSCluster: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type GetSKSClusterAuthorityCertResponse struct {
	Cacert string `json:"cacert,omitempty"`
}

type GetSKSClusterAuthorityCertAuthority string

const (
	GetSKSClusterAuthorityCertAuthorityControlPlane GetSKSClusterAuthorityCertAuthority = "control-plane"
	GetSKSClusterAuthorityCertAuthorityAggregation  GetSKSClusterAuthorityCertAuthority = "aggregation"
	GetSKSClusterAuthorityCertAuthorityKubelet      GetSKSClusterAuthorityCertAuthority = "kubelet"
)

// This operation returns the certificate for the given SKS cluster authority encoded in base64.
func (c ClientAPI) GetSKSClusterAuthorityCert(ctx context.Context, id UUID, authority GetSKSClusterAuthorityCertAuthority) (*GetSKSClusterAuthorityCertResponse, error) {
	path := fmt.Sprintf("/sks-cluster/%v/authority/%v/cert", id, authority)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetSKSClusterAuthorityCert: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetSKSClusterAuthorityCert: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetSKSClusterAuthorityCert: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetSKSClusterAuthorityCert returned %d code", resp.StatusCode)
	}

	bodyresp := &GetSKSClusterAuthorityCertResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetSKSClusterAuthorityCert: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type GetSKSClusterInspectionResponse map[string]any

// Helps troubleshoot common problems when deploying a kubernetes cluster. Inspections run every couple of minutes.
func (c ClientAPI) GetSKSClusterInspection(ctx context.Context, id UUID) (*GetSKSClusterInspectionResponse, error) {
	path := fmt.Sprintf("/sks-cluster/%v/inspection", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetSKSClusterInspection: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetSKSClusterInspection: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetSKSClusterInspection: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetSKSClusterInspection returned %d code", resp.StatusCode)
	}

	bodyresp := &GetSKSClusterInspectionResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetSKSClusterInspection: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CreateSKSNodepoolRequest struct {
	// Nodepool addons
	Addons []string `json:"addons,omitempty"`
	// Nodepool Anti-affinity Groups
	AntiAffinityGroups []AntiAffinityGroup `json:"anti-affinity-groups,omitempty"`
	// Deploy target
	DeployTarget *DeployTarget `json:"deploy-target,omitempty"`
	// Nodepool description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Nodepool instances disk size in GB
	DiskSize int64 `json:"disk-size" validate:"required,gte=20,lte=50000"`
	// Prefix to apply to instances names (default: pool)
	InstancePrefix string `json:"instance-prefix,omitempty" validate:"omitempty,gte=1,lte=30"`
	// Compute instance type
	InstanceType *InstanceType `json:"instance-type" validate:"required"`
	// Kubelet image GC options
	KubeletImageGC *KubeletImageGC `json:"kubelet-image-gc,omitempty"`
	Labels         Labels          `json:"labels,omitempty"`
	// Nodepool name
	Name string `json:"name" validate:"required,gte=1,lte=255"`
	// Nodepool Private Networks
	PrivateNetworks []PrivateNetwork `json:"private-networks,omitempty"`
	// Nodepool Security Groups
	SecurityGroups []SecurityGroup `json:"security-groups,omitempty"`
	// Number of instances
	Size   int64             `json:"size" validate:"required,gt=0"`
	Taints SKSNodepoolTaints `json:"taints,omitempty"`
}

// Create a new SKS Nodepool
func (c ClientAPI) CreateSKSNodepool(ctx context.Context, id UUID, req CreateSKSNodepoolRequest) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v/nodepool", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CreateSKSNodepool: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CreateSKSNodepool: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CreateSKSNodepool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CreateSKSNodepool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CreateSKSNodepool returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CreateSKSNodepool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete an SKS Nodepool
func (c ClientAPI) DeleteSKSNodepool(ctx context.Context, id UUID, sksNodepoolID UUID) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v/nodepool/%v", id, sksNodepoolID)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteSKSNodepool: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteSKSNodepool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteSKSNodepool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteSKSNodepool returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteSKSNodepool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve SKS Nodepool details
func (c ClientAPI) GetSKSNodepool(ctx context.Context, id UUID, sksNodepoolID UUID) (*SKSNodepool, error) {
	path := fmt.Sprintf("/sks-cluster/%v/nodepool/%v", id, sksNodepoolID)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetSKSNodepool: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetSKSNodepool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetSKSNodepool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetSKSNodepool returned %d code", resp.StatusCode)
	}

	bodyresp := &SKSNodepool{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetSKSNodepool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateSKSNodepoolRequest struct {
	// Nodepool Anti-affinity Groups
	AntiAffinityGroups []AntiAffinityGroup `json:"anti-affinity-groups,omitempty"`
	// Deploy target
	DeployTarget *DeployTarget `json:"deploy-target,omitempty"`
	// Nodepool description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Nodepool instances disk size in GB
	DiskSize int64 `json:"disk-size,omitempty" validate:"omitempty,gte=20,lte=50000"`
	// Prefix to apply to managed instances names (default: pool)
	InstancePrefix string `json:"instance-prefix,omitempty" validate:"omitempty,gte=1,lte=30"`
	// Compute instance type
	InstanceType *InstanceType `json:"instance-type,omitempty"`
	Labels       Labels        `json:"labels,omitempty"`
	// Nodepool name
	Name string `json:"name,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Nodepool Private Networks
	PrivateNetworks []PrivateNetwork `json:"private-networks,omitempty"`
	// Nodepool Security Groups
	SecurityGroups []SecurityGroup   `json:"security-groups,omitempty"`
	Taints         SKSNodepoolTaints `json:"taints,omitempty"`
}

// Update an SKS Nodepool
func (c ClientAPI) UpdateSKSNodepool(ctx context.Context, id UUID, sksNodepoolID UUID, req UpdateSKSNodepoolRequest) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v/nodepool/%v", id, sksNodepoolID)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateSKSNodepool: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateSKSNodepool: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateSKSNodepool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateSKSNodepool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateSKSNodepool returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateSKSNodepool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetSKSNodepoolFieldField string

const (
	ResetSKSNodepoolFieldFieldAntiAffinityGroups ResetSKSNodepoolFieldField = "anti-affinity-groups"
	ResetSKSNodepoolFieldFieldDescription        ResetSKSNodepoolFieldField = "description"
	ResetSKSNodepoolFieldFieldLabels             ResetSKSNodepoolFieldField = "labels"
	ResetSKSNodepoolFieldFieldSecurityGroups     ResetSKSNodepoolFieldField = "security-groups"
	ResetSKSNodepoolFieldFieldPrivateNetworks    ResetSKSNodepoolFieldField = "private-networks"
	ResetSKSNodepoolFieldFieldDeployTarget       ResetSKSNodepoolFieldField = "deploy-target"
)

// Reset an SKS Nodepool field to its default value
func (c ClientAPI) ResetSKSNodepoolField(ctx context.Context, id UUID, sksNodepoolID UUID, field ResetSKSNodepoolFieldField) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v/nodepool/%v/%v", id, sksNodepoolID, field)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ResetSKSNodepoolField: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetSKSNodepoolField: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetSKSNodepoolField: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetSKSNodepoolField returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetSKSNodepoolField: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type EvictSKSNodepoolMembersRequest struct {
	Instances []UUID `json:"instances,omitempty"`
}

// This operation evicts the specified Compute instances member from the Nodepool, shrinking it to `&lt;current nodepool size&gt; - &lt;# evicted members&gt;`.
func (c ClientAPI) EvictSKSNodepoolMembers(ctx context.Context, id UUID, sksNodepoolID UUID, req EvictSKSNodepoolMembersRequest) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v/nodepool/%v:evict", id, sksNodepoolID)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("EvictSKSNodepoolMembers: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("EvictSKSNodepoolMembers: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("EvictSKSNodepoolMembers: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("EvictSKSNodepoolMembers: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request EvictSKSNodepoolMembers returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("EvictSKSNodepoolMembers: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ScaleSKSNodepoolRequest struct {
	// Number of instances
	Size int64 `json:"size" validate:"required,gt=0"`
}

// Scale a SKS Nodepool
func (c ClientAPI) ScaleSKSNodepool(ctx context.Context, id UUID, sksNodepoolID UUID, req ScaleSKSNodepoolRequest) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v/nodepool/%v:scale", id, sksNodepoolID)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("ScaleSKSNodepool: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("ScaleSKSNodepool: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ScaleSKSNodepool: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ScaleSKSNodepool: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ScaleSKSNodepool returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ScaleSKSNodepool: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Rotate Exoscale CCM credentials
func (c ClientAPI) RotateSKSCcmCredentials(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v/rotate-ccm-credentials", id)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("RotateSKSCcmCredentials: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("RotateSKSCcmCredentials: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("RotateSKSCcmCredentials: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request RotateSKSCcmCredentials returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("RotateSKSCcmCredentials: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Rotate operators certificate authority
func (c ClientAPI) RotateSKSOperatorsCA(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v/rotate-operators-ca", id)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("RotateSKSOperatorsCA: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("RotateSKSOperatorsCA: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("RotateSKSOperatorsCA: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request RotateSKSOperatorsCA returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("RotateSKSOperatorsCA: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpgradeSKSClusterRequest struct {
	// Control plane Kubernetes version
	Version string `json:"version" validate:"required"`
}

// Upgrade an SKS cluster
func (c ClientAPI) UpgradeSKSCluster(ctx context.Context, id UUID, req UpgradeSKSClusterRequest) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v/upgrade", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpgradeSKSCluster: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpgradeSKSCluster: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpgradeSKSCluster: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpgradeSKSCluster: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpgradeSKSCluster returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpgradeSKSCluster: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Upgrade a SKS cluster to pro
func (c ClientAPI) UpgradeSKSClusterServiceLevel(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v/upgrade-service-level", id)

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("UpgradeSKSClusterServiceLevel: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpgradeSKSClusterServiceLevel: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpgradeSKSClusterServiceLevel: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpgradeSKSClusterServiceLevel returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpgradeSKSClusterServiceLevel: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ResetSKSClusterFieldField string

const (
	ResetSKSClusterFieldFieldDescription ResetSKSClusterFieldField = "description"
	ResetSKSClusterFieldFieldLabels      ResetSKSClusterFieldField = "labels"
)

// Reset an SKS cluster field to its default value
func (c ClientAPI) ResetSKSClusterField(ctx context.Context, id UUID, field ResetSKSClusterFieldField) (*Operation, error) {
	path := fmt.Sprintf("/sks-cluster/%v/%v", id, field)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ResetSKSClusterField: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ResetSKSClusterField: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ResetSKSClusterField: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ResetSKSClusterField returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ResetSKSClusterField: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListSnapshotsResponse struct {
	Snapshots []Snapshot `json:"snapshots,omitempty"`
}

// List Snapshots
func (c ClientAPI) ListSnapshots(ctx context.Context) (*ListSnapshotsResponse, error) {
	path := "/snapshot"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListSnapshots: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListSnapshots: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListSnapshots: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListSnapshots returned %d code", resp.StatusCode)
	}

	bodyresp := &ListSnapshotsResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListSnapshots: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Snapshot
func (c ClientAPI) DeleteSnapshot(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/snapshot/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteSnapshot: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteSnapshot: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteSnapshot: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteSnapshot returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteSnapshot: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Snapshot details
func (c ClientAPI) GetSnapshot(ctx context.Context, id UUID) (*Snapshot, error) {
	path := fmt.Sprintf("/snapshot/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetSnapshot: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetSnapshot: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetSnapshot: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetSnapshot returned %d code", resp.StatusCode)
	}

	bodyresp := &Snapshot{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetSnapshot: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Export a Snapshot
func (c ClientAPI) ExportSnapshot(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/snapshot/%v:export", id)

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ExportSnapshot: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ExportSnapshot: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ExportSnapshot: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ExportSnapshot returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ExportSnapshot: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type PromoteSnapshotToTemplateRequest struct {
	// Template default user
	DefaultUser string `json:"default-user,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Template description
	Description string `json:"description,omitempty" validate:"omitempty,lte=4096"`
	// Template name
	Name string `json:"name" validate:"required,gte=1,lte=255"`
	// Enable password-based login in the template
	PasswordEnabled *bool `json:"password-enabled,omitempty"`
	// Enable SSH key-based login in the template
	SSHKeyEnabled *bool `json:"ssh-key-enabled,omitempty"`
}

// Promote a Snapshot to a Template
func (c ClientAPI) PromoteSnapshotToTemplate(ctx context.Context, id UUID, req PromoteSnapshotToTemplateRequest) (*Operation, error) {
	path := fmt.Sprintf("/snapshot/%v:promote", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("PromoteSnapshotToTemplate: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("PromoteSnapshotToTemplate: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("PromoteSnapshotToTemplate: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("PromoteSnapshotToTemplate: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request PromoteSnapshotToTemplate returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("PromoteSnapshotToTemplate: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListSOSBucketsUsageResponse struct {
	SOSBucketsUsage []SOSBucketUsage `json:"sos-buckets-usage,omitempty"`
}

// List SOS Buckets Usage
func (c ClientAPI) ListSOSBucketsUsage(ctx context.Context) (*ListSOSBucketsUsageResponse, error) {
	path := "/sos-buckets-usage"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListSOSBucketsUsage: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListSOSBucketsUsage: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListSOSBucketsUsage: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListSOSBucketsUsage returned %d code", resp.StatusCode)
	}

	bodyresp := &ListSOSBucketsUsageResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListSOSBucketsUsage: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type GetSOSPresignedURLResponse struct {
	URL string `json:"url,omitempty"`
}

type GetSOSPresignedURLOpt func(url.Values)

func GetSOSPresignedURLWithKey(key string) GetSOSPresignedURLOpt {
	return func(q url.Values) {
		q.Add("key", fmt.Sprint(key))
	}
}

// Generates Presigned Download URL for SOS object
func (c ClientAPI) GetSOSPresignedURL(ctx context.Context, bucket string, opts ...GetSOSPresignedURLOpt) (*GetSOSPresignedURLResponse, error) {
	path := fmt.Sprintf("/sos/%v/presigned-url", bucket)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetSOSPresignedURL: new request: %w", err)
	}

	if len(opts) > 0 {
		q := request.URL.Query()
		for _, opt := range opts {
			opt(q)
		}
		request.URL.RawQuery = q.Encode()
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetSOSPresignedURL: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetSOSPresignedURL: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetSOSPresignedURL returned %d code", resp.StatusCode)
	}

	bodyresp := &GetSOSPresignedURLResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetSOSPresignedURL: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListSSHKeysResponse struct {
	SSHKeys []SSHKey `json:"ssh-keys,omitempty"`
}

// List SSH keys
func (c ClientAPI) ListSSHKeys(ctx context.Context) (*ListSSHKeysResponse, error) {
	path := "/ssh-key"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListSSHKeys: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListSSHKeys: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListSSHKeys: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListSSHKeys returned %d code", resp.StatusCode)
	}

	bodyresp := &ListSSHKeysResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListSSHKeys: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type RegisterSSHKeyRequest struct {
	// Private Network name
	Name string `json:"name" validate:"required"`
	// Public key value
	PublicKey string `json:"public-key" validate:"required"`
}

// Import SSH key
func (c ClientAPI) RegisterSSHKey(ctx context.Context, req RegisterSSHKeyRequest) (*Operation, error) {
	path := "/ssh-key"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("RegisterSSHKey: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("RegisterSSHKey: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("RegisterSSHKey: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("RegisterSSHKey: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request RegisterSSHKey returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("RegisterSSHKey: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a SSH key
func (c ClientAPI) DeleteSSHKey(ctx context.Context, name string) (*Operation, error) {
	path := fmt.Sprintf("/ssh-key/%v", name)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteSSHKey: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteSSHKey: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteSSHKey: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteSSHKey returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteSSHKey: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve SSH key details
func (c ClientAPI) GetSSHKey(ctx context.Context, name string) (*SSHKey, error) {
	path := fmt.Sprintf("/ssh-key/%v", name)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetSSHKey: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetSSHKey: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetSSHKey: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetSSHKey returned %d code", resp.StatusCode)
	}

	bodyresp := &SSHKey{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetSSHKey: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListTemplatesResponse struct {
	Templates []Template `json:"templates,omitempty"`
}

type ListTemplatesVisibility string

const (
	ListTemplatesVisibilityPrivate ListTemplatesVisibility = "private"
	ListTemplatesVisibilityPublic  ListTemplatesVisibility = "public"
)

type ListTemplatesOpt func(url.Values)

func ListTemplatesWithVisibility(visibility ListTemplatesVisibility) ListTemplatesOpt {
	return func(q url.Values) {
		q.Add("visibility", fmt.Sprint(visibility))
	}
}

func ListTemplatesWithFamily(family string) ListTemplatesOpt {
	return func(q url.Values) {
		q.Add("family", fmt.Sprint(family))
	}
}

// List Templates
func (c ClientAPI) ListTemplates(ctx context.Context, opts ...ListTemplatesOpt) (*ListTemplatesResponse, error) {
	path := "/template"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListTemplates: new request: %w", err)
	}

	if len(opts) > 0 {
		q := request.URL.Query()
		for _, opt := range opts {
			opt(q)
		}
		request.URL.RawQuery = q.Encode()
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListTemplates: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListTemplates: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListTemplates returned %d code", resp.StatusCode)
	}

	bodyresp := &ListTemplatesResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListTemplates: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type RegisterTemplateRequestBootMode string

const (
	RegisterTemplateRequestBootModeLegacy RegisterTemplateRequestBootMode = "legacy"
	RegisterTemplateRequestBootModeUefi   RegisterTemplateRequestBootMode = "uefi"
)

type RegisterTemplateRequest struct {
	// Boot mode (default: legacy)
	BootMode RegisterTemplateRequestBootMode `json:"boot-mode,omitempty"`
	// Template build
	Build string `json:"build,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Template MD5 checksum
	Checksum string `json:"checksum" validate:"required,gte=1"`
	// Template default user
	DefaultUser string `json:"default-user,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Template description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Template maintainer
	Maintainer string `json:"maintainer,omitempty" validate:"omitempty,gte=1,lte=255"`
	// Template name
	Name string `json:"name" validate:"required,gte=1,lte=255"`
	// Enable password-based login
	PasswordEnabled *bool `json:"password-enabled" validate:"required"`
	// Template size
	Size int64 `json:"size,omitempty" validate:"omitempty,gt=0"`
	// Enable SSH key-based login
	SSHKeyEnabled *bool `json:"ssh-key-enabled" validate:"required"`
	// Template source URL
	URL string `json:"url" validate:"required,gte=1"`
	// Template version
	Version string `json:"version,omitempty" validate:"omitempty,gte=1,lte=255"`
}

// Register a Template
func (c ClientAPI) RegisterTemplate(ctx context.Context, req RegisterTemplateRequest) (*Operation, error) {
	path := "/template"

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("RegisterTemplate: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("RegisterTemplate: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("RegisterTemplate: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("RegisterTemplate: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request RegisterTemplate returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("RegisterTemplate: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Delete a Template
func (c ClientAPI) DeleteTemplate(ctx context.Context, id UUID) (*Operation, error) {
	path := fmt.Sprintf("/template/%v", id)

	request, err := http.NewRequestWithContext(ctx, "DELETE", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("DeleteTemplate: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("DeleteTemplate: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("DeleteTemplate: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request DeleteTemplate returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("DeleteTemplate: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Retrieve Template details
func (c ClientAPI) GetTemplate(ctx context.Context, id UUID) (*Template, error) {
	path := fmt.Sprintf("/template/%v", id)

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("GetTemplate: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("GetTemplate: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("GetTemplate: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request GetTemplate returned %d code", resp.StatusCode)
	}

	bodyresp := &Template{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("GetTemplate: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type CopyTemplateRequest struct {
	// Zone
	TargetZone *Zone `json:"target-zone" validate:"required"`
}

// Copy a Template from a zone to another
func (c ClientAPI) CopyTemplate(ctx context.Context, id UUID, req CopyTemplateRequest) (*Operation, error) {
	path := fmt.Sprintf("/template/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("CopyTemplate: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "POST", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("CopyTemplate: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("CopyTemplate: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("CopyTemplate: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request CopyTemplate returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("CopyTemplate: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type UpdateTemplateRequest struct {
	// Template Description
	Description string `json:"description,omitempty" validate:"omitempty,lte=255"`
	// Template name
	Name string `json:"name,omitempty" validate:"omitempty,gte=1,lte=255"`
}

// Update template attributes
func (c ClientAPI) UpdateTemplate(ctx context.Context, id UUID, req UpdateTemplateRequest) (*Operation, error) {
	path := fmt.Sprintf("/template/%v", id)

	body, err := prepareJsonBody(req)
	if err != nil {
		return nil, fmt.Errorf("UpdateTemplate: prepare Json body: %w", err)
	}

	request, err := http.NewRequestWithContext(ctx, "PUT", c.serverURL+path, body)
	if err != nil {
		return nil, fmt.Errorf("UpdateTemplate: new request: %w", err)
	}

	request.Header.Add("Content-Type", "application/json")

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("UpdateTemplate: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("UpdateTemplate: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request UpdateTemplate returned %d code", resp.StatusCode)
	}

	bodyresp := &Operation{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("UpdateTemplate: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

type ListZonesResponse struct {
	Zones []Zone `json:"zones,omitempty"`
}

// List Zones
func (c ClientAPI) ListZones(ctx context.Context) (*ListZonesResponse, error) {
	path := "/zone"

	request, err := http.NewRequestWithContext(ctx, "GET", c.serverURL+path, nil)
	if err != nil {
		return nil, fmt.Errorf("ListZones: new request: %w", err)
	}

	if err := registerRequestMiddlewares(&c, ctx, request); err != nil {
		return nil, fmt.Errorf("ListZones: register middlewares: %w", err)
	}

	resp, err := c.httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("ListZones: http client do: %w", err)
	}

	if resp.StatusCode < http.StatusOK || resp.StatusCode > http.StatusIMUsed {
		return nil, fmt.Errorf("request ListZones returned %d code", resp.StatusCode)
	}

	bodyresp := &ListZonesResponse{}
	if err := prepareJsonResponse(resp, bodyresp); err != nil {
		return nil, fmt.Errorf("ListZones: prepare Json response: %w", err)
	}

	return bodyresp, nil
}

// Client represents an API interface representation for ClientAPI and mock test.
type Client interface {
	// List IAM Access Keys
	ListAccessKeys(ctx context.Context) (*ListAccessKeysResponse, error)
	// This operation creates a legacy IAM Access Key, to create a key for use with IAM roles use the api-key endpoint.The corresponding secret is only available in the response returned by this operation, the caller must take care of storing it safely as there is no other way to retrieve it.
	CreateAccessKey(ctx context.Context, req CreateAccessKeyRequest) (*AccessKey, error)
	// Retrieve all known available IAM Access Key operations and associated tags
	ListAccessKeyKnownOperations(ctx context.Context) (*ListAccessKeyKnownOperationsResponse, error)
	// Retrieve IAM Access Key operations and associated tags for the signing key
	ListAccessKeyOperations(ctx context.Context) (*ListAccessKeyOperationsResponse, error)
	// This operation revokes the specified IAM Access Key. Access Keys created by the revoked Access Key will not be revoked.
	RevokeAccessKey(ctx context.Context, key string) (*Operation, error)
	// Retrieve IAM Access Key details
	GetAccessKey(ctx context.Context, key string) (*AccessKey, error)
	// List Anti-affinity Groups
	ListAntiAffinityGroups(ctx context.Context) (*ListAntiAffinityGroupsResponse, error)
	// Create an Anti-affinity Group
	CreateAntiAffinityGroup(ctx context.Context, req CreateAntiAffinityGroupRequest) (*Operation, error)
	// Delete an Anti-affinity Group
	DeleteAntiAffinityGroup(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve Anti-affinity Group details
	GetAntiAffinityGroup(ctx context.Context, id UUID) (*AntiAffinityGroup, error)
	// List API keys
	ListAPIKeys(ctx context.Context) (*ListAPIKeysResponse, error)
	// Create a new API key
	CreateAPIKey(ctx context.Context, req CreateAPIKeyRequest) (*IAMAPIKeyCreated, error)
	// Delete an API key
	DeleteAPIKey(ctx context.Context, id string) (*Operation, error)
	// Get API key
	GetAPIKey(ctx context.Context, id string) (*IAMAPIKey, error)
	// Returns a CA Certificate required to reach a DBaaS service through a TLS-protected connection.
	GetDBAASCACertificate(ctx context.Context) (*GetDBAASCACertificateResponse, error)
	// Delete a Grafana service
	DeleteDBAASServiceGrafana(ctx context.Context, name string) (*Operation, error)
	// Get a DBaaS Grafana service
	GetDBAASServiceGrafana(ctx context.Context, name string) (*DBAASServiceGrafana, error)
	// Create a DBaaS Grafana service
	CreateDBAASServiceGrafana(ctx context.Context, name string, req CreateDBAASServiceGrafanaRequest) (*Operation, error)
	// Update a DBaaS Grafana service
	UpdateDBAASServiceGrafana(ctx context.Context, name string, req UpdateDBAASServiceGrafanaRequest) (*Operation, error)
	// Initiate Grafana maintenance update
	StartDBAASGrafanaMaintenance(ctx context.Context, name string) (*Operation, error)
	// Create a new DBaaS integration between two services
	CreateDBAASIntegration(ctx context.Context, req CreateDBAASIntegrationRequest) (*Operation, error)
	// Get DBaaS integration settings
	ListDBAASIntegrationSettings(ctx context.Context, integrationType string, sourceType string, destType string) (*ListDBAASIntegrationSettingsResponse, error)
	// Get DBaaS integration types
	ListDBAASIntegrationTypes(ctx context.Context) (*ListDBAASIntegrationTypesResponse, error)
	// Delete a DBaaS Integration
	DeleteDBAASIntegration(ctx context.Context, id UUID) (*Operation, error)
	// Get a DBaaS Integration
	GetDBAASIntegration(ctx context.Context, id UUID) (*DBAASIntegration, error)
	// Update a existing DBaaS integration
	UpdateDBAASIntegration(ctx context.Context, id UUID, req UpdateDBAASIntegrationRequest) (*Operation, error)
	// Delete a Kafka service
	DeleteDBAASServiceKafka(ctx context.Context, name string) (*Operation, error)
	// Get a DBaaS Kafka service
	GetDBAASServiceKafka(ctx context.Context, name string) (*DBAASServiceKafka, error)
	// Create a DBaaS Kafka service
	CreateDBAASServiceKafka(ctx context.Context, name string, req CreateDBAASServiceKafkaRequest) (*Operation, error)
	// Update a DBaaS Kafka service
	UpdateDBAASServiceKafka(ctx context.Context, name string, req UpdateDBAASServiceKafkaRequest) (*Operation, error)
	// Get DBaaS kafka ACL configuration
	GetDBAASKafkaAclConfig(ctx context.Context, name string) (*DBAASKafkaAcls, error)
	// Initiate Kafka maintenance update
	StartDBAASKafkaMaintenance(ctx context.Context, name string) (*Operation, error)
	// Add a Kafka Schema Registry ACL entry
	CreateDBAASKafkaSchemaRegistryAclConfig(ctx context.Context, name string, req DBAASKafkaSchemaRegistryAclEntry) (*Operation, error)
	// Delete a Kafka ACL entry
	DeleteDBAASKafkaSchemaRegistryAclConfig(ctx context.Context, name string, aclID string) (*Operation, error)
	// Add a Kafka topic ACL entry
	CreateDBAASKafkaTopicAclConfig(ctx context.Context, name string, req DBAASKafkaTopicAclEntry) (*Operation, error)
	// Delete a Kafka ACL entry
	DeleteDBAASKafkaTopicAclConfig(ctx context.Context, name string, aclID string) (*Operation, error)
	// Create a DBaaS Kafka user
	CreateDBAASKafkaUser(ctx context.Context, serviceName string, req CreateDBAASKafkaUserRequest) (*Operation, error)
	// Delete a DBaaS kafka user
	DeleteDBAASKafkaUser(ctx context.Context, serviceName string, username string) (*Operation, error)
	// If no password is provided one will be generated automatically.
	ResetDBAASKafkaUserPassword(ctx context.Context, serviceName string, username string, req ResetDBAASKafkaUserPasswordRequest) (*Operation, error)
	// Get a DBaaS migration status
	GetDBAASMigrationStatus(ctx context.Context, name string) (*DBAASMigrationStatus, error)
	// Delete a MySQL service
	DeleteDBAASServiceMysql(ctx context.Context, name string) (*Operation, error)
	// Get a DBaaS MySQL service
	GetDBAASServiceMysql(ctx context.Context, name string) (*DBAASServiceMysql, error)
	// Create a DBaaS MySQL service
	CreateDBAASServiceMysql(ctx context.Context, name string, req CreateDBAASServiceMysqlRequest) (*Operation, error)
	// Update a DBaaS MySQL service
	UpdateDBAASServiceMysql(ctx context.Context, name string, req UpdateDBAASServiceMysqlRequest) (*Operation, error)
	// Initiate MySQL maintenance update
	StartDBAASMysqlMaintenance(ctx context.Context, name string) (*Operation, error)
	// Stop a DBaaS MySQL migration
	StopDBAASMysqlMigration(ctx context.Context, name string) (*Operation, error)
	// Create a DBaaS MySQL database
	CreateDBAASMysqlDatabase(ctx context.Context, serviceName string, req CreateDBAASMysqlDatabaseRequest) (*Operation, error)
	// Delete a DBaaS MySQL database
	DeleteDBAASMysqlDatabase(ctx context.Context, serviceName string, databaseName string) (*Operation, error)
	// Create a DBaaS MySQL user
	CreateDBAASMysqlUser(ctx context.Context, serviceName string, req CreateDBAASMysqlUserRequest) (*Operation, error)
	// Delete a DBaaS MySQL user
	DeleteDBAASMysqlUser(ctx context.Context, serviceName string, username string) (*Operation, error)
	// If no password is provided one will be generated automatically.
	ResetDBAASMysqlUserPassword(ctx context.Context, serviceName string, username string, req ResetDBAASMysqlUserPasswordRequest) (*Operation, error)
	// Delete a OpenSearch service
	DeleteDBAASServiceOpensearch(ctx context.Context, name string) (*Operation, error)
	// Get a DBaaS OpenSearch service
	GetDBAASServiceOpensearch(ctx context.Context, name string) (*DBAASServiceOpensearch, error)
	// Create a DBaaS OpenSearch service
	CreateDBAASServiceOpensearch(ctx context.Context, name string, req CreateDBAASServiceOpensearchRequest) (*Operation, error)
	// Update a DBaaS OpenSearch service
	UpdateDBAASServiceOpensearch(ctx context.Context, name string, req UpdateDBAASServiceOpensearchRequest) (*Operation, error)
	// Get DBaaS OpenSearch ACL configuration
	GetDBAASOpensearchAclConfig(ctx context.Context, name string) (*DBAASOpensearchAclConfig, error)
	// Create a DBaaS OpenSearch ACL configuration
	UpdateDBAASOpensearchAclConfig(ctx context.Context, name string, req DBAASOpensearchAclConfig) (*Operation, error)
	// Initiate OpenSearch maintenance update
	StartDBAASOpensearchMaintenance(ctx context.Context, name string) (*Operation, error)
	// Create a DBaaS OpenSearch user
	CreateDBAASOpensearchUser(ctx context.Context, serviceName string, req CreateDBAASOpensearchUserRequest) (*Operation, error)
	// Delete a DBaaS OpenSearch user
	DeleteDBAASOpensearchUser(ctx context.Context, serviceName string, username string) (*Operation, error)
	// If no password is provided one will be generated automatically.
	ResetDBAASOpensearchUserPassword(ctx context.Context, serviceName string, username string, req ResetDBAASOpensearchUserPasswordRequest) (*Operation, error)
	// Delete a Postgres service
	DeleteDBAASServicePG(ctx context.Context, name string) (*Operation, error)
	// Get a DBaaS PostgreSQL service
	GetDBAASServicePG(ctx context.Context, name string) (*DBAASServicePG, error)
	// Create a DBaaS PostgreSQL service
	CreateDBAASServicePG(ctx context.Context, name string, req CreateDBAASServicePGRequest) (*Operation, error)
	// Update a DBaaS PostgreSQL service
	UpdateDBAASServicePG(ctx context.Context, name string, req UpdateDBAASServicePGRequest) (*Operation, error)
	// Initiate PostgreSQL maintenance update
	StartDBAASPGMaintenance(ctx context.Context, name string) (*Operation, error)
	// Stop a DBaaS PostgreSQL migration
	StopDBAASPGMigration(ctx context.Context, name string) (*Operation, error)
	// Create a DBaaS PostgreSQL connection pool
	CreateDBAASPGConnectionPool(ctx context.Context, serviceName string, req CreateDBAASPGConnectionPoolRequest) (*Operation, error)
	// Delete a DBaaS PostgreSQL connection pool
	DeleteDBAASPGConnectionPool(ctx context.Context, serviceName string, connectionPoolName string) (*Operation, error)
	// Update a DBaaS PostgreSQL connection pool
	UpdateDBAASPGConnectionPool(ctx context.Context, serviceName string, connectionPoolName string, req UpdateDBAASPGConnectionPoolRequest) (*Operation, error)
	// Create a DBaaS Postgres database
	CreateDBAASPGDatabase(ctx context.Context, serviceName string, req CreateDBAASPGDatabaseRequest) (*Operation, error)
	// Delete a DBaaS Postgres database
	DeleteDBAASPGDatabase(ctx context.Context, serviceName string, databaseName string) (*Operation, error)
	// Create a DBaaS Postgres user
	CreateDBAASPostgresUser(ctx context.Context, serviceName string, req CreateDBAASPostgresUserRequest) (*Operation, error)
	// Delete a DBaaS Postgres user
	DeleteDBAASPostgresUser(ctx context.Context, serviceName string, username string) (*Operation, error)
	// Update access control for one service user
	UpdateDBAASPostgresAllowReplication(ctx context.Context, serviceName string, username string, req UpdateDBAASPostgresAllowReplicationRequest) (*DBAASPostgresUsers, error)
	// If no password is provided one will be generated automatically.
	ResetDBAASPostgresUserPassword(ctx context.Context, serviceName string, username string, req ResetDBAASPostgresUserPasswordRequest) (*Operation, error)
	// Check whether you can upgrade Postgres service to a newer version
	CreateDBAASPGUpgradeCheck(ctx context.Context, service string, req CreateDBAASPGUpgradeCheckRequest) (*DBAASTask, error)
	// Delete a Redis service
	DeleteDBAASServiceRedis(ctx context.Context, name string) (*Operation, error)
	// Get a DBaaS Redis service
	GetDBAASServiceRedis(ctx context.Context, name string) (*DBAASServiceRedis, error)
	// Create a DBaaS Redis service
	CreateDBAASServiceRedis(ctx context.Context, name string, req CreateDBAASServiceRedisRequest) (*Operation, error)
	// Update a DBaaS Redis service
	UpdateDBAASServiceRedis(ctx context.Context, name string, req UpdateDBAASServiceRedisRequest) (*Operation, error)
	// Initiate Redis maintenance update
	StartDBAASRedisMaintenance(ctx context.Context, name string) (*Operation, error)
	// Stop a DBaaS Redis migration
	StopDBAASRedisMigration(ctx context.Context, name string) (*Operation, error)
	// List DBaaS services
	ListDBAASServices(ctx context.Context) (*ListDBAASServicesResponse, error)
	// Get logs of DBaaS service
	GetDBAASServiceLogs(ctx context.Context, serviceName string, req GetDBAASServiceLogsRequest) (*DBAASServiceLogs, error)
	// Get metrics of DBaaS service
	GetDBAASServiceMetrics(ctx context.Context, serviceName string, req GetDBAASServiceMetricsRequest) (*GetDBAASServiceMetricsResponse, error)
	// List available service types for DBaaS
	ListDBAASServiceTypes(ctx context.Context) (*ListDBAASServiceTypesResponse, error)
	// Get a DBaaS service type
	GetDBAASServiceType(ctx context.Context, serviceTypeName string) (*DBAASServiceType, error)
	// Delete a DBaaS service
	DeleteDBAASService(ctx context.Context, name string) (*Operation, error)
	// Get DBaaS Grafana settings
	GetDBAASSettingsGrafana(ctx context.Context) (*GetDBAASSettingsGrafanaResponse, error)
	// Get DBaaS Kafka settings
	GetDBAASSettingsKafka(ctx context.Context) (*GetDBAASSettingsKafkaResponse, error)
	// Get DBaaS MySQL settings
	GetDBAASSettingsMysql(ctx context.Context) (*GetDBAASSettingsMysqlResponse, error)
	// Get DBaaS OpenSearch settings
	GetDBAASSettingsOpensearch(ctx context.Context) (*GetDBAASSettingsOpensearchResponse, error)
	// Get DBaaS PostgreSQL settings
	GetDBAASSettingsPG(ctx context.Context) (*GetDBAASSettingsPGResponse, error)
	// Returns the default settings for Redis.
	GetDBAASSettingsRedis(ctx context.Context) (*GetDBAASSettingsRedisResponse, error)
	// Create a DBaaS task to check migration
	CreateDBAASTaskMigrationCheck(ctx context.Context, service string, req CreateDBAASTaskMigrationCheckRequest) (*Operation, error)
	// Get a DBaaS task
	GetDBAASTask(ctx context.Context, service string, id UUID) (*DBAASTask, error)
	// List Deploy Targets
	ListDeployTargets(ctx context.Context) (*ListDeployTargetsResponse, error)
	// Retrieve Deploy Target details
	GetDeployTarget(ctx context.Context, id UUID) (*DeployTarget, error)
	// List DNS domains
	ListDNSDomains(ctx context.Context) (*ListDNSDomainsResponse, error)
	// Create DNS domain
	CreateDNSDomain(ctx context.Context, req CreateDNSDomainRequest) (*DNSDomain, error)
	// List DNS domain records
	ListDNSDomainRecords(ctx context.Context, domainID UUID) (*ListDNSDomainRecordsResponse, error)
	// Create DNS domain record
	CreateDNSDomainRecord(ctx context.Context, domainID UUID, req CreateDNSDomainRecordRequest) (*Operation, error)
	// Delete DNS domain record
	DeleteDNSDomainRecord(ctx context.Context, domainID UUID, recordID UUID) (*Operation, error)
	// Retrieve DNS domain record details
	GetDNSDomainRecord(ctx context.Context, domainID UUID, recordID UUID) (*DNSDomainRecord, error)
	// Update DNS domain record
	UpdateDNSDomainRecord(ctx context.Context, domainID UUID, recordID UUID, req UpdateDNSDomainRecordRequest) (*Operation, error)
	// Delete DNS Domain
	DeleteDNSDomain(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve DNS domain details
	GetDNSDomain(ctx context.Context, id UUID) (*DNSDomain, error)
	// Retrieve DNS domain zone file
	GetDNSDomainZoneFile(ctx context.Context, id UUID) (*GetDNSDomainZoneFileResponse, error)
	// List Elastic IPs
	ListElasticIPS(ctx context.Context) (*ListElasticIPSResponse, error)
	// Create an Elastic IP
	CreateElasticIP(ctx context.Context, req CreateElasticIPRequest) (*Operation, error)
	// Delete an Elastic IP
	DeleteElasticIP(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve Elastic IP details
	GetElasticIP(ctx context.Context, id UUID) (*ElasticIP, error)
	// Update an Elastic IP
	UpdateElasticIP(ctx context.Context, id UUID, req UpdateElasticIPRequest) (*Operation, error)
	// Reset an Elastic IP field to its default value
	ResetElasticIPField(ctx context.Context, id UUID, field ResetElasticIPFieldField) (*Operation, error)
	// Attach a Compute instance to an Elastic IP
	AttachInstanceToElasticIP(ctx context.Context, id UUID, req AttachInstanceToElasticIPRequest) (*Operation, error)
	// Detach a Compute instance from an Elastic IP
	DetachInstanceFromElasticIP(ctx context.Context, id UUID, req DetachInstanceFromElasticIPRequest) (*Operation, error)
	// Retrieve Mutation Events for a given date range. Defaults to retrieving Events for the past 24 hours.
	// Both a `from` and `to` arguments can be specified to filter Events over a specific period.
	// Events will be the the most descriptive possible but not all fields are mandatory
	ListEvents(ctx context.Context, opts ...ListEventsOpt) ([]Event, error)
	// Retrieve IAM Organization Policy
	GetIAMOrganizationPolicy(ctx context.Context) (*IAMPolicy, error)
	// Update IAM Organization Policy
	UpdateIAMOrganizationPolicy(ctx context.Context, req IAMPolicy) (*Operation, error)
	// List IAM Roles
	ListIAMRoles(ctx context.Context) (*ListIAMRolesResponse, error)
	// Create IAM Role
	CreateIAMRole(ctx context.Context, req CreateIAMRoleRequest) (*Operation, error)
	// Delete IAM Role
	DeleteIAMRole(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve IAM Role
	GetIAMRole(ctx context.Context, id UUID) (*IAMRole, error)
	// Update IAM Role
	UpdateIAMRole(ctx context.Context, id UUID, req UpdateIAMRoleRequest) (*Operation, error)
	// Update IAM Role Policy
	UpdateIAMRolePolicy(ctx context.Context, id UUID, req IAMPolicy) (*Operation, error)
	// List Compute instances
	ListInstances(ctx context.Context, opts ...ListInstancesOpt) (*ListInstancesResponse, error)
	// Create a Compute instance
	CreateInstance(ctx context.Context, req CreateInstanceRequest) (*Operation, error)
	// List Instance Pools
	ListInstancePools(ctx context.Context) (*ListInstancePoolsResponse, error)
	// Create an Instance Pool
	CreateInstancePool(ctx context.Context, req CreateInstancePoolRequest) (*Operation, error)
	// Delete an Instance Pool
	DeleteInstancePool(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve Instance Pool details
	GetInstancePool(ctx context.Context, id UUID) (*InstancePool, error)
	// Update an Instance Pool
	UpdateInstancePool(ctx context.Context, id UUID, req UpdateInstancePoolRequest) (*Operation, error)
	// Reset an Instance Pool field to its default value
	ResetInstancePoolField(ctx context.Context, id UUID, field ResetInstancePoolFieldField) (*Operation, error)
	// This operation evicts the specified Compute instances member from the Instance Pool, shrinking it to `&lt;current pool size&gt; - &lt;# evicted members&gt;`.
	EvictInstancePoolMembers(ctx context.Context, id UUID, req EvictInstancePoolMembersRequest) (*Operation, error)
	// Scale an Instance Pool
	ScaleInstancePool(ctx context.Context, id UUID, req ScaleInstancePoolRequest) (*Operation, error)
	// List Compute instance Types
	ListInstanceTypes(ctx context.Context) (*ListInstanceTypesResponse, error)
	// Retrieve Instance Type details
	GetInstanceType(ctx context.Context, id UUID) (*InstanceType, error)
	// Delete a Compute instance
	DeleteInstance(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve Compute instance details
	GetInstance(ctx context.Context, id UUID) (*Instance, error)
	// Update a Compute instance
	UpdateInstance(ctx context.Context, id UUID, req UpdateInstanceRequest) (*Operation, error)
	// Reset Instance field
	ResetInstanceField(ctx context.Context, id UUID, field ResetInstanceFieldField) (*Operation, error)
	// Set instance destruction protection
	AddInstanceProtection(ctx context.Context, id UUID) (*AddInstanceProtectionResponse, error)
	// Create a Snapshot of a Compute instance
	CreateSnapshot(ctx context.Context, id UUID) (*Operation, error)
	// Reveal the password used during instance creation or the latest password reset.
	// This is only available for VMs created against templates having the `password-enabled`
	// property set to `true`.
	// creation or resets.
	// creation or resets.
	RevealInstancePassword(ctx context.Context, id UUID) (*InstancePassword, error)
	// Reboot a Compute instance
	RebootInstance(ctx context.Context, id UUID) (*Operation, error)
	// Remove instance destruction protection
	RemoveInstanceProtection(ctx context.Context, id UUID) (*RemoveInstanceProtectionResponse, error)
	// This operation re-installs a Compute instance to a base template. If target template is provided it will be used to recreated instance from. Warning: the operation wipes all data stored on the disk.
	ResetInstance(ctx context.Context, id UUID, req ResetInstanceRequest) (*Operation, error)
	// Reset a compute instance password
	ResetInstancePassword(ctx context.Context, id UUID) (*Operation, error)
	// This operation resizes a Compute instance's disk volume. Note: the disk can only grow, cannot be shrunk.
	ResizeInstanceDisk(ctx context.Context, id UUID, req ResizeInstanceDiskRequest) (*Operation, error)
	// This operation changes the Compute instance's type. Note: the new Instance Type must be within the same family (e.g. a standard instance cannot be scaled to gpu2 or storage).
	ScaleInstance(ctx context.Context, id UUID, req ScaleInstanceRequest) (*Operation, error)
	// This operation starts a virtual machine, potentially using a rescue profile if specified
	StartInstance(ctx context.Context, id UUID, req StartInstanceRequest) (*Operation, error)
	// Stop a Compute instance
	StopInstance(ctx context.Context, id UUID) (*Operation, error)
	// This operation reverts the snapshot to the Compute instance volume, restoring stored data as it was at the time of the snapshot.
	// The Compute instance must be previously stopped.
	RevertInstanceToSnapshot(ctx context.Context, instanceID UUID, req RevertInstanceToSnapshotRequest) (*Operation, error)
	// List Load Balancers
	ListLoadBalancers(ctx context.Context) (*ListLoadBalancersResponse, error)
	// Create a Load Balancer
	CreateLoadBalancer(ctx context.Context, req CreateLoadBalancerRequest) (*Operation, error)
	// Delete a Load Balancer
	DeleteLoadBalancer(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve Load Balancer details
	GetLoadBalancer(ctx context.Context, id UUID) (*LoadBalancer, error)
	// Update a Load Balancer
	UpdateLoadBalancer(ctx context.Context, id UUID, req UpdateLoadBalancerRequest) (*Operation, error)
	// Add a Load Balancer Service
	AddServiceToLoadBalancer(ctx context.Context, id UUID, req AddServiceToLoadBalancerRequest) (*Operation, error)
	// Delete a Load Balancer Service
	DeleteLoadBalancerService(ctx context.Context, id UUID, serviceID UUID) (*Operation, error)
	// Retrieve Load Balancer Service details
	GetLoadBalancerService(ctx context.Context, id UUID, serviceID UUID) (*LoadBalancerService, error)
	// Update a Load Balancer Service
	UpdateLoadBalancerService(ctx context.Context, id UUID, serviceID UUID, req UpdateLoadBalancerServiceRequest) (*Operation, error)
	// Reset a Load Balancer Service field to its default value
	ResetLoadBalancerServiceField(ctx context.Context, id UUID, serviceID UUID, field ResetLoadBalancerServiceFieldField) (*Operation, error)
	// Reset a Load Balancer field to its default value
	ResetLoadBalancerField(ctx context.Context, id UUID, field ResetLoadBalancerFieldField) (*Operation, error)
	// Retrieve Operation details
	GetOperation(ctx context.Context, id UUID) (*Operation, error)
	// List Private Networks
	ListPrivateNetworks(ctx context.Context) (*ListPrivateNetworksResponse, error)
	// Create a Private Network
	CreatePrivateNetwork(ctx context.Context, req CreatePrivateNetworkRequest) (*Operation, error)
	// Delete a Private Network
	DeletePrivateNetwork(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve Private Network details
	GetPrivateNetwork(ctx context.Context, id UUID) (*PrivateNetwork, error)
	// Update a Private Network
	UpdatePrivateNetwork(ctx context.Context, id UUID, req UpdatePrivateNetworkRequest) (*Operation, error)
	// Reset Private Network field
	ResetPrivateNetworkField(ctx context.Context, id UUID, field ResetPrivateNetworkFieldField) (*Operation, error)
	// Attach a Compute instance to a Private Network
	AttachInstanceToPrivateNetwork(ctx context.Context, id UUID, req AttachInstanceToPrivateNetworkRequest) (*Operation, error)
	// Detach a Compute instance from a Private Network
	DetachInstanceFromPrivateNetwork(ctx context.Context, id UUID, req DetachInstanceFromPrivateNetworkRequest) (*Operation, error)
	// Update the IP address of an instance attached to a managed private network
	UpdatePrivateNetworkInstanceIP(ctx context.Context, id UUID, req UpdatePrivateNetworkInstanceIPRequest) (*Operation, error)
	// List Organization Quotas
	ListQuotas(ctx context.Context) (*ListQuotasResponse, error)
	// Retrieve Resource Quota
	GetQuota(ctx context.Context, entity string) (*Quota, error)
	// Delete the PTR DNS record for an elastic IP
	DeleteReverseDNSElasticIP(ctx context.Context, id UUID) (*Operation, error)
	// Query the PTR DNS records for an elastic IP
	GetReverseDNSElasticIP(ctx context.Context, id UUID) (*ReverseDNSRecord, error)
	// Update/Create the PTR DNS record for an elastic IP
	UpdateReverseDNSElasticIP(ctx context.Context, id UUID, req UpdateReverseDNSElasticIPRequest) (*Operation, error)
	// Delete the PTR DNS record for an instance
	DeleteReverseDNSInstance(ctx context.Context, id UUID) (*Operation, error)
	// Query the PTR DNS records for an instance
	GetReverseDNSInstance(ctx context.Context, id UUID) (*ReverseDNSRecord, error)
	// Update/Create the PTR DNS record for an instance
	UpdateReverseDNSInstance(ctx context.Context, id UUID, req UpdateReverseDNSInstanceRequest) (*Operation, error)
	// Lists security groups. When visibility is set to public, lists public security groups.
	// Public security groups are objects maintained by Exoscale which contain source addresses for
	// relevant services hosted by Exoscale. They can be used a source in ingress rules and as a destination
	// in egress rules.
	ListSecurityGroups(ctx context.Context, opts ...ListSecurityGroupsOpt) (*ListSecurityGroupsResponse, error)
	// Create a Security Group
	CreateSecurityGroup(ctx context.Context, req CreateSecurityGroupRequest) (*Operation, error)
	// Delete a Security Group
	DeleteSecurityGroup(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve Security Group details
	GetSecurityGroup(ctx context.Context, id UUID) (*SecurityGroup, error)
	// Create a Security Group rule
	AddRuleToSecurityGroup(ctx context.Context, id UUID, req AddRuleToSecurityGroupRequest) (*Operation, error)
	// Delete a Security Group rule
	DeleteRuleFromSecurityGroup(ctx context.Context, id UUID, ruleID UUID) (*Operation, error)
	// Add an external source as a member of a Security Group
	AddExternalSourceToSecurityGroup(ctx context.Context, id UUID, req AddExternalSourceToSecurityGroupRequest) (*Operation, error)
	// Attach a Compute instance to a Security Group
	AttachInstanceToSecurityGroup(ctx context.Context, id UUID, req AttachInstanceToSecurityGroupRequest) (*Operation, error)
	// Detach a Compute instance from a Security Group
	DetachInstanceFromSecurityGroup(ctx context.Context, id UUID, req DetachInstanceFromSecurityGroupRequest) (*Operation, error)
	// Remove an external source from a Security Group
	RemoveExternalSourceFromSecurityGroup(ctx context.Context, id UUID, req RemoveExternalSourceFromSecurityGroupRequest) (*Operation, error)
	// List SKS clusters
	ListSKSClusters(ctx context.Context) (*ListSKSClustersResponse, error)
	// Create an SKS cluster
	CreateSKSCluster(ctx context.Context, req CreateSKSClusterRequest) (*Operation, error)
	// This operation returns the deprecated resources for a given cluster
	ListSKSClusterDeprecatedResources(ctx context.Context, id UUID) ([]SKSClusterDeprecatedResource, error)
	// This operation returns a Kubeconfig file encoded in base64.
	GenerateSKSClusterKubeconfig(ctx context.Context, id UUID, req SKSKubeconfigRequest) (*GenerateSKSClusterKubeconfigResponse, error)
	// List available versions for SKS clusters
	ListSKSClusterVersions(ctx context.Context, opts ...ListSKSClusterVersionsOpt) (*ListSKSClusterVersionsResponse, error)
	// Delete an SKS cluster
	DeleteSKSCluster(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve SKS cluster details
	GetSKSCluster(ctx context.Context, id UUID) (*SKSCluster, error)
	// Update an SKS cluster
	UpdateSKSCluster(ctx context.Context, id UUID, req UpdateSKSClusterRequest) (*Operation, error)
	// This operation returns the certificate for the given SKS cluster authority encoded in base64.
	GetSKSClusterAuthorityCert(ctx context.Context, id UUID, authority GetSKSClusterAuthorityCertAuthority) (*GetSKSClusterAuthorityCertResponse, error)
	// Helps troubleshoot common problems when deploying a kubernetes cluster. Inspections run every couple of minutes.
	GetSKSClusterInspection(ctx context.Context, id UUID) (*GetSKSClusterInspectionResponse, error)
	// Create a new SKS Nodepool
	CreateSKSNodepool(ctx context.Context, id UUID, req CreateSKSNodepoolRequest) (*Operation, error)
	// Delete an SKS Nodepool
	DeleteSKSNodepool(ctx context.Context, id UUID, sksNodepoolID UUID) (*Operation, error)
	// Retrieve SKS Nodepool details
	GetSKSNodepool(ctx context.Context, id UUID, sksNodepoolID UUID) (*SKSNodepool, error)
	// Update an SKS Nodepool
	UpdateSKSNodepool(ctx context.Context, id UUID, sksNodepoolID UUID, req UpdateSKSNodepoolRequest) (*Operation, error)
	// Reset an SKS Nodepool field to its default value
	ResetSKSNodepoolField(ctx context.Context, id UUID, sksNodepoolID UUID, field ResetSKSNodepoolFieldField) (*Operation, error)
	// This operation evicts the specified Compute instances member from the Nodepool, shrinking it to `&lt;current nodepool size&gt; - &lt;# evicted members&gt;`.
	EvictSKSNodepoolMembers(ctx context.Context, id UUID, sksNodepoolID UUID, req EvictSKSNodepoolMembersRequest) (*Operation, error)
	// Scale a SKS Nodepool
	ScaleSKSNodepool(ctx context.Context, id UUID, sksNodepoolID UUID, req ScaleSKSNodepoolRequest) (*Operation, error)
	// Rotate Exoscale CCM credentials
	RotateSKSCcmCredentials(ctx context.Context, id UUID) (*Operation, error)
	// Rotate operators certificate authority
	RotateSKSOperatorsCA(ctx context.Context, id UUID) (*Operation, error)
	// Upgrade an SKS cluster
	UpgradeSKSCluster(ctx context.Context, id UUID, req UpgradeSKSClusterRequest) (*Operation, error)
	// Upgrade a SKS cluster to pro
	UpgradeSKSClusterServiceLevel(ctx context.Context, id UUID) (*Operation, error)
	// Reset an SKS cluster field to its default value
	ResetSKSClusterField(ctx context.Context, id UUID, field ResetSKSClusterFieldField) (*Operation, error)
	// List Snapshots
	ListSnapshots(ctx context.Context) (*ListSnapshotsResponse, error)
	// Delete a Snapshot
	DeleteSnapshot(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve Snapshot details
	GetSnapshot(ctx context.Context, id UUID) (*Snapshot, error)
	// Export a Snapshot
	ExportSnapshot(ctx context.Context, id UUID) (*Operation, error)
	// Promote a Snapshot to a Template
	PromoteSnapshotToTemplate(ctx context.Context, id UUID, req PromoteSnapshotToTemplateRequest) (*Operation, error)
	// List SOS Buckets Usage
	ListSOSBucketsUsage(ctx context.Context) (*ListSOSBucketsUsageResponse, error)
	// Generates Presigned Download URL for SOS object
	GetSOSPresignedURL(ctx context.Context, bucket string, opts ...GetSOSPresignedURLOpt) (*GetSOSPresignedURLResponse, error)
	// List SSH keys
	ListSSHKeys(ctx context.Context) (*ListSSHKeysResponse, error)
	// Import SSH key
	RegisterSSHKey(ctx context.Context, req RegisterSSHKeyRequest) (*Operation, error)
	// Delete a SSH key
	DeleteSSHKey(ctx context.Context, name string) (*Operation, error)
	// Retrieve SSH key details
	GetSSHKey(ctx context.Context, name string) (*SSHKey, error)
	// List Templates
	ListTemplates(ctx context.Context, opts ...ListTemplatesOpt) (*ListTemplatesResponse, error)
	// Register a Template
	RegisterTemplate(ctx context.Context, req RegisterTemplateRequest) (*Operation, error)
	// Delete a Template
	DeleteTemplate(ctx context.Context, id UUID) (*Operation, error)
	// Retrieve Template details
	GetTemplate(ctx context.Context, id UUID) (*Template, error)
	// Copy a Template from a zone to another
	CopyTemplate(ctx context.Context, id UUID, req CopyTemplateRequest) (*Operation, error)
	// Update template attributes
	UpdateTemplate(ctx context.Context, id UUID, req UpdateTemplateRequest) (*Operation, error)
	// List Zones
	ListZones(ctx context.Context) (*ListZonesResponse, error)

	Wait(context.Context, *Operation, ...OperationState) (*Operation, error)

	WithZone(APIZone) Client

	WithContext(context.Context) Client

	WithHttpClient(*http.Client) Client

	WithRequestMiddleware(RequestMiddlewareFn) Client
}

// Wait is a helper that waits for async operation to reach the final state.
// Final states are one of: failure, success, timeout.
// If states argument are given, returns an error if the final state not match on of those.
func (c ClientAPI) Wait(ctx context.Context, op *Operation, states ...OperationState) (*Operation, error) {
	if op == nil {
		return nil, fmt.Errorf("operation is nil")
	}

	ticker := time.NewTicker(c.pollingInterval)
	defer ticker.Stop()

	if op.State != OperationStatePending {
		return op, nil
	}

	var operation *Operation
polling:
	for {
		select {
		case <-ticker.C:
			o, err := c.GetOperation(ctx, op.ID)
			if err != nil {
				return nil, err
			}
			if o.State == OperationStatePending {
				continue
			}

			operation = o
			break polling
		case <-ctx.Done():
			return nil, ctx.Err()
		}
	}

	if len(states) == 0 {
		return operation, nil
	}

	for _, st := range states {
		if operation.State == st {
			return operation, nil
		}
	}

	var ref OperationReference
	if operation.Reference != nil {
		ref = *operation.Reference
	}

	return nil,
		fmt.Errorf("operation: %q %v, state: %s, reason: %q, message: %q",
			operation.ID,
			ref,
			operation.State,
			operation.Reason,
			operation.Message,
		)
}

func String(s string) *string {
	return &s
}

func Int64(i int64) *int64 {
	return &i
}

func Bool(b bool) *bool {
	return &b
}

// Validate any struct from schema or request
func Validate(r any) error {
	return validator.New().Struct(r)
}

func prepareJsonBody(body any) (*bytes.Reader, error) {
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	return bytes.NewReader(buf), nil
}

func prepareJsonResponse(resp *http.Response, v any) error {
	defer resp.Body.Close()

	buf, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	if err := json.Unmarshal(buf, v); err != nil {
		return err
	}

	return nil
}

type UUID string

func (u UUID) String() string {
	return string(u)
}

func ParseUUID(s string) (UUID, error) {
	id, err := uuid.Parse(s)
	if err != nil {
		return "", err
	}

	return UUID(id.String()), nil
}
